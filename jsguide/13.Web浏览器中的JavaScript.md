第二部分 客户端JavaScript 
# 第13章 Web浏览器中的JavaScript  
#  13-1 客户端JavaScript  
#  13-2 在HTML里嵌入JavaScript  
#  13-3 JavaScript程序的执行  
#  13-4 兼容性和互用性  
#  13-5 可访问性  
#  13-6 安全性  
#  13-7 客户端框架 

---
第13章
Web浏览器中的JavaScript
本书第一部分介绍丁JavaScript语言核心。第二部分开始转向Weh浏览器中JavaScript的
讨论，通常称为客户端JavaScript。迄今为止，我们所看到的大部分例子虽然是合祛的
JevaScript代码，但是却没有特定的上下文，也就是说它们不过是一些运行在不明环境
的代码片段。木章提供了一个可以运行JavaScript的上下文。
在丌始讨论JavaScript之前。有必安先思考一下在Web浏览器中是如何兰现Web页面的。
一些呈现静态信息的页面，叫做文档(document) (由于加入了JavaScript,静态页面的
信息看上去会动来动去，但信息本身是静态的)，相对丁文档来说，其他Web页面则感觉
上更像是应用。如果需要的话，这些页面可以动态裁入新的信息，因此看起来吏加图形
化、而非文本化，并且它们可以进行离线操作，以及保存数据到本地，以便再次访问时
进行状态恢复。此外,还有其他Web页面处于文档和应用的中问，结合了两者的特性。
本章以客卢端JavaScript概述开始，包括一个简单的例子，以及对JavaScript在Web文档和
Web应用中角色的讨论。概述内容还介绍了哪些内容在后续章节中会有，接卜来会详细
解释JavaScript代码在HTML文档中是如何嵌人并执行的，然后还会介绍兼容性、可访问
性和安企性等问题。  

##  [13.1 客户端JavaScript](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

Window对象是所有客户端JavaSeript特性和AP]的主要接人点。它表示Web浏览器的一
个窗J1或窗体，并且可以用标识符window来引用它。Window对象定义了一些属性，比
如，指代Location对象的location属性，Location对象指定当前显示在窗口中的URL,并
允许脚本往窗日甲教人新的URL:.
11设置location氨性，从忻跳转到新的Web贞i面
window.location = "http://mw.creilly.com/ 

";
Window对象还定义了“些方法，比如alert()，可以弹出一个对话框用米显示一些信
息。还有setTimeout(),可以往册一个函数，在给定的一段时间之后触发一个四调:
11等待两秒，然后说hello
setTimeout(function(){ alert{"hello Nor1d"); }; 2000);
往意上面的代码并役有显式地使用window属性。在客户端JavaScript中，Window对象也
是全局对象。这意味着Window对象处于作用城链的顶部，它的属性和方法实际上是全
局变量和全局函数。Window对象有一个引用自身的属性，叫做window。如果需要引开窗
口对象本身，可以用这个属性，但是如果只是想要引用全局窗口对象的属性，通常并不
需要用到window。
Window对象还定义了很多其他重要的属性、方祛和构造函数，参见第14章查看完整的
细节。
Window对象中其中一个最重要的属性是document; 它引用Document对象，后者表示显
示在窗口中的文档。Document对象有一些重要方法,比如getElementById(),可以基于
元索id属性的值返回单一的文档元素(表示HTML标签的一对开始/结束标记，以及它们
之间的所有内容) ;
1查找id="timestamp" 的元案
var timestamp = document.getElementById("timestamp");
getElementById(}返问的Element对象布其他重要的属性和方法。比如允许脚本获取它的
内容,设跫属性值等;
/1如果元素为空，往里面捅人当前的日期和时间
if (timestamp.firstChild== null)
timestamp.appendChild(document.createTextNode(new Date( ).toString() )) ;
查询、遍历和修政文档内容的方法会在第15章介绍。
每个Element对象都有sty1e和c1assName属性。允许脚本指定文档元素的CSS样式,或修
改应用到元素上的CSS类名。设置这些CSS相关的属性会改变文档元索的呈现:
l1显式修改目标元装的呈现
timestamp.style.backgroundColorz"yellow";
// 或者只改变类，让样式表指定美体内容
timestamp.classlame = "highlight";
第16章会介绍sty1e和className属性，以及其他CSS编程技术。
Window、Document和Element对象上另--个重要的属性集合是事件处璵程序相关的属
性。可以在脚本中为之绑定一个函数，这个函数会在某个事徘发生时以异步的方式调
用。事件处理程序可以让JavaScript代码修改窗口、文档和组成文档的元素的行为。事件
处理程序的属性名是以单词“on”开始的，用法如下:
'1当用户作击timestam元案时，重新它的内容
timestamp.anclick= function(){ this.innerHTHL = new Date().toString(); }
Window对象的onload处理程序是最重要的事件处理程序之一。当显示在窗口中的文档内
容稳定开可以操作时会触发它。JavaScript代码通常封装在onload事件处理程序里。第17
章将会详细讲述事件。例13-1是onload处理程序的演示，并展示了客户端JavaScript的实
例代码，包括查询文档元素、修改CSS类和定义事件处理程序。这个例子的JavaScript代
码是放登在HTML的<script>标签之内的，且在13.2节会对它进行解释。往意代码里的
一个函数是在另一个函数里定义的。因为事件处理程序的广泛使用，使得嵌套函数在客
户端JavaSeript中非常普遍。
例13-1: 显示内容的简单客户端JavaScript
```
<!DOCTYPE htmI>
<html>
<head>
<sty1e>
本页的CSS样式发*
.reveal *{ display: none; }
/* class="revea1"的元系的千元裘都不显示*I
b1ock;}
.reveal *.handle {display;
* 除了class="hand1e"的元素*/
</style>
<5cript>
'1所有的页面逻辑在on1oad弈件之辰启动
window.onload= function() {
11找到所有class 名为"reveal"的容器元素
var elements= document-getElementsBy[lassName("reveal") ;
for (var i= 0; i< elements.length; i++){ 11对每个元案进行迫历
var elt ■elements[I];
// 找到容器中的"handle"元岽
ar title= elt.getElementsyClassName("handle")[0];
/! 当单击这个元素时，是现剩下的内容
addRevealHandler(tltle; elt);}
function addRevealHandler(title,e1t)
title.onclick= function() {
If (elt.className "n"reveal")
elt.className= "revealed";
else if (elt.classNane=="revealed")
elt.className = "reveal";
};
</script>
<thead>
<body:
<div classo"reveal">
<h1class="handle">Click Here to Reveal Hidd'n Text</h1>
<p>This panagzaph is hidden.It 
 appears when you click on the title.c/p>
<idiv>
</body>
</htm1>
```
在本章的概要介绍中提到了，
些Web页面感觉上像文档，而另一些则像应用。接下来
的两节会探讨JavaScript在两种Web页面类型里是如何使用的。  

##  [13.1.1 Web文档里的JavaScript](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

JavaScript程序可以通过Document对象和它包含的Element对象遍历和管理文档内容。它
可以通过操纵CSS样式和类，修改文档内容的呈现。并且可以通过往册适当的事件处理
程序来定义文档元素的行为。内容，呈现和行为的组合，叫{做动态HTML或DHTML,会
在第15~17章果介绍。
Wcb文档里应当少呈地使用JavaScript,因为JavaScript真正的角色是增强用户的浏览体
验，使信息的获取和传递更容易。用户的体验不应依赖于JavaScript,但JavaScript可以
增强体验，比如通过「面的方式:
创建动画和其他视觉袭果,巧妙地引导和帮助用户进行页面导航。
对表格的列进行分组，让用户更容易找到所需要的。
隐職某些内容，当用户“深人”到内容里时，再逐渐展示详细信息。
13.1.2 Web应用里的JavaScript
在Web文档中使用的JavaScript DHTML特性在Web应用中都会用到，对于Web应用来
说，除了内容、呈现和操作API之外，还依赖了Web浏览器环境提供的更基础的服务。
要真正理解Weh应用，需要先认识到Web浏览器已经有了很好的发展，现在已经不仅仅
是作为显示文档的工具的角色了，而渐渐变成了一个简易的操作系统。想一下，传统操
作系统允许组织桌面利|文件夹里的图标(表示文件或应用) ; Web浏览器允许在工具栏
和文件夹里组纵书签(表示文档利Web应用)。系统可以在一个窗口里运行多个应用I
Web浏览器叮以在一个标签里显示多个文裆。操作系统定义了很多底层刚络API.提供
绘制图像、保存文件等功能。Web浏览器也定义底层网络API (第18章)、保存数据
(第20章) 和绘制图像(第21章)。
谨记Web浏览器是简单操作系统的概念，这样就可以把Web应用定义为用JavaScript访问
更多浏览器提供的高级服务(比如网络、图像和数据存储)的Wcb页面。高级服务里最有
名的是XMLHttpRequesl对象，后者可以对HTTP请求编程来启用网络。Web应用使用这
个服务从服务器获取新信息，而不用重新载人页面。类似这样的Web应用遁常叫做Ajax
应用，Ajax构成了“Web 2.0" 的脊梁。XMLH'tpRequest会在第18章详细介绍。
HTML5标准(在撰写本书之时还是草案) 和相关的标准为Web应用定义了很多其他巫
要的APl。这些API包括第21章和第20竞的数据存储和图像API,以反很多其他特性的
API.如地理位置信息、历史管理和后台线程。在实现这些API之后，会开启:场Web应
用功能的革命。这些API会在第22章中介绍。
当然，JavaScript在Web应用甲会比在Web文档甲邱得更加乖要。JavaScript增强了Web文
档，但是设计良好的文档需要在禁用JavaScript石还能继续工作。Web应用本质上就是
JavaScrip(程序，后者使用由Web浏览器提供的操作系纰类型的服务,并且不用期望它们
在禁用浏览器脚本后还能正常工作i1。  

##  [13.2 在HTML里嵌入JavaScript](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

在HTML文档里伥人客户端JavaScript代码有4种方祛:
内联，放置在<script>和</script>标签对之间。
放置在由<script>标签的src属性指定的外部文件中。
放置在HTML事件处理程序中，该事件处理程序由onclick或onnouseover这样的
HTML属性值指定。
放在~个URL里，这个URL使用特殊的“javascript”
协议。
接下来的小节会逐一解释这4种JavaScript嵌套技术。但是，位得往意的是，HTML事件
处理程序属性和javascript: URL这两种方式在现代JavaScript代码里已经很少使用(它
们在Wcb早期多少有点通用)。内联脚本(役有src属性) 也比它们之前用得少了。有个
课芘1
编程哲学叫“unobtrusive JavaScript”
主张内容(HTML) 和行为{JavaScript代
码应该尽最地保持分离。根据这个编程哲学,JavaScript最好通过<script>元素的src
属性來嵌入HTML文档里,
利用HTML表单提交的方式和服务器满CGI脚本进行通信的交互式Web页面。是原始的
注1:
"Web应用".可以不用JavaScript参实现。但是，我们不会在本书中"讨论这种Wcb应用"
类型。
译注1: Unsbtrusive JavaScript是一种将JavaScript从HTML结构中抽离的设计概念，避免在HTML
标签中夹杂一堆anchange.onclick莘属性去挂载JavaScript事件，让HTML与JavaScript
分离，依MVC的原则将功能杈贵区分济楚，使HTM.也变得结构化容易阅读。
Web浏览器中的Java5cript

##  [13.2.1 script元素](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

JavaScript代码可以以内联的形式出现在HTML文件里的<script>和</script>标签之间:
< script>
1l 这里是你的JavaScript代码
</$cript>
在XHTML中,<script>标签中的内容被当做其他内容一样对待。如果JavaScript代码
包含了"<" 或“&”字符.那么这些字符就彼解释成为XML标记。因此，如果要使用
XHTML,最好把所有的JavaScript代码放人到一个CDATA部分里;
scrip CDATA
/1这軍是你的JavaScript代码
]iscript
例13-2展示了一个HTML文件，它包含简单的]avaScript程序。往释解释了这个程序悬做
什么的，但这个例子主要演示的是JavaSeript代码以及CSS样式表是如何嵌人HTML文件
里。往意这个例子和例13-1的结构类似，并同样使用onload事件处理程序。
例13-2: 实现一个简单的JavaScript数宇时钟程序
```
<!DOCTYPE html>
<!-- 这是一个HTML5 文件-->
<!-- 裉节点
<html>
<!-- 标题，觯本和样式都放在这里-->
<head>
<title>Digital Clpck</tit1e>
/1js代码
<sczipt>
/1定义-个函数用以显示当前时闻
function displayTime() {
+P-ECLmc
var elt= document.getElementById("c1ock"); 11通过id="clock"找到元素
1! 得到当前时i间
vaI now 兰new Date();
11让e1t来显示它
e1t.innexHTML= now.toLocaleTimeString();
/! 在1秒后再改执行
setTImequt(disp1ayTime,1000};
window.onload = displayTime; !! 当onload事件发生时开始显示时问
</script>

314i 第13章

---

###  [13.2.2 外部文件中的脚本](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

<script>标签支持src属性，这个属性指定包含JavzScript代码的文件的URL。它的用祛
如下:
<script src=".../scxipts/util-js"><iscript>
会的
JavaScript文仆的扩展名适常是以,js结尾的。它包含纯粹的JavaSeript代码，其中既没有
script标签，也汝有其他HTML标签。
具有src属性的<script>标签的行为就像指定的JavaScript文件的内容直接出现在标签
<script>和</script>之间一样。往意。即便指定了src属性并且<script>和</script>标
签之间没有JavaSeript代码，结束的</script>标签也是不能丢的。在XHTML中，在此处
可叮以使用简短的<script/>标签。
使用src属性时.<scxipt>利l<1script>标签之间的任何内容都会忽略。如果需要，可以
在<script>标签之间添加代码的补充说明文档或版权信息。但是要往意; 如果有任何非
空格或JavaScrip性释的文本出现在<script src="">和</script>之间，HTM1.5校验器
将会报错评i2。
以下是src属性方式的一些优点;
可以把大块JavaScript代码从HTM[.文件中删除，这有助于保持内容和行为的分
离，从ti 简化HTML文件。
如果多个Web页面共用相同的JavaScript代码，用src属性可以让你只管理一份代
码，而不用在代码改变时编辑每个HTML文件。
如果一个JavaScripr代码文件由多个页面共享，就只需要小载它一次，通过使用它
随后的页面可以从浏览器缓存检索它。
的第一个页面-
由于src属性的值可以是任意的URL.因此来白一个Web服务器的JavaScript程序或
Web页面可以使用由另一个Web服务器输出的代码。很多互联网广告依赖与此。
从其他网站载人脚本的能力，可以让我们更好地利用缓存。Google正在为通用的
有时我们会看到诸如这种代码:
译注2:
s5cript src="core.js">
config= {...};
</script>
看越来这段代码定叉了一些配置项。由core.jK米读取，这是一种将页面岑数传入库文件
的方法，在]avaScripl库的开发中非常常见，其中<scIipt>和</script>之间的代码是
一段纯文本: 在core.js执行时读取这段文本然后动态执行一次。浏览器不会自动执行
script标莶之间的代码。
Web浏览器中的JavaScript| 315

---
客户端类库推广标准且好记的UR[]事出'，可以让浏览器只缓存--份副本，井且网络
上的任意站点都可以使用。链接JavaScript代码到Goog1e服务器，可以减少Web页
面的启动时间，因为这些类库可能已经存在千用户的浏览器缓存中，但是你必须相
信由第三方提供的代码服务,这对于你的站点来说很关键。参见htp/lcode.google.
comupis/ajaxlib>/奁看更多信息。
从文档服务器之外的服务器里载人脚本有重要的安全隐患。13.6.2节介绍的同源安全策
略会阻止一个域的文档中的JavaScript和另一个域的内容进行交互。但是，要往意和脚本
本身的来源并没有关系，而是和脚本嵌人的文档的来源有关系。因此，同源策洛并不适
用于如下情况: 即便代码和文档有着不同的来源，JavaScript代码也可以和它嵌人的文档
进行交互。当任页面中用src属性包含一个脚本时，就给了脚本作者(以及从中裁人这
段脚本的域的网站管理员) 完全控制Web页面的权限。  

###  [13.2.3 脚本类型](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

JavaScript是Wcb的原始脚本语言，而在默认情况下，假定<script>元素包含或引用
JavaScript代码。如果要使用不标准的脚本语言，如Microsoft的VBScript (只有IE支
持)，就必须用type属性捐定脚本的MIME类型;
```
<script type="text/vbscript">
’这里是VB5cr1pt 代码
c1script>
```
type属性的默认值是“textjavascript”。如果需要，可以显式指定此类型，但这完全没
必要。
老的浏览器在<script>标记上用language属性代替type属性，这种情况现在也会经常
看到:
```
<script language="javascript">
! 这里是JavaScript代码......
</script>
```
language属性已经废弃，不应该再使用了。
当Web浏览器遇到<script>元素，并且这个<script>元素包含其值不被浏览器识别的
type属性时，它会解析这个元素但不会尝试显示或执行它的内容。这意味着可以使用
script元索来嵌入任意的文本数据到文档里，只要用type属性为数据声明一个不可执
行的类型。要获取数摒，可以用表示script元案(第15章会解释如何获取这些元紊) 的
这些类库文件通常放在Google捉供的CDN上。
译注3:
HTMLElement对}象的text属性。但恳，要往意这些数据怅人技术只对内联脚本生效评诛4。
如果同时指定src属性利、个未知的类型,那这个脚本会被忽略，并且不会从指定的URL
里下载任何内容。  

###  [13.2.4 HTML中的事件处理程序](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

当脚本所在的HTML文件被载人浏览器时，这个脚本里的JavaScrjpt代码只会执行
一次。为了可交互，JavaScript程序必须定义事件处理程序一一Web浏览器先往册
JavaScript函数，并在之后调用它作为事件的响应(比如用户输入)。正如本章‘开
始展示的，JavaScript代码可以通过把凼数赋值给Element对象的属性(比如onc1ick或
onmouseover) 来往册事件处理程序。(还有其他注册事件处理程序的方法，参见第17
章)，这个Element对象表示文档里的一个HTML元素。
类似onclick的事件处理程序属性，用相同的名字对应到HTML属性，并且还可以通过将
JavaScript代码放置在HTML属性里来定义事件处理程序。例如，要定义用户切换表单中
的复选框时调用的事件处理程序，可以作为表示复选框的HTML元素的属性指定处理嵇
序代码:
```
<input type="checkbox" name="options" value="giftwrap"
anchangeo"orde`r,options,giftwrap = this.checked;">
```
这里的onchange属性比较有意思。这个属性值里的JavaScript代码会在用户选择或取消选
择复选框时执行。
HTML中定义的事件处理程序的属性可以包含任意条JavaScript语句，相互之间用逗
号分關。这些语句组成一个闲数体，然后这个丽数成为对应事件处理程序属性的位。
(17.2.2节会详细介绍HTML属性文本到JavaScript函数的转换。) 但是，通常HTML事
件处理程序的属性由类似上面的简单赋值或定义在其他地方的简单函数调用组成。这
样可以保持大部分实际的JavaScrip代码在脚本里，而不用把JavaScript和HTML混在
起。实际上，很多Web开发者认为使用HTML事件处理程序的属性是不好的习惯，他们
更喜欢保持内容和行为的分离。  

###  [13.2.5 URL中的JavaScript](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

在URL后面跟一个javascript:协议限定符，是另一种嵌入JavaSctipt代码到客户端的方
式。这种特殊的协议类型指定URL内容为怔意字符串，这个字符串是会被JavaScript解释
器运行的JavaScrijpt代码。它被当做单独的一行代码对待,这意味着语句之间必须用分号
译注4: Sleven Souder著名的ControlIS框架就是利用了script 无亲的这一特性来控制JavaScripl代
碣的执行，更多信急请阒读; http://stevesouders.com/controljsl,
隔开，而/1饨释必须用/* */往释代替。javascript: URL能识别的“资源”是转换成宇
符串的执行代码的返回值。如果代码返回undefined,那么这个资源是没有内容的。
javascript: URL可以用在可以使用常规URL的任意地方: 比如<a>标记的href属性，
<form>的action属性，甚至window.open()方法的参数。趔链按里的JavaScript URL可以
是这样:
< hzef="javasczipt:neW Date()-toLocaleTimeString();">
What time is it?
</a>
部分浏览器(比如Firefox) 会执行URL里的代码，并使用返回的字符串作为待显示新文
档的内容。就像单击一个http: URL链接，浏览器会擦除当前文档并显示新文档。以上
代码的返回值并不包含任何HTML标签,但是如果有，浏览器会像谊染通常载人的等价
HTML文档一样渲染它们。其他浏览器(比如Chrome和Safari) 不允许URL像上面一样
微盖当前文档，它们会忽略代码的返回值。但是，类似这样的URL还是支持的;
口href="javascr1pt;alert(new Date().toLocaleTimeStIing());">
检耷时间，而不必覆盖盎个文档
</a>
当浏览器载人这种类型的URL时，它会执行JavaScript代码，但是由于没有返回值
(alert()方法返回undefined) 作为新文档的显示内容，类似Pirefax的浏览器并不会膂
换当前显示的文档。
(在这种情况下，javascript: URL利lonc1ick事件处理程序的目的
一样。上:面的链接通过<button>元素的onc1ick处理程序来表示会更好，因为<a>元紊道
常应该保留为超链接，用来载人新文档。) 如果要确保javascript: URL不会覆盖当前
文档，可以用void操作符强制函数调用或给表逃式赋予undefined值:
<a href="javascript:vaid window.open('about:blank' );"打并.-个窗H</a>
如果这个URL里役有void操作符，调用window.open()方祛返回的值会(在一些浏览器
里) 被转化为字符串并显示，而当前文档也会被覆盖为包含该宇符串的文档:
[object Window]
和HTML事件处理程序的属性一样.JavaScript URL是Web早期的遗物，通常应该避免在
现化HTML里使用。但javascript: URL在1TML文档之外确实有着重要的角色。如果
要测试一小段JavaScript代码，那么叮以在浏览器地址栏思直接输入javascript: URL。
个面会介绍javascript: URL另一个正统(且强大的) 的用法: 浏[览器书签。
书签
在Web浏览器中，“书签”就是.-个保存起来的URL。如果书签是javascript: URL,
第13章
318

---
那么保存的就足小段脚本，叫做bookmurkleto bookmarklct是一个小型程序，很容易就
可以从浏览器的菜单或工具栏甲启动。bookmarklet里的代码执行起来就像页面上的脚本
一样,可以查询和设置文档的内容，呆现和行为。只要书签不返回值。它就可以操作当
前显示的作何文档，而不把文档替换成新的内容。
考虑下面<a>标签里的javascript: URL。单d链接会打升一个简单的JavaScripl表达式
计算器，它允许在页面环境中计算表达式利执行语句:
ca href-'javascript;
var e = ",r 。""; 1* 需灵计算的表达式和结哭*/
do
1体输出乱达式和结果，并要求输人新的长达式$/
eval(e); }/* 尝试计算这个表达式*{
ry{ r ="Result: " +
否则记住这个错误，
catch(ex){ I = ex; }
}while(e); 1* 直到没疔输入表达式或者单击了Cance1按钮才会停止，否则一直循环执行*/
/*这句代码用以防止当前文档被蹬盖*/
vaid 0;
JavaScript Eva1uator
</a>
往意，即便这个JavaScript LRL是写成多行的，HTML解析器仍将它作为单独的一行对
待，并且其中的单行}|位释也是无效的。还有，要记住代码是单引号中的HTML属性的一
部分，所以代码不可以包含任侧单引号。
在开发时,把这样的链接硬编码在页面中是有用的; 而把它另仔为可以在任何页面上运
行的书签，就更有用了。通常，在浏览器里把超链接的地址加入书签可以这样做，在链
接上右击并选择类似“Boakmark Link" 的选项，或者拖动链接到书签T.具栏。  

##  [13.3 JavaScript程序的执行](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

客户端JavaScript榨序没有严格的定义。我们可以说JavaScript程序是由Web页面中所包
含的所有JavaScript代码(内联脚本、HTML事件处理程序和javascript: LRL) 和通过
script标签的src屑性引用的外部JavaScript代码组成。所有这些单独的代码共用同一
个全局Window对象。这意味着它们都可以看到机同的Documeot对象，叮以共享相同的
全局函数和变望的集合: 如果一个脚本定义了新的全局变皇或函数。那么这个变垦或函
数会在脚本执行之后对任意JavaScript代码可见。
如果Web页面包含一个嵌人的窗体(通常使用<iframe>元素)，嵌人文档中的JavaScript
代码和被嵌入文档里的JavaScript代码会有不同的全局对象，它可以当做一个单独的
JavaScript程序。但是，要记位，役有严格的关于JavaScript程序范围的定义。如果外面
和里面的文档来自于同一个服务器，那么两个文档中的代码就可以进行交互，并且如果
你愿意，就可以把它们当做是同一个程序的两个相互作用的部分。14.8.3节会详细介绍
全局Window对象以及不同窗口和窗体之间的交互。
bookmarklet里的javascript: URL存在于文档之外，可以想象成是一种用户扩展或者对
于其他程序的修改。当用户执行一个bookmarklct时，书3签里的JavaScripu代码就可以访
问金局对象和当前文档的内容,以及对它进行操作。
JavaScript序的执行有两个阶段。在笫一阶段，载人文档内容，并执行<scr1pt>元索里
的代码(包括内联脚本和外部脚本)。脚本通常(但不总是，参见13.3.1节) 会按它们
在文档果的出现顺序执行。所有脚本里的JavaScript代码都是从上往下，按照它在条件、
循环以及其他控制语句中的出现顺序执行。
当文档载人完成，并且所有脚本执行完成后，JavaScript执行就进入它的第二阶段。这个
阶段是异步的，而且由事件驱动的。在事件驱动阶段，Web浏览器调用事件处埋程序函
数(由第一阶段里执行的脚本指定的HTML事件处理程序，或之前调用的事件处理程序
来定义)，来响应异步发生的事件。调用事件处理程序通常是晌应用户输入(如鼠标单
击，键盘按下等)。但是，还可以由网络活动.运行时问或者JavaScript代码中的错误来
触发。第17章会详细介绍事件和事件处理程序。13.3.2节世会进行更多讨论。往意，嵌
人在Wcb页面里的javascript: URL也可以被当做是一种事件处理程序，因为直到用户
通过单击链接或提交表单来激话之后它们才会有效果。
事件驱动阶段里发生的第一个事件是load事件,指示文档已经完全载人，并可以操作。
JavaSeript程序经常用这个事件来触发或发送消，息。我们会经常看到一些定义函数的脚本
程序.除了定义一个onIoad事件处理程序函数外不做其他操作，这个函数会在脚本事件
驱动阶段开始时被load事件触发。止是这个on1oad事件会对文档进行操作，并做程序想
做的任何事。JavaScript程序的载入阶段尼相对短暂的，通常只持续1~2秒。在文档载人
完成之后，只要Web浏览器显示文档，事件驱动阶段就会一直持续下去。因为这个阶段
是异步的和事件驱动的，所以可能有长时间处于不活动状态,役有JavaScript被执行，铍
用户或网络事件触发的括动打断。13.3.4节会详细介绍JavaScript执行的两个阶段。
核心JavaScript和客户端JavaScript都有一个单线程执行模型。脚本和事件处理程序(尤
论如何) 在同一个时间只能执行一个，没有并发性。这保持了JavaScript编程的简单性，
在13.3.3节会介绍。  

###  [13.3.1 同步、异步和延迟的脚本](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

JavaScript第~次添加到Web浏览器时，还没有API可以用来遍历和操作文档的结构和内
容。当文档述在裁人时，Java$cript影响文档内容的唯.方法足快逑尘成内容。它使用
document.writ e()方祛完成上述任务。例13-3展示「1996年最光逃的JavaScript代码的
样子。
创13-3: 载入时生成文档内容
```
<hI>Table of Factorials</h1>
<script>
/1用来计算阶乘的函数
function factorial(n) {
COU
if (n <= 1) return n;
能|
lse return n*factorial(n-1);
1开始创建HTML表
dacument.write("<table>");
dacument,write("<tr><th>n</th><th>n!</th></tr>"]; !! 输出表头
for(var i= 1; i<= 10; i++} {
/! 输出10行
document.write("<tr><td>" + 1+"</td><td>" + factorial(1) + "<1td></tr>") ;
'1衣格结束
document.write{"</table>");
w.twot'
document.write("Generated at " + new Date());
11输出时间戰
</script>
```
当脚本把文本传递给document.write()时，这个文术被舔加到文档输人流中，HTML解
析器会在当前位置创建一个文术与点，将文术插入这个文本书点后面。我们并不推荐使
用document.write(),但在某些场录下它有者重要的用途(见15.10.2节)。当HTML解
析器過到<script>元素时，它默认必须先执行脚本，然后再恢复文档的解折和渲染。这
对于内联脚本役什么问题.但如果脚本源代码是一个出src属性指定的外部文件，这意
味着脚本后面的文档部分在下载和执行脚本之前，都不会出现在浏览器中译注5。
脚本的执行只在默认情况下是同步和阻寒的。<script>标签叮以有defer和async属性，
这(在女持它们的浏览器里) 可以改变脚本的执行方式。这些都是布尔属性，没有值;
只需要出现在<script>标签里即可。HTMLS说这些属性只在和src属性联合使用树才有
效，但有些浏览器还支持延迟的内联脚本:
```
<script defer src="deferred.js"><1script>
<scxipt async sIco"async.js"></script>
```
defer和async属性都像在告诉浏览器链接逃来的脚本不会使用document.urite(); 也不
会尘成文档内容; 因此浏览器可以在下载脚本时继续解析利楦染文档。defer属性使得
浏览器延迟脚本的执行，，直到文档的载人和解析完成，并可叮以操作。async属性使得浏
览器可以尽快地执行脚本，而不用在卜载脚本时阻寨文档解析。如果<script>标签同时
有两个属性，同时支持两者的浏览器会遵从async展性并忽略defer属性。
作者在这里的表述很模糨。所诮“不会出现在浏览器中”是指文档的文本内容已经载
译注5:
人,但是并禾被浏览器引孪解析为DOM树，而DOM树的生成足受JavaScripl代码执行的
影响的，Java$cripl代码会“阻家”页击UT的渲染。
Web浏览器中的JavaScriptl 321

---
注意，延迟的脚本会按它们在文档里的出现顶序执行。而异步脚本在它们载人后执行，
这意味着它们矿能会无序执行。
在撰写本书的时候，async和defer属性还没有广泛实现，它们只被一些优化建议所考
虑。即便延迟和异步的脚本会同步执行，Web页面应该还可以正常工作。
甚至可以在不支持async属性的浏览器里，通过动态创建<script>元素并把它插人到文档
中，来实现脚本的异步戴人和执行。例13-4舆的1oadasync()函数完成了这个工作。第15
章会介绍它使用的技术。
例134: 异步载入并执行脚本
11异步裁人井执行-个指定URL 中的脚本
functlon 1oadasync(url) {
var head= document.getElementsByTagName("head")[O]; 11找到<head>元素
var S a document,createElement("script")}; I1创建一个<scxipt>元素
11役置其5ZC属性
s.SrC = url;
11将script元素插人head标签中
head. appen dChild( s) ;
往意这个1oadasync()丽数会动念地载入脚本~
脚本载入到文档中，成为正在执行的
JavaScript程序的一部分，既不是通过Web页面内联包含，也不是来自Web页面的静态
引用。  

###  [13.3.2 事件驱动的JavaScript](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

例13-3里展示的古老的JavaScript程序尼问步载人的程序: 在页面载入时开始执行，生成
一些输出，然后结束。这种类型的程序在今天已经不常见了。反之，我们通过往册事件
处理程序啮数来写程序。之后在往册的事件发生时异步调用这些函数。例如，想要为常
用操作启用键盘快捷键的Web应用会为键盘事件往册事件处理程序。甚至非交互的程序
也使用事件。假如想要写一个分析文档结构并自动生成文档内容的表格的程序。程序不
需要用户输人事什的事件处理程序,但它还是会往册onload事件处理程序，这样就可以
知道文档在什么时候载人完成并可以生成内容表格了。
事件和事件处理是第17章的主题，但是这节会挑供--个快速概览。事件都有名字,
比如click.change.load、mouseover、keypress或readystatechange,指示发生的事件的
通用类型。事件还有目标，它是一个对象，并且事件就是在它上面发生的。当我们谈
论事件的时候，必须问时指定事件类型(名字) 和目标: 比如，一个单击事件发生在
HTMLButtonElement对象E,或者一个readystatechange事件发尘在XMLHtpRequest对
象上。
如果想要程序响应一个事件，写一个函数，叫做“事件处理程序”、“事件监听器* 或
3221第13章

---
“回调”。然后注册这个丽数，这样他就会在事件发生时调用它。正如前面提到的，这
可以通过HTML属性来完成，但是我们不鼓励将JavaScript代码和HTML内容混淆在一
起。反之，往册事件处埋程序最简单的方仫是把]avaSeript函数赋值给目标对象的属性,
类似这样的代码:
window.onload = function(){...};
document.getElementById{"button1").onclick
function(){...};
卫
function handleResponse(){...I
迮
request.onreadystatechange= handleResponse;
位意，按照约定，事件处理程序的属性的名宇是以“on”开始，后面跟着事件的名字。
还要往意在上面的任何代码里没有函数调用: 只是把函数本身赋值给这些属性。浏览器
会在事件发生时执行调用。用事件进行异步编程会经常涉及嵌盘函数，也经常要在函数
的函数里定义函数。
对于大部分浏览器中的大部分事件米说，会把一个对象传递给事件处理程序作为参数，
那个对象的属性提供了事件的详细信息。比如，传递给单击事件的对象，会有一个属性
说明鼠标的哪个按钮被单击。(在IE里，这些事件信息被存储在全局event对象里，而
不是传递给处理程序丽数。) 事件处理程序的返四位有时用来指示函数是不充分处理了
事件，以及阻止浏览器执行它默认会进行的各种操作。
有些冉件的目你是文档元素，它们会经常往上传递给文档树，这个过程叫做“冒泡”
例如，如果用户在<button>元素上单击鼠标，单击事件就会在按钮上触发。如果注册在
按钮上的函数没有处理(并且冒泡停止) 该事件。事件会冒泡到按镇嵌套的容器元素,
这样,任何往册在容器元素上的单击事件都会调用。
如果需要为‘个事件注册多个事件处理程序函数，或者如果想要写一个可以安全往册事
件处理程序的代码模块，就算另、个模块已经为相同的目标上的相同的事件往册了一个
处理程序,也需要用到另种事件处理程序注册技术。大部分可以成为事件目标的对象
都有一个叫做addEventlistaner()的方法，允许往册多个监听器:
window.addEvent Listener("load"; function() {...}> false) ;
request.addEventListenex("Ieadystatechange"; function() {...}; false) ;
往意这个函数的第一个参数是事件的名称。虽然addEventlistener() 已经标准化超过了
十年，而微软目前只有在IE9里实现「它。在IE8以.及之前的浏览器巾，必须使用一个相
似的hi 法，叫做attachEvent() :
window.attachEvent("onload",function() {..};
参见第] 7章查看更多关JaddEventListener()和attachEvent()的内容。
Web浏览器中的JavaScript
323

---
客户端JavaScript序还使用异步通知类型，这些类型往往不是事件。如果设置Window
对象的onerror属性为一个函数，会在发生(参阅章14.6￥) JavaScript错误(或其他未
捕获的异常) 时调用函数。还有，setTimeout()和setInterval()函数(这些是Window
对象的方祛; 因此是客户端JavaScript的仝局函数) 会在指定的一段时间之后触发指定
函数的调用。传递给setTimeout()的函数和真实事件处理程序的往册不同，它们通常叫
做“回调逻辑”而不是“处理程序”，但它们和事件处理程序一样，也是异步的。参见
14.1节获得更多关十setTimeout()和setInterval()的信息。
例13-5演小了setTineout().addEventListener()和attachEvent()，定义一个onlad()
函数注册在文档载人完成时执行的函数。on1oad()是非常有用的函数,我们会在本书后
面的例子中用到它。
例13-5: onLnad()，当文档载入完成时调用一个函数
'1注册函数f,当文档戴人完成时执行这个函数f
11如果文梢已经载入完成，尽快以异步方式执行它
functiononLad(f){
if (onLoad.loaded)
11如果文档已经载人完成
11将f放人半步队列，月尽快执行它
window.setTimeout(f,0);
1往质弈件的标准方迭
else if (window,addEventListener)
la
window.addEventListener("load",f,false);
1! IE8以及虫早的IE版本浏览器化现车件的方祛
else if (windw.attachEvent)
window,attachEvent("an1oad",f};
11给onLoad设翌一个标志，用来指示文档是个载人完成
onLoad.loaded = false;
/! 往册一个函数，当文档载人完成时设置这个标光
onLoad(function(){ onLoad.loaded= true; });  

###  [13.3.3 客户端JavaScript线程模型](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

JavaScript语言核心并不包含任何线程机制，并且客户端JavaScript传统E也役有定
义任何线程机制。HTMI.5定义了一种作为后台线程的“WebWotker”，但是客户端
JavaScripl还像严格的单线程一样工作。甚其至当可能并发执行的时候，客户端JavaScript
也不会知晓是否真的有并行逻辑的执行。
单线租执行是为了让编程更加简单。编写代码时可以确保两个事什处理程序不会同一时
刻运行，操作文档内容时也不必担心会有其他线程试图同时修改文档，并月.永远不惴要
在号JavaScripr代码的时候担心锁、死锁和兖态条作(race condition)。
单线程执行意味者浏览器必须在脚本和事件句处理程序执行的时候停比响应用户输人。
这为JavaScript程序员带米了负担，它意味肴JavaScript脚本和事件处理程序不能运行太
长时间。如果一个脚本执行计算密集的任务，它将会给文档载人带来延迟，而用户尤法
324] 第13章

---
在脚本完成前看到文裆内容。如果事件处理程序执行计算密集的任务，浏览器可能变得
无法响应，叮能会导致用户认为浏览器崩绩了生2。
如果应用程序不得不执行太多的计算:导致明显的延迟，应该允诈文档在执行这个计算
之前完全载人，并确保能够告知用户计算正在进行并H.浏览器没有挂起。如果可能将计
算分解为离散的子任务，可以使用setTimeout()利setInterval()方法在后台运行子任
时
D
务,向时更新个进应指示器向用户显示反馈。
HTML5定义了一利并发的控制方式，叫儆“Wcb workcr”。Wcb worker是一个用来执行
计算栾集任务面不冻结用户界面的后台线程。运行在Web worker线程里的代码不能访问
文档内容，不能村主线程或其他worker共享状态，只可以和主线程和其他worker通过异
步事件进行通信，所以主线程不能检测并发性，并且Weh worker不能修改JavaScript程序
的基础单线程执行桢型。参见22.4节获得更多Web worker的信息。  

### [13.3.4 客户端JavaScript 时间线](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

我们已经看钊了JavaScript程序从脚本执行阶段开始，然后切换到事件处理阶段。本节会
更详纸地解释「JavaScript程序执行的时间线。
Web浏览器创建Document对象，井H.开始解析Web贞面，解析HTML元素和它
1.
们的文本内容后舔加Element对象和Text节点到文档中。在这个阶段document.
readystate属性的值是*luading”。
当HTML解析器遇到没有async和defer属性的<script>元素时，它把这些元素添加
到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载(如
果需要) 和执行时解析器会暂停。这样脚本就可以用document.write()来把文本插
人到输人流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定
义网数和往册后面使用的往册弃件处理程序，但它们可以遍历和操作文档树，因为
在它们执行时已经存在了。这样，同步脚本可以看到它肖已的<script>元素和它们
之前的文档内容。
3.
当解析器遇到设置了async属性的<script>元素时，它开始下载脚本文本，并继续
解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下載。异
步脚本禁止使用document.write()方法。它们可以看到月己的<script>元素和它之
前的所有文档元素，并H.可能或干胞不可能访问共他的文档内容。
当文档完成解析，document,readyState属性变成“intcractivc”。
某些浏览器能够防范拒绝服务攻击和偶热的无限循环，如罘脚本或事件处理程序运行时
注2;
间太长。它会提示用户。这就给用户一个选择中止运行脚本的机会。
Web浏览器中的JavaScript| 325

---
所有有defer属性的脚本,会按它们在文档的里的出现颍序执行。异步脚本可能也
5.
会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用document.write()
方法。
浏览器在Docurment对象卜触发DOMContentLoaded事件。这标志者程序执行从同步
6.
脚本执行阶段转换到了异步事件驱动阶段。但要往意，这时可能还有异步脚本役有
执行完成。
这时，文档已经完全解析完成，但恳浏览器叮能还在等待其他内容栽人，如图
7.
片。当所有这些内容完成载人时，并且所有异步脚本完成裁人和执行，document.
readystate属性改变为“complete",Weh浏览器触发Window对象上的load事科。
从此刻起，会调用异步事件，以异步响应用户输人事件.网絡事件、计时器过期等。
8.
这是一条理想的时间线，但是所有浏览器都没有支持它的全部细节。所有浏览器普
遍都支持1oad事件，都会触发它，它是决定文档完全载人并可以操作最通用的技术。
DOMContentLoaded事件在load事件之前触发，当前所有浏览器都支持这个事件,除了IE
之外，document.readyState属性在写本书时已被大部分浏览器实现，俱是属性的值在浏
览器之间有细微的差别。defer属性被所有当前版本的IB支持,但是现在还木被其他浏
览器实现。async属性的支持在写本书时还不近用，但是例13-4里展示的异步脚本执行技
术被当前所有当前浏览器支持，(但是，要注意用类似loadasync()函数动怂载人脚本
的能力让程序执行的脚本载人阶段和事件驱动阶段之间的界限更加模糊。
这条时间线设有指定什么时候文档开始对用户可见或什么时{候Web浏览器必须丌始响应
用户输人事件。这些是实现细节。对于很长的文档或非常慢的网络链接，Web浏览器理
论上会道染一部分文档，并且在所有脚本执行之前，就能允许用户开始和页面产生一些
交f。这种情况下，用户输入事件可能在程序执行的事件驱动阶段开始之前触发。  

##  [13.4 兼容性和互用性](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

Web浏览器是Web应用的操作系统，但是Wcb是一个存在各种差异性的环境，Wcb文档
和应用会在不同操作系统(Windows.Mac OS.Linux,iPhoue OS,Android) 的不同
开发商(Microsoft.Mozilla、Apple.Gougle.Opera) 的不同时代的浏览器(从预览
版的浏览器到类似IE6这利十多年之前的浏览器) 上查看和运行。写一个健业的客户端
JavaScripti程序并能止确地运行在这么多类型的平台上，的确是一种挑战。
客户端JavaScript兼容性和交互性的问题可以归纳为以下三类;
演化
Web平台一直在演变和发展当中。一个标准规范会俱导一个新的特性或API。如果
特牲看起来有用，浏览器开发商实现它。如果足够多的开发商实现它,开发者开始
试用这个特性，并依赖于这个特性，然后这个特性就在Web平台中广泛使用。有时
候浏览器开发商和Web开发者引领这种标准规范的指定，开发好官方的版本,之前
该特性已经成为一个事实的标谁。另一种悄况，新特性已经被添加到Web中，新浏
览器支持它但足老浏览器不支持。Web开发者必须在使用老旧浏览器的大量用户和
好
使用新式浏览器的少星用户之间做出权衡。
未实现
有时候，浏览器开发商之间对了某一个特性是否尼够有用到要实现存在观点上的差
异，一些开发商实现了这个特性，而其他的没有实现。有些现代浏览器实现的功能
在老旧浏览器中没实现，这情况还好，似同样实现一个功能在不同刘览器中有
很大差别，例如，IE8不支持<canvas>元素，虽然所有其他浏览器乜经实现了它。
一个更加糟糕的例子是，Microsoft决定不实现DOM level 2 Event拟范(它定义了
addEventListener()和相关的方法)。这个规范在十年之前已经标难化了「，其他浏
览器厂商已经支持了很久了用。
bug
每个浏览器都有bug,并且役有按照规范谁确地实现所有的客户端JavaScript API。
有时候编写能兼容各个浏览器的JavaSeript程序是一个槽透了的工作，必须歼究乜
有浏览器巾的各种bug.
率运的是，JavaScript诏台本身足被所有浏览器厂商实现的，它不是兼容性的题的源头。
所有浏览器都有对FES3的通用实现，并且在写本书的时候，所有」“商都在实现ES5。ES3
和ES5之间的转换可能会导致兼容性问题，因为一些浏览器会支持严格模式而其他的不
支持，浏览器厂商对ES5的实现基本是相互通用的。
首先，要解决JavaScript的兼容性问题是要了解问题的根源是什么。Web浏览器版本的
更迭要比本书的版本快三倍多，因此本书没办法告诉你什么版本的浏览器实现了哪些特
性，或者不会过多讨论哪些特性在某些浏览器下的表现如何或其中的bug。这些比较具
体的信息最好直接去网上查找。HTM[.5标稚化的努力的日标是最终产生一个侧试套件。
在写本书的时候，还没有这样的测试，但是一旦存在这样的测试，这必定会给浏览器兼
容性领域留下一些宝贵的财富。当下有一些网站提供了这利信息，可能会对你有用:
http; //developer mozila.org 

Mozilla开发者中心
http://msdn.microsoft.com 

Mi cTosof开发 者网 絡
值得微软称贄的是: IE9现在同时支持<canvas>元素和addEventlistener()方法。
主3:
Web浏览器中的JavaScriptI 327

---
http://developer.apple.comsafari 

Apple开发者网络里的Safari开发者中心
htp:code.gogle.com/doctype 

Google把Doctype项日介绍为“开放Web的一本百科全书”。这个用户可以编辑的
站点包含客户端JavaScript的各种兼容性表格。在写本书的时候，这些表格只报告
了每个浏览器里是否存在各利属性和方法。而事实上没有说它们是否工作正常。
http://en.wikipedia.org/wiki/Compari 

 son_of_layout_engines_(HTML_5)
Wikipedi文章跟踪了HTML5特性和APl在各个浏览器里的实现状态。
http://en.wikipedia,org/wiki/Comparison_of_layout_ 

 engines_(Documcnt_Objcct_Mcdel)
一篇简单的文章，跟踪DOM特性的实现状态。
http://a.de 

 veria.com/caniuse 

这个“何时可用......站点跟踪贡要Web特性的实现状态,允许根据各种标准进行
过滤，并在某个特性只剩下少量匕部署的浏览器不支持时推花使用。
http://w 

 ww.quirksmode.og/dom
根据W3C标准列出的各种浏览器的DOM兼容性表格。
http://vebdevouL.retbro 

 wser-support
另一个跟踪浏览器开发商对于Web标准的实现的站点。
生意，列表的最后三个站点是由个人维护的。尽管它们是客户端JavaScript的先行者，但
这些站点可能不会总是保持最新。
当然，怠识到浏览器之间的兼容性问题只是第一步。接下来,你需要解决这些不兼容
性。一种策略是限制自已使用弥选择支持的所有浏览器都普遍支持的特性(或者很
容易模拟出的特性)。之前提及的“何时可用....这个网站(http://a.deveria.com/ 

caniuse) 就是围绕这个策略的: 它列出了所有等IE6淘状之后才能用的新特性，等1E6淘
汰之后，这个网站也没有存在的必要了。下面几节介绍:种略有点绡极的澍付宾户端不
兼容性问题的策略。  

###  [13.4.1 处理兼容性问题的类库](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

处理不兼容问题其中一种最简单的方法是使用类库。比如，考虑客户端图像的<canvas>
元素{第21章的主感)。IE是唯一不支持这个特性的当前浏览器。它支持一种晦涩的
客户端图形语言，叫做VML.尽管如此，canvas元素可以基下它进行模拟。开源的
"explorer canvas" 项目在http://code.google.comlplexpiorercarvas 

上已经发布了一个类
库，就是散这仲事倩; 引人一-个JavaScript代码文仲叫做excanvas.js,然后lE就会看起来
像它支持<canvas>元素一样。
328
第13章

---
关于“当前正在使用的浏览器”
客户端JavaScript是一个充满变化的概念，特刖是随着ES5和HTML5的出现。医为
平台的快速演变，我们往往不会使用“某些特定版本的浏览器”这种狭叉的措衅
表述。所有这样的表述，在本书下一版出版之前就过时了。因此，你会发现我经常使
我“所有当前的浏览器”(或“除IE之外当前所有浏览器”)放人我所表述的语境
啦
中。在撰写本书时，当前的(非测试版) 的浏览器是:
品
Internet Explorer 8
Firefox 3.6
Safari 5
Chrome S
Opera 10.10
当本书上架时，当前浏览器可能会是Internet Explorer 9.Firefox 4.Safari 5,
Chrome 11和Opera 11。
但并不是说本书中所有提到的“当前浏览器”都是这个含义。我只是希型大家能了
解在撰写本书时所使用的浏览器。
本书第5版用了词语“现代浏览器”，而不是“当前浏览器”。那个版本在2006年
发布。那时候的“当前浏览器”足Firefox 1.5.IE6、Safari 2和Opera 85 (Gogle
的Chrome测觉器还不存在)。太书中保留的所有关于“现代浏览器”的表述都可
以理羿“所有浏览器”，因为比这些还老的浏览器巳经很少了。
本书[特别是第22章} 描述的一些最断的客户躺特性，这些特性还没有在所有的
浏览器里实现。然而这些特性都在一个开放的标准流程下进行开发，已经在至少
一个发布的浏览器里实现，并看起来会被所有浏览器厂商接受(可能除Microsoft
之外)。
excanvas.js是一个兼容类库的很纯粹的例子。在开发过程中，可能会对某个特性编写类
似的类库。ES数组方法(见7.9节)，比如forEach(),map()和reduce()，可以在ES3
中几乎完美模拟,并且通过把合适的类库添加到页面中，叮以把这些强大有用的方祛当
做所有浏览器平台基线的部分。
但是，有时候。不可能完全地(或有效地) 在一个不支持某个特性的浏览器上实现一
个特性。就像已经提到的，IE是唯一没有实现标准事件处理API的浏览器，包括往册事
件处理程序的addEventlistener()方法。IE支持一个类似的方法叫做attachEvent()。
attachEvent()不像addEvent Listener()一样强大，并且在1E提供的基础上透明地实
Web浏览器中的JavaScript
329

---
现整个标准并非真正可行。反之，开发者有时定义一个折中的事件处理方店，通常
叫addEvent().它可以用addEventListener()或attachEvent()来方便地实现绑定事
件的功能。然后。它们在所有的代码里用addEvent()来代村addEventlistener()或
attachEvent()。
在实际的开发工作中，今天不少Web开发者在它们所有的Web页面上用了客户端
IavaScript框架，比如jQuery (参见第19章)。使这些框架必不可少的一个重要功能是:
它们定义了新的客户端API并兼容所有浏览器。例如。在jQuery里，事件处理程序的往
册是通过叫bind()的方法完成的。如果你基于jQuery做所有的Web开发，你就永远不需
要考虑addEventListener()和attachEvent()之间的不菲容情问题。参见13.7节获得更多
关十客户端框架的信息。  

###  [13.4.2 分级浏览器支持](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

分级浏览器(graded browser support) 是由Yahoo!率先提山的一种测试技术。从某种维
度对浏览器厂商/版本/操作系统变体进行分级。分级浏览器中的A级要通过所有的功能测
试用例。对于C级浏览器来说则不必所有用例都通过测试。A级浏览器需要网页究全可
用，C级浏览器只犏在HTML完整情况下可用即可，而不需要JavaScript和CSS都正常工
作。那些不是A级和C级的浏览器都称做X级浏览器:这部分都是全新的浏览器或者太竿
见的浏览器。我们默认在这些浏览器中都是网页完全可用的，但官方并不会对X级浏览
器中的功能提供完墼支持和测式。
你可以在http:/eveloper.yahoo.comlywilarticles/gbs| 读更多关于Yahoo !的分级浏览器支
持情况。这个页面还存有Yahoo!当前的A级和C级浏览器列衣(这个列表每季度更新一
次) 评些6。就算白已没有采用任何一种分级浏览器创试基准，使用Yahoo!的A级浏览器
列表是--种简单快捷的办法，通过夼阅这个列表也能猜楚地知道当前比较流行的浏览器
是哪些。  

###  [13.4.3 功能测试](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

功能铡试(capability testing) 是解决不兼容性问题的一种强大技术。如果你想试用某个
功能，但又不清楚这个功能是否在所有的浏览器中都有比较好的兼容性，则黹要在踯本
中舔加相应的代码来检测是否在浏览器中支持该功能。如果期望使用的功能还役有被当
前的平台所支持,要么不在该平台中使用它，耍么提供可在所有平台上运行的代码。
译注6: 根据2011年第四季度的统计，Yahoo!巳经不再将浏览器划分为A级和C組，而是统一蛤出
一个测试基准，根据这次更晰，可以明显感觉科测试基准向移动终端倾斜。
第13章
330

---
你将会在后面的各章中一次又一次地看到功能测试。例如，任第17章，有如下所示的代
冯:
if (element.addEventListenex){ 11在使用这个W3C方祛之前首先检测它是否可用
e1ement.addEventListener("keydawn",handler,false);
element.addEventListener("keypress"; handler; false);
心
else if (element,attachEvent){ /1在使用H该正方法之前首先检测它
element.attachEvent("onkeydown"; handler);
element.attachEvent("onkeypress",handler) ;
else{ 11否则，选择普遍支持的技术
element.onkeydown= element.onkeypress = handler ;
关于功能测试最乖要的是，它并不涉及浏览器开发商和浏览器的版本号。代码在当前的
浏览器集合中有效，在浏览器的后续版本中也同样有效，而不管后续的浏览器是否实现
了这些功能的集合。但要注意的是，这种方祛需要测试某个属性或方祛是否在浏览器中
已经定义了，除非该属性或方让完全可用。如果Microsoft要定义一个addEventlistener()
方祛。但Microsoft只是实现了一部分W3C规范，在调用addEventListener()之前这将会
给使用特性测试的代码带来很多麻烦。  

###  [13.4.4 怪异模式和标准模式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

Microsoft在发布E6的时候，增加了IE5里没有的很多CSS标谁特性。但为了确保与已有
Wcb内容的后向兼容性.它定义了两种不同的渲染模式。在“标谁模式”或“CSS兼容
模式”中，浏览器要避循CSS标准，在“怪异模式”中，浏览器表现的和IE4和IE5小的
怪异非标准模式一样。渲染模式的选择依赖于HTML文件顶部的DOCTYPE户明，在IE6小
打开役有DOCTYPE的页面和声明了某些权限Doctypc的页面都会按照怪异模式进行渲
染，定义了严格的Doctypc的页面(或者为了做到前向兼容性而添加了未知的Doctype的
页面) 会按照标准模式进行渲染，定义了HTML5 Doctype (<!DOCTYPE htm1>) 的页面
在所有现代浏览器中都会按照标准模式泣染。
怪异模式和标准模式之间的差别经历了很长时间的发展历程，现在新版本的IE都文持标
徙模式，其他主流浏览器也都支持标准模式。这两种模式都已经被HTML5规范所认可。
怪异模式和标准模式之间的差异对于HTML和CS5开发者影响最大。但客户端JavaScripl
代码则是需要知道文档以哪种模式进行谊染的。要进行这种渲染模式的特性检测，通常
检查document.compatHode属性。如果其值为“CSS1Compat”,贝|说明浏览器工作在标
准模式; 如果值为“BackCompat”
(或undefined,说明属性根本不存在)，则说明浏
览器工作在怿异模式。所有现代浏览器都实现IcompatMode属性，并且HTML5规范对它
进行了标准化。
]331
Web浏览器中的JavaScript

---
测试compatMode不是必要的。创是，在例15-8展示的示例代码中用到了它。  

###  [13.4.5 浏览器测试](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

功能测试非常适用于检测大型功能领域的支持，比如可以使用这种方法来确定浏览器是
否支持W3C事件处理模型还是IE的事件处理模型。另外，有时候叮能会需要在某种浏览
器中解决个别的bug或难题，仙却没有太好的方法来稔测bug的存在性。在这种悄况下，
需要创建一个针对某个平台的解决方案，这个解决方案和特定的浏览器厂商、版本或操
作系统(或三方面的组合) 联系紧密。
在客户端JavaScript中检铡浏览器类型和版本的方法就是使用Navigator对象，我们]将在
第14章学习它，确定当前浏览器的[ 商和版本的代码通常叫做浏览器嗅探器(browser
sniffer) 或者客户端嗅探器(client sniffer)。例14-3给出了一个简单的例↑。在Web的
早期、当Netscape和1E平台两者相互不推容的时候，客户端嗅探(client sniffing) 就是
种觉见的客户端编程技术，现在推容性悄况已经基本稳定，浏览器嗅探不像若于年前
这样常用，但偶尔有些场景还会用到。
需要往意的是，客户端嗅探也可以在服务器端完成，Web脏务器根据User-Agent头部可
以有选择地返回特定的JavaScript代码纷客户端。  

###  [13.4.6 Internet Explorer里的条件注释](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

实际上，读者会发现客户端JavaScrip(编程中的很多不兼容性都是针对IE的。也就是说，
必须按照某种方式为IE编写代码。而按照另一种方式为其他的浏览器编写代码。IE支持
条件往释(由IE5引人)，尽管这种做祛并不符合标准规范，但是在处理不兼容性时非
常有用。
下面足HTML中的条件往释的样子。注意，HTML注释使用结束的分隔符的找巧:
```

```
来看一个具体的例子，上文介绍过使用excanvsjs类库在Internet Explorer里灾现<canvas>
元素。由丁这个类库只有18需要{并且也只为IE工作)，因此有理由在页面里使用条件
往释引入它，这样其他浏览器就不会载人它:

IE的JavaScript解释器也支持条件注释，C和C++程序员可能觉得它们和C预处埋器的
#ifdef/#endif功能很相似。IE中的JavaScript条件注释以文本@cc_on丌头，以文本@1
结束{cc_on stands中的CC表示条仳编译)。下面的条仆注释包含了只在IE中执行的
代码:

在一条条件往释内部，关键字@f、@else和@end划分出哪些是要被IE的JavaScript解释器
有条件地执行的代码,大多数盱候,只需要上面所示的简单的条件; @if (@_jscript)。
JScript是Microsoft自己的JavaScript解释器的名学，而@_j script变量仟IB中总是
为t rue。
通过条傩往释和常规的JavaScripi注释的合理的交叉组合，可以设置在IE中运行一段代码
而在所有其他浏览器中运行另一段不同的代码;
@cc_ _on
@if (@_jscript)
11这里的代码在一条条件往释中，也在一条常规的Java5cript往释中
//IE会执行这段代码，其他训览器不执行它
alert('You are using Internet Explorer};
@else$/
//这段代码并投在JavaSczipt注释中，们仍然在IE条件往释中
/ 也就是说除了IE，之外的所有浏览器都执行这里的代码
alert('You are not using Internet Explorer');
@en d  

##  [13.5 可访问性](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

Web是发布信息的埋想工具，而JavaScrip程序可以增强对信息的访问。然ri，JavaScript
程序员必须小心，因为程序员写代码太过随意，以至于那些有视觉障碍或者肢体困难的
用户役办法正确地获取信息。
盲人用户使用一种叫微屏箍阅读器的“辅助性找术”将书面的文字变成语音词花。有些
Web浏览器中的JavaScript
333

---
屏幕阅读器是识别JavaScript的，而另一些只能花禁用JavaScript时才会工作得更好。奶
果你设计的站点过于依赖JavaScripl来呈现数据的话，就会把那些使用读屏软件的用户拒
之门外。(当然也会把那些使用像手机这样不支持JavaScrip的移动设备的用户以及那些
有意禁用浏览器脚本的用户排除在外。) JavaScript的角色应当是增加信息的表现力，tfi
不是负贞信息的呈现。JavaScript叮访问性的-条币要原则是，设计的代码即使在禁用
JavaScript解释器的浏览器中也能正常使用(或至少以某种形式正常使用)。
可访问性关心的另-个重要的问题是，对于那些只使用键盘但不能(或者选择不用) 使
用鼠标的用户来说，如果编写的JavaScript代码依赖于特定的鼠标事件，这就会将那些不
使用鼠标的用户排除在外。Web浏览器允诈使用键盘来遍历利激话个Web页面中的UI
元素。并I1JavaScript代码也应该允诈这样做。正如第17章所介绍的，JavaScript文持独
立于设备的事件，例如onfocus和onchange,以及依赖于设备的事件(比如onmouseover
和onmousedown)。为了考虑到可访问性，应该尽可能地支持独立丁设备的事件。
创建可访问的Web页面并非鸡毛蒜皮的小问题，而对于可访问性的完整讨论则超出
了本书的范畴。关心可访问性的Web应用开发者应该阅读这里的文档: http://WWW 

.
w3.org/WAl/inro/aria 

的WA[-ARIA (Web Accessibil ity Initiative-Accessible Rich Interinet
Applications) 标雀。  

##  [13.6 安全性](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

Web浏览器中包含JavaScript解释器，也就是说，-旦载人Web贞面，就可以让任意的
JavaScript代码在计算机毕执行。很明显，这甲存在者安全隐患，浏览器厂商也在不断地
权衡下面这两个方面之间的博弈:
定义强大的客户端API,启用强大的Web应用;
阻止恶意代码读取或修改数据、盗取隐私、诈骗或浪费时间。
就像在其他领域小一样，JavaScript也在盘根错书的安全漏洞和补丁之间不断地发展演
化。在Wcb早期，浏览器添加了类似能够打开、移动、调整窗口大小以及编辑浏览器状
态栏的功能。而当不道德的广告商和骗子开始滥用这些技术，浏览器制作者不得不限制
或禁用这些API。今天，在标准化HTML5的进程中，浏览器厂商会小心(并且开放和合
作性地) 掂量某个长期存在的安全限制，并且在(希望) 不引人新的安全漏洞的基础上
給客户端JavaSeripti舔加少量的功能。
下面几节会介绍JavaScript的安全限制和安全问题，这些问题是每个Web开发者都需要意
识到的。
第13章
334


###  [13.6.1 JavaScript不能做什么](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

Web浏览器针对恶意化码的第一条防线就是它们不支持某些功能。例如，客户端
JavaScripl没有权限来写人或删除客户计算机上的任意文件或列出任意日录。这意味着
(但22.6 5节会介绍JavaScript如何阅读用户
JavaScript程序不能删除数据或植入病毒。
选择的文件，22.7节介绍JavaScript如何实现安全隐私文件系统，以及如何读取和写人
文件。)
上
类似地，客户端JavaScript没有任何通用的网络能力。客户端}avaScript程序可以对HTTP
协议编程(参见第18章) ;并月.HTML.5有一个附属标從叫WebSockets,定义了一个类会
接字的API,用于和指定的服务器通信。但是，这些API都不允诈对于范围更广的网络进
行直接访问。通用的1nternet客户端和服务器不能同时使用客户端JavaScript来写伴’。
浏览器钋对恶意代码的第二.条防线是在自已支持的某些功能上施加限制。以下是-些功
能限制:
JavaScript程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹业窗
口，很多浏览器限制了这‘功能，使得只有为了响应鼠标单市这样的用户触发枣件
的时候，才能使用它。
Java$cript程序可以笑闭自己打开的浏览器窗lF,但是不允许它不经过用户确认就
关闭其他的窗l1.
l{TMI.FileUpload 沈素的value属性尾只读的。如果可以设霞这个属性，脚本就能设
置它为任意斯望的文件名，从而导致表单上传指定文件{比如密码文件} 的内容到
服务器。
脚本不能读取从不同服务器详性&载/
载入的文档的内容，除非这个就足包含该脚本的文
档。类似地，
个脚本不能在来自不同服务器的文档F.注册事件监听器。这虢防止
脚本窃取共他贞面的用户输人(例如，组成一个需码项的键盘单市过程)。这限
制叫做|问源策珞(samne-origin policy)，下:节将重详细地介绍它。
注意，这用并未给出所有的客户端JavaScript的跟制项，不同浏览器有不向的安全策略,
并可能实现不同的API限制。部分浏览器可能还允许根据用户偏好来增强或臧弱限制。
作者在这里的提示非常重爱，我们不能基于测竟器写出一个“服务器”，网络中的浏览
译注7:
器和浏览器之间无法直接进行道信，
译注8: 严格讲这些服务器来自于不目的城、端口或协议,更详细内容请参照13.6.2。
Web浏览器中的JavaScript| 335


###  [13.6.2 同源策略](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

向源策胳是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。当Web页面
使用多个<iframe>元素或者打开其他浏览器窗[ l的时候，这一策珞通常就会发挥作用。
在这种悄况下，同源策略负责管理窗J1或窗体中的JavaScript代码以及和其他窗[1或帧的
交互。具体米说，脚本只能读取和所属文档来源相同的窗[1和文档的属性(参见14.8节
了解如何使用JavaScript操控多个窗口和窗体)。
文档的来源包含协议。主机，以及载入文档的URL端口。从不同Wcb服务器载入的文档
具有不同的来源。通过同一主机的不同端口载人的文档具有不同的来源。便用http:协议
戢人的文档和使用https:协议载人的文档具有不何的来源，即便它们来自同一个服务器。
脚本本身的来源和同源策洛并不相关，相关的是脚本所嵌人的文档的米源，理解这一点
很重要。例如，假设一个来自士机A的脚本被包含到(使用<script>标记的src属性) 宿
主B的一个Wcb页面中。这个脚本的来源是主机B.并且可以完整地访问包含它的文档的
内容。如采脚本打开一个新窗口并载人来自主机B的另--个文档，脚本对这个文档的内
容也其有完全的访问权限。但是，如果脚本打开第三个窗口并载入一个来月主机C的文
档(或者恐来自主机A),向源策略就会发挥作用，阻止脚本访问这个文档。
实际上，同源策略并非应用丁不同源的窗口中的所有对象的所有属性。不过它应用到了
其中的大多数属性，尤其是对Documcnt对象的几乎所有属性而言。凡是包含另一个服务
器中文档的窗口或窗体，都是同源策珞适用的范围。如果脚本打开一个窗口，脚本也叮
以关闭它，但不能以任何方式查看窗口内部。同源策珞还应用于使用XMLHttpRequest生
成的HTTP诮求(参见第18章)。这个对象允许客卢端JavaScript生成任意的HTTP请求到
脚本所属文档的Web服务器，但是不允许脚本和其他Web服务器通信。
对手防止脚本窃取似有的信息来说，同源策珞是必需的。如果役有这一限制，恶意脚本
(通过防火墙裁人到安全的公司内网的浏览器中)可能会打开一个空的窗口，欺骟用户进
入并使用这个窗口在内网上浏览文件。恶意脚本就能够读取窗口的内容并将共发送回自
己的服务器。同源策略防止了这种行为。
不严格的同源策略
在某些情况下，同源策珞就显得太过严格了。本节会介绍三种不严格的同源策略。
向源策略给那些使用多个子域的大站点带来了一些问题。例如，来自home.example.com 

的文档里的脚本想要合法地读取从developer.example.com 

载人的文档的属性，或者来自
orders.example.com 

的脚本可能黹要读catalog.exampie.com 

上的文档的属性。为、支持
这种类型的多域名站点，可以使用Document对象的domain属性。在默认情况下，属性
第13章
336 |

---
donain存放的是载入文档的服务器的主机名。可以设置这~属性，不过使用的字符半必
须具有有效的域前缀或它本身。因此，如果一个domain属性的初始值是字符串“home.
example.com 

”，就可以把它设置为字符申“cxample.com 

"，但是不能设置为“home.
example" 或“ample.com 

”。另外，domain值中必须有一个点号，不能把它设置为
“com" 或其他顶级域名。
如果两个窗口(或窗体) 包含的脚本把domain设置成了相同的位，那么这两个窗口就不
再受同源策略的约束，它们可以相互读取对方的属性。例如，从order.example.com 

利
catalog.example.com 

裁人的文档中的脚本可以把它们的document.domain属性都设置为
“examople.com 

”; 这样*来，这些文档就有了同源性，可以互相读取属性。
不严格的同源策略的第二项技术已经标准化为: 跨域资源共享(Cro8s-Origin Rcsourcc
Sharing,参见http://www.w3.org/TR/cors/ 

)。这个标逄草案用新的“0rigin:" 请求头和
新的Access-Control-A11ow-0rigin晌应头来扩“展HTTP。它允许服务器用头信息显式地
列出源，或使用通配符来匹配所有的源并允许由任何地址请求文件。类似Firefox 3.5和
Safari 4的浏览器可以使用这种新的头信息来允许跨域HTTP请求，这样XMLHttpRequest
就不会被问源策略所限制了。
另一种新技术，叫做跨文档消息(cross-document messaging),允许來自-个文档
的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源忍否不同。调用
Window对象上的postMessage()方法，可以异步传递稍息事件(可以用onmessage事件句
个文档具的脚本还是不能调用在其他文档
处理程序丽数来处理它) 到窗口的文档型,
里的方法和读取属性，但它们可以用这种消息传递技术来灾现安全的通信。参见22.3节
获得更多关于路文档消息API的细节。  

###  [13.6.3 脚本化插件和ActiveX控件](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

尽管核心JavaScript增言和基本的客户端对象模犁缺乏大多数恶意代码所需要的文件系统
功能和网络功能，但情况并不像吞上去那么简单。在很多Web浏览器中，JavaScript亦被
用做很多软件或插件的“脚本引擎”，这样的组件有IE中的ActiveX挖件和其他浏览器的
插件。Flash和Java插件是最常安装的例子，它们为客户端脚本提供了非常重要且强人的
特性。
脚本化ActiveX控件和插件的能力也存在着亥伞性的问题。例如，Java applel具有访问底
层刚络的能力。Java安余“沙箱”阻止app1c(和载人它的服务器之外的任何服务器进行
通信，因此,这并未打开一个安全榻洞。但是，它暴露了一个根本的问题; 如果插件是
可以脚本化的，我们不仅要无条件相信Wcb浏览器的安全架构，还要相信插件的安全架
构。实际上，Java和Flash插件看上去具有健壮的安全性，并且不会为客户端JavaScript引|
Web浏览器中的JavaScriptI 337

---
来安全例题。然忧，ActiveX脚本化有岩更加辨糕的历史遗留问题。IE浏览器已经能够访
问各种各榉的脚本化ActiveX控件,而这些控件是Windows檠作系统的一部分，并且在过
去，操作系就还存在很多可被控件利用的安全漏洞。  

###  [13.6.4 跨站脚本](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

跨站脚木{Cross-site scripting); 或者叫做xss,这个术语用来表示一类安全问题，也就
是攻击者向目标Wcb站点注入HTML标签或者脚本。防止XSS攻击是服务器湍Web开发者
的。项基本工作。然而; 客户端JavaScript程序员也必须意识到或者能够预防跨站脚本。
如果Web贞血动态地产生文档内容，并且这些文档内容总燕于用户提交的数据的，而并
没有通过从中移除任何嵌人的HTML标签来“消毒”的话，那么这个Web页面很容易遭
到跨站脚本攻近。来看。个小例千,考虑如下的Web页面，它使用JavaScript通过用心的
名字来向用川问奸:
<5cript>
vaI name= decodeURICamponent(window.location.search.substring(1)) 11";
document.write("Hel1o " + name);
</script>
这两行脚本使用window.1ocation.search来获得它们自己的URL中以“?* 开始的部分。
它使用document.write{)来向文档添加动态生成的内容。这个页血专门通过如下的~个
URL来调用:
http://ww.examp1e.com/gret.html 

 ?David
这么使用的时候、它会品示文本“HeIlo David”。但考虑一下，当用下面的URL来调用
它，会发牛仆么情况:
http://ww.exap1e.com/greet.hto1?%3Cscript%}Ealert 

('David" )%3C/script%3E
只用这个URL,脚本会动态地生成另一个脚本(%3C和%3E是一个尖插号的编码)。在这
个例子巾，往人的脚本只显示一个对话框，这还是相对较好的情况。但是，如果考怠以
下的情况;
http: /isiteA/greet.htm1?name=%3Cscript sTC=siteB/evil.js%3E%3C/scxipt%3E
之所以叫做跨站脚本攻山。就是因为它涉及多个站点。站点B (或者站点C) 包含:个专
门构造的到站点A的链接{就像比面的那个); 它会往人一个来自站点B的脚本。脚本
eval.jx驻留在恶意站点B中，但现在，它嵌人到站点A中，并H可以对站点A的内容进行
任何想要的操作。它可能拔坏这个页血或者便其不能正常工作(例如，启动下-节所要
介绍的拒绝服务攻击)。这可能会对站点A的用户带来不少坏处。更危险的是，恶意脚
第13章
338

---
术可以读取站点A所存储的cookie (可能是统计数据或者其他的个人验证信息)，然后
把数据发送回站点8。往人的脚本甚至可以诱骗用户击键并将数据发送回站点B。
通常，防止XSS或击的方式是，在使用作何不可信的数拥来动态的创建文档内容之前，
从巾移除HTML标签。可以通过添加如下一行代码米移除<script>标签两边的尖括号，
从而修复前面给出的gret.htm!文件,
卫
name= name.replace(/<1g,"&lt;").replace(/>/g,"&gt;");
上面的简单代码替换把宁符申中所有的火括号替换成它们对应的HTML实体，也就朵说
将字符串中作意HTMI标签进行转义和过滤删除(deactivate) 处理。IE8定义了一个更
加微妙的toStaticHTML()方法，可以移除<script>标签(和其他潜在的可执行内容) 而
不修改不可执行的HTML> toStaticHTML()是不标谁的，但在JavaScript核心代码巾白已
实现一个HTML安全函数也非常简单。
HTML.的内容安企策略则更进一步,它为<iframe>元素定义了一个sandbox属性。在实
现之后，它允许显示不可信的内容，并自动禁用脚本。
跨站脚本使得。个有害的漏洞能够立足于Web的架构之中。深人理解这些跨站脚本的知
识是位得的，但是更深人的讨论超出「本书的范围。有很多在线资源可以帮助你预防跨
站脚本带来的危险。其中一个最重要的参考资料出自原始CERT Advisory: http://WWW 

.
cert.org/advisories/CA-2000 

- 02.html。  

###  [13.6.5 拒绝服务攻击](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

这里描还的同源策路和其他的安全限制可以很好地预防恶意代码毁坏数据或者防止侵犯
隐私这种问题。然而。它们并不能防止另外一种攻击: 拒绝服务攻山，这种攻击手法
非常暴力。如果访问广启用JavaScript功能的‘个恶意Web站点，这个站点可以使用一
个alert()对话框的无限循环占用浏览器，或者用一个无限循环或役有意义的计算来占用
CPC。
某些浏览器可以检测运行时间很长的脚本，并且让用户选择终止它们。但足恶意脚本可
以使用window.setInterval()这样的方法来占用CPC,并通过分配很多的内存来攻击你
的系统。Web浏览器并没有通用的办法束防止这种笨贡的攻击手法。实际上。由于没有
人会返回一个滥用这种脚本的网站，因此这在Web上不是一个常见的问题。  

##  [13.7 客户端框架](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/13.Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript.md#%E7%AC%AC13%E7%AB%A0-web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84javascript)

一些Web开发者发现基于客户端框架或类库来创建它们的Web应用非常便捷。从某种意
义上讲类库也是框架，它们对Web浏览器提供的标雀和专用API进行了封装，向上提供
更高级别的API,用以更高效地进行客户端编程开发。一旦使用一个框架，就耍用框架
定义的APT来写代码，使用框架的--个明显的好处是高级的API可以用更简洁的代码完成
更复杂的功能。此外，完善的框架也会帮我们处理上文提到的很多兼容性.安朵性和叮
访刚性问题。
第19章会介绍jQucry,jQucry是当前最流行的框架之一。如果你决定在你的项日中使用
jQucry,还应该阅读第19章的内容: 理娜底层API会帮助你成为更加优秀的Web开发者，
即使你很少直接使用它们。
除了jQucty以外，还有一些其他的JavaScript框架一远超过在这里列出的框架。其巾有
些开源框架非常有名且广泛使用:
Prototype
Prototype类库(htp /lprotopejs.org 

) 和jQuery类似，是专门针对DOM和Ajax实现
的一套实用1: 具,此外还为语言核心扩展了很多实用I" 具,Scriptaculous (http://
script.aculo.us 

>) 类库是基丁Prototypc来实现的，可以用来做动画和各种视觉特效。
Dnjo
Dojo (htp://dojotooikil.org 

) 是一个大型的框架，它宜称白已“深不可测”。它包
含一个和类繁多的UI组件集合、包管理系统、数垢抽象县等。
YUI
YUI (http://developert.yahoo.com/yuil 

) 是Yahoo! 使用的一个著名框架，是 Yahoo! 的
工程师团队开发的，已经应用在包含Yahoo!主页在内的诸多项目中。YUI和Dojo-
样龙大，是一个无所不包的类库,包抵语言工具、DOM工具，UI组州等。目前已
经有两个不兼容版本的YUI存在，分别为YUI 2和YUI 3。
CIosure
Closurc类库(http:/fcode.googie.comn/ctosurelibrary1) 是Google应用FGmail.
Goog1c Docs和其他Web应用的客户端类库。这个类库是打算和Closure编译器
(htp 1icode.google.com 

!cloxure!campiler/) 配合使用的，剔除没有用的类库函数。
因为没有用的代码会在部署之前被移除，Closure类库的设计者不需姜保持特性集
合的紧禊。所以Closurc包含一个庇大的实用工具集。
GWT
GWT ，即Google Web Toolkit (htp://code.google.com/webroolkitr 

),是一个完全不
同类型的客户端框架。它用JAVA定义了Web应用接口，并提供编译器，将JAVA程
序翻译成兼容的容户端JavaScript。GW1任一些Google产品中使用，旧是不如它们
自己的Closure类库使用得那么广悦。
