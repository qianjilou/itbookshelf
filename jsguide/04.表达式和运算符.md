## [第4章 表达式和运算符](https://github.com/qianjilou/itbookshelf/tree/master/jsguide)
###  [4-1 原始表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#41-%E5%8E%9F%E5%A7%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  [4-2 对象和数组的初始化表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#42-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  [4-3 函数定义表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#43-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  [4-4 属性访问表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#44-%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  [4-5 调用表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#45-%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  [4-6 对象创建表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#46-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  [4-7 运算符概述](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#47-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A6%82%E8%BF%B0)
###  [4-8 算术表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#48-%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  [4-9 关系表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#49-%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  [4-10 逻辑表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#410-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F)
###  4-11 赋值表达式
###  4-12 表达式计算  
###  [4-13 其他运算符](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#413-%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6)
---

表达式(expression) JavaScript中的一个短语，JavaScript解释器会将其计算
(evaluate) 出一个结果。程序中的常量是最简单的一类表达式。变量名也是一种简单的
表达式,它的值就是赋值给变量的值。复杂表达式是由简单表达式组成的。比如，数组
访问表达式是由一个表示数组的表达式、左方括号、一个整数表达式和石方括号构战。
它们所组成的新的表达式的运算结果是该数组的特定位置的元素值。同样的，函数调用
表达式由一个表示函数对象的表达式和0个或多个参数表达式构成。  


将简单表达式组合成复杂表达式最常用的方祛就是使用运算符(operator)。运算符按照
特定的运算规则对操作数(通常是两个) 进行运算.并计算出新值。乘怯运算符“*”
是比较简单的例子。表达式x*y是对两个变昼表达式x和y进行运算并得出结果。有时我
们更愿意说运算符返回了一个值而不是“计算”出了一个值。  

本章将讲解所有的JavaScript运算符,同时也讲解不涉及运算符的表达式(比如访问数组
元素和函数调用)。如果你熟悉C语法风格的其他编程语育，.你会发现大多数JavaScript
表达式和运算符都似曾相训。

##  [4.1 原始表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

最简单的表达式是“原始表达式”
(primary expression)。原始表达式是表达式的最小
单位---它们不再包含其他表达式。JavaScript中的原始表达式包含常盘或真接量.关键
字和变章。
直接量是首接在程序中出现的常数值。它们看起来像;
11数字直接量
1.23
60

---
11字符中直接毋
"hello"
11正则戋汰式直接址
/pattern/
JavaScript数字直接氧的语法在3.1节已经做了讲解。字符申直接量在3.2节做了讲解。正
则表达式直接量语法在3.2.4节做广简单介绍，在第10章将做专门讲解。
JavaScript中的--些保留字构成了原始表达式:
1! 返回一个布尔值: 真
t如ue
11返回一个布尔值: 假
fal se
/! 返回一个值: 空
null
11返回”当前“对象
this
我们]在3.3节和3.4书中学习了true.false和nu11l。和其他关键字不问,this并不尼
个常量，它在程序的不同地方返回的值也不相同。t hi s关键字经常在面向对象编程中出
见。在一个方法体内，this返叫调用这个方祛的对象。参照4.5书、第8章(8.2.2节) 和
第9章来荻取关于this的详细信息。
最后，第三种原始表达式是变量:
11返四变冠i的值
//返回5um的值
Sum
1undefined是全局变母，和null 不同，它不是一个关犍宁
undefined
当JavaScript代码中出现了标识符，JavaScripl会将其当做变量而去查找它的值。如果变
最名不存在，表达式运算结果为undefined。然而，在ECMAScript 5的严格模式中，对不
存在的变最进行求值会抛出一个引用错误异常。  

##  [4.2 对象和数组的初始化表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

对象和数组初始化表达式实际上是一个新创建的对象和数组。这些初始化农达式有时称
做“对象直接盘”和“数组直接量”。然而和布尔直接量不问，它们不是原始表达式,
因为它们所包含的成员或者元素都是子表达式。数组初始化表达式语法非常简单，我们
以此开始。
数组初始化表达式是通过一对方括号利其内由逗号膈开的列表构成的。初始化的结果足
一个新创建的数组。数组的元素是逗号分隔的农达式的值:
1一个空数组: []内宵空即表示该数组没有任何元素
:]
[1+2,3+4]
/! 拥有两个元業的数组，第:个是3，第一个恳7
表达式和运算苻| 61

---
数组初始化表达式中的元桊初始化表达式也可以是数组视始化表达式。也就是说，这些
表达式是可以嵌套的:
var matrix= [[1,2,3],[4,5,6],[7,8,9]];
JavaScript对数组初始化表达式进行求值的时候，数组初始化表达式中的元素表达式也
都会各肖计算一次。也就是说，数组初始化表达式每次计算的值有可能是不同的。
数组直接量中的列表逗号之间的元素可以省略，这时省略的空位会填充值undefined。例
如，下面这个数组包含5个元素，其中三个元素是undefined:
var sparseArray = [1,,>;5] ;
数组直接量的元素列表结尾处可以甯下单个逗号，这时并不会创建一个新的值为
undefined的元素。
对象初始化表达式私数组初始化表达式非常类似，只是方括号被花括号代替，并且每个
子表达式都包含一个属性名和一个冒号作为前缀:
1l 一个拥有两个属性成员的对象
var p = {x:2.3; y:-1.2 };
var q = {};
个空对象
11q的属性成员和p的一样
q.x = 2.3; q.y =-1.2;
对象直接量也可以嵌盒，比如;
var rectangle ={ upperleft:{ x: 2,y: 2 },
lowerRight:{ x; 4,y; 5} }
JavaScript求对象初始化表达式的值的时候，对象表达式也都会各自计算一次，并H它
们不必包含常数值:它们可以是任意JavaSctipl表达式。同样，对象直接昼中的属性名称
可以是宁符串而不足标识符(这在那些只能使用保留字或一些非祛标识符作为属性名的
地方非常有用) ;
a side = 1;
vaI square={ "uppeILeft":{ x: p.X,y: P.y };
'lowerRight' :{ x; p.x + side,y: p.y + $ide}};
第6章和第7章会再次讨论对象和数组的初始化表达式。  

##  [4.3 函数定义表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

函数定义表达式定义一个JavaScript函数。表达式的值是这个新定义的函数。从某种意义
上讲.函数定义表达式可称为“函数直接量”; 毕竞对象初始化表达式也称为“对象直
接量”。个典型的的数定义表达式包含关键字function,跟随其后的是一对圆括号，
括号内足~ 个以逗号分割的列表，列表含有0个或多个标识符(参數名)，然后再跟随
一个由花括号包襄的JavaSeript代码段(幽数体)，例如:
11这个的数返回传人参数伉的平方
var square = functicn(x) {return x 半X; }
函数定义表达式同样可以包含函数的名字。函数也叮以通过凼数语句来定义，浙不是咱
数表达式。更多详情会在第8章中讨论。  

##  [4.4 属性访问表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

属性访问表达式运算得到一个对象属性或一个数组元素的值。JavaScript为属性访问定义
「两种语法:
expressin,identifier
expression[ expression
第一种写祛是一个表达式后跟随一个句点和标识符。衣达式指定对象，标识符则指定需
要访问的属性的名称。第二种写法是使用方括号，方挢号内是另外一个表达式(这种方
法适用于对象和数组)。第二个表达式指定要访问的属性的名称或者代表要访问数组元
素的索引[。这单有些具体的例子:
11一个示例对象
var D = {x:1,y:{Z:3}};
1一个包含这个对象的示例数组
vaI a= [o,4,[5,6]]:
1=> 1: 表达式o的x属性
1=> 3: 表达式a.y的z属性
Iry+Z
o["x"]
11=> 1: 对象o的x腐性
11=> 4: 表达式a中案引为1的元崇
a[1]
a[zj["1"]
11=> 6: 表达式a[2]中蒙引为1的元索
11=> 1: 表达式a[C]的x属性
a[C].x
不管使用哪种形式的属性访问农达式，在“.”和“[”.之前的表达式总是会首先计算。
如果计算结果足nu11成者undefined,表达式会抛出一个类型错误异常，因为这两个值都
不能包含任意属性。如果运算结果不是对象(或者数组)，JavaScript会将其转换为对象
(参芩3.6节)。如果对象表达式后跟随句点利标识符，则会查找由这个标识符所指定的
属性的值，并将其作为整个表达式的值返回。如果对象农达式后跟随一对方括号，则会
计算方括号内的表达式的值并将它转换为字符串。不论哪种情况，如果命名的属性不存
在，那么整个属性访问表达式的值就是undefined。
陇然.identifier的写祛更加笏单，但需要往意的是，这种方式只适用于要访问的臧性名
称是合祛的标识符,并且需要知道要访问的属性的名字。如采属性名称是-个保留宁或
表达式和运算符
53

---
者包含空格和标点符号，或是一个数字(对于数组来说)，则必须使用方括号的写法。
当属性名是通过运算得出的值而不是固定的值的时候，这时必须使用方抵号写祛(具体
示例参照6.2,1节)。
对象和其属性的细节会在第6章涵盖。数组及其元岽会在第7章讲述。  

##  [4.5 调用表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

JavaScript中的调用表达式(invocation expression) 是一种调用(或者执行) 匪数或方法
的语祛表示。它以一个函数表达式开始，这个函数表达式指代了要调用的函数。的数表
达式后跟随一对圆括号，括号内是一个以逗号隔开的参数列表，参数可以有0个也可有
多个，例如:
f(0)
1l f是个函数表达式; 0是--个参数衣达式
Math,max(x,y,z)
11Math.max 是一个函数; X; y 和Z 是参数
a.soIt()
'1a.sort是一个函数，它役有参数
当对调用表达式进行求值的时候，首先计算函数表达式，然后计算参数表达式，得到一
组参数值。如果函数表达式的位不是一个可调用的对象，则抛出一个类型错误异常(所
有的函数都是可调用的，即使宿主对象不是函数它也有可能被调用，这里的|别将在
8.7.7节讲述)。然后; 实参的值被依次赋值给形畚，这些形参是定义函数时指定的，接
下米开始执行函数体。如果函数使用1eturn语句给出一个返回值，那么这个返回值就是
整个调用表达式的值。否则，调用表达式的值就是undefined。函数调用-
包括当形参
表达式的个数和函数定义中实参的个数不匹配的时候的运行情况-
的细节将会在第8章
详细讨论。
任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式。如果这个表达式是一
个属性访问表达式，那么这个调用称做“方法调用”(method invocation)。在方祛调
用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指
问。这种特性使得在面何对象编嵇范例中，闲数(其OO名称为“方法”) 可以调用其
宿主对象。参照第9章以获取更相信的信息。
并不是方法调用的调用表达式通常使用企局对象作为this关键字的值。然而在
ECMAScript 5中.那些通过严格模式定义的幽数在调用时将使用undefined作为this的
值,this不会指向全局对象。参照5.7.3节以获得更多关于严格模式的信息。  

##  [4.6 对象创建表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

对象创建表达式(object crcation cxprcssion} 创建一个对象并调用一个函数(这个垴数
第4章

---
称做构造函数) 初始化新对象的属性。对象创建表达式利丽数调用表达式非常类似，只
是对象创建表达式之前多了一个关键字new;
new 0bject( )
new Point(2,3)
如果一个对象创建表达式不皆要传人任何参数给构造困数的话，那么这对空圆括号是可
以省略棹的:
new 咖ject
new Date
当计算一个对象创延表达式的值时,和对象初始化表达式通过{}创建对象的儆祛:样,
]avaScript首先创处一个新的空对象，然后，JavaScript通过传人指定的畚数并将这个新
对象当做this的值来调用一个指定的函数。这个函数可以使用this来初始化这个新创建
对象的属性。那些被当战构造函数的函数不会返问一个值，并且这个新创建并被初始化
后的对象就是整个对象创建表达式的值。如果.-个构造函数确实返刚了一个对象值，那
么这个对象就作为整个对象创建表达式的值，1新创建的对象就废弃了。
构造函数的细节将在第9章讲述。  

##  [4.7 运算符概述](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

JavaScript中的运算符用十算术表达式、比较表达式.逻辑表达式、赋值表达式等。
长4-1简单列出了IavaScript中的运算符，作为个方便的参照。
需要注意的是，大多数运算符都是由标点符号表示的，比如“+”和“=”。而另外一些
运算符则是由关键字表示的，比奶delete和instanceof。关键字运算符和标点符号所表
示的运算符一样都忍正规的运算符，它们的语法都非常言简意赅。
表4-1是按照运算符的优先级排序的，前面的运算符优先级要高十后面的运算符优先级。
被水平分割线分隔开来的运算符具有不同的优先级。标题为A的列农示运算符的结合
性，L (从左至右) 或R (从右至左)，标题为N的列表示操作数的个数。标题为“类
型”的列表示期望的操作数类型，以及运算符的结果类型(在“一”符号之后)。裁4-1
之后的段落会解释优先级、结合性和操作数类型的概念。表4-1贝对运算符做单独讨论。

###  4.7.1 操作数的个数  

向
49
运算符叮以根拢其操作数的个数进行分类。JavaScript中的大多数运算符(比如“*”乘
祛运算符} 是个二元运算符(binary operator),将两个表达式合并成一个稍复杂的
表达式。换言之，它们的操作数均是两个。JavaScript同样支持一些一元运算符(unary
operator)，它们将
个表达式转换为另个稍复杂的表达式。表达式一x中的“-" 运
算符就是一个一元运算符，是将操作数x求负值。最后，JavaScript支持个三元运算符
它将三个表达式合并成一个农达式。
(tcrnary operator)，条仆判断运算符  

###  4.7.2 操作数类型和结果类型  

一些运算符可以作用于任何数据类型，但仍然希望它们的操作数是指定类型的数据，并
且大多数运算符返回(或计算出)一个特定类型的值。在表4-1标题为“类型”的列中列
出了运算符操作数的类型(箭头前) 和运算结果的类型(箭头后)。
JavaScript运算符通常会根据需要对操作数进行类犁转换(参照3.8节)。乘法运算符
希望操作数为数字，但表达式”3"*"5”却是合法的，因为JavaScript会将搡作数转换
“*?
为数宇。这个表达式的值是数字15,而不尼字符串“15”。之前也提到过，JavaScript
中的所有俏不尼真值胱尼假值，因此对于那些希望操作数悬布尔类型的操作符来说，它
们的操作数可以足任意类型。
有些运算符对操作数类型有着不同程度的依赖。最明显的例子是加法运算符，“+”
运算符可以对数宇进行加法运算，也可以对字符串作连接。同样，比如“<”比较运算
符可以根据操作数类型的不同对数字进行大小值的比较，也可以比较宇符在字母表中的
次序先后。单个运算符的描述充分解释了它们对类型有着怎样的依赖以及对操作数进行
怎样的类型转换。  

###  4.7.3 左值  

你叮能会注意到，表4-1中的赋侑运算符和其他少数运算符期望它们的操作数是1va1类
型。左值{lvalue) 是一个古老的术语，它是抬“表达式只能出现在赋值运算符的左
则”
在JavaScript中,变量、对象属性和数组元素均是左值。ECMAScript规范允许内
置网數返回一个左位，但自定义的角数则不能返回左值。  

###  4.7.4 运算符的副作用  

计算一个简单的表达式(比如2*3) 不会对程序的运行状态遣成任何影响，程序后续执
行的计算也不会受到该计算的影响。而有一些表达式则具有很多副作用，前后的表达式
运算会相互影响。赋值运算符是最明显的一个例子: 如果给一个变肇或属性赋值，那么
表达式和运算符
|67

---
那些使用这个变昼或属性的表达式的慎都会发生改变。
*+”和“_--" 递增和递减运算
符与此类似，因为它们包含隐式的赋慎。de1ete运算符同样有副作用;删除一个属性就
像(但不完企:样) 给这个属性贼值undefined。
其他的JavaScript运算符都没有副作用，但函数调用表达式和对象创建表达式有些特别，
在函数体或者构造因数内部运用了这些运算符井产坐了副作用的时候，我们说函数调用
表达式和对象创建表达式是有副作用的。  

###  4.7.5 运算符优先级  

表4-1中所示的运算符是按照优先级从高到低排序的，每个水平分割线内的一组运算符具
有相同的优先级。运算符优先级控制着运算符的执行顺序。优光级高的运算符(表格的
顶部) 的执行总是先于优先级低(表格的底部) 的运算符。
看一下下面这个表达式:
w口x+y*z;
乘法运算符“*”比加法运算符“+”具有更高的优先级，所以乘法先执行，加祛后执
行。然后; 由于赋值运筧符“=”具有最低的优先级，因此赋值操作是在右侧的表达式
计算出结果后进行的。
运算符的优先级可以通过显式使用圆挢号来重写。为了让加祛先执行，乘祛后执行，可
以这样写:
w= (x + y)*z;
需要往意的足，属性访问表达式和调用表达式的优先级要比农4-1中列出的所有运算符都
要高。看一下这个例子:
typeof my.functions[x] (y)
尽管typeof是优先级最高的运算符之一，但typeof也是在两次属性访问和函数调用之后
执行的。
实际上，如果你真的不确定你所使用的运算符的优先级，最简单的方祛就是使用圆括号
来强行指定运算次序。有些重要规则需要熟记: 乘法和除法的优先级高于加法和减法，
赋值运算的优先级非常低，通常总是最后执行的。  

###  4.7.6 运算符的结合性  

在表4-1中标题为A的列说明了运算符的结合性。L指从左至右结合，R指从右至左结合。
第4章
;8|

---
结合性指定了在多个具有同样优先级的运算符表达式中的运算顺序。从左至右是指运算
出
的执行是按照由左到右的顺序进行。例如，减法运算符具有从左至布的结合性，内此:
叫
w=x-y-z.
和这段代码一模一样:
w=((x-y)-z)
反过来讲，下面这个表达式:
x=~-y;
w=x=y=z;
q = a?b:c?d:c?f:g;
和这段代码一模一样:
x=~(-y);w=(x=(y=z));q=
a?b;(c?d;(e?f:g));
因为一元操作符、赋值和三元条件运算符都具有从右代东的结合性。  

###  4.7.7 运算顺序  

运算符的优先级和结合性规定了它们任复染的表达式中的运算顺序，但并没有规定子表
达式的计算过程中的运算顺序。JavaScript总是严格按照从左至右的顺序来计算表让式。
例如，在表达式w=X+y*z中; 将首先计算子表达式W，然后计算x.y和z; 然后,y的值和z
的值相飛，再加1E.X的值，最后将其斌值给表达式w所指代的变量或属性。给表达式添加
囡哲号将会改变乘法、加祛利|赋值运算的关系，但从左至右的顺序是不会改变的。
只有在任何一个表达式其有副作用而影响到其他表达式的时候，其求值顺序才会和看k.
去有所不同。如果表达式x中的一个变量自增1，这个变量在表达式z中使用，那么实际
上是先计算出了x的值再计算z的值，这一点非常重要译社1。  

##  [4.8 算术表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

本节涵盖了那些进行算术计算的运算符，以及对操作教的算术操作。乘法.除法和减祛
译泫1: 作者在这里搦示了--种很容易忽略的观象。假设存在a=].那么“b=(a++)+a;" 将如何让
箅结罘呢? 按照正文所述，项序应该是，[) 计算b，2) 计算a++ (假设值为c)，3)
计算8，4) 讦算c+a，5) 将c+a的结呆斌值给b。按照“++”的定义，第2) 少中a++的
结果依然是1,即c为1,随后a立卬壈1，因此在执行第3) 步时、a的位已经是2。所以b的
站果为了。很多初学者会误认为a增1的操作是在表达式计算完毕后执行的。
表达式和运算符] 69

---
运算符非常简单，找们首先讲解它们。加法运算符单独占一书，因为加祛同样可以做字
符申连接操作，并且其类型转换有些特殊。一元运算符和位运算符同样在单独的两节中
会讲到。
基本的算术运算符是* (乘祛)、1(除法).% (求朵)、+ (加迭) 和一{减法)。我
们会在随后有专门一节讲述“+”运算符。剩下的4个运算符非常简单，只是在必要的
时候将操作数转换为数字而已，然后求积、商、余数和差。所有那些无祛转换为数字
的操作数都转换为NaN值。如果操作数(或者转换结果) 是NaN值，算术运算的结果也
尼NaN。
运算符“1”用第二个操作数束除第:个操作数，如果你使用过那些区分蓥型和俘点型数
字的编程语言，那么当用一-个整数除以另一个整数时，则希望得到的结果也是整数。但
在JavaScript中,所有的数‘宁都是评点型的，除法运算的结果也是浮点型，比如，5/z的
结果是2.5，而不是2。除数为0的运算结果为正无穷大或负无穷大，而O/0的结栗是NaN,
所有这些运算均不会报错。
译任2
运算符“%”计算的是第一个操作数对第二个操作数的模"
换句话说，就是第一个
操作数除以第二个操作数的佘数。结果的符号和第一个操作数(被除数) 的符号保持
致。例如，5%2结果是1，-5%2的结果是~1。
求余运算符的操作数通常都是整数，但也适用于浮点数，比如，6.5%2.1结果是O.2.  

###  4.8.1 "+"运算符  

一元加法运算符“+”可以对两个数字做加法，也可以做字符串连接操作:
hello" + u 。+
there" 11=>"hello there"
"1" + "2" 1{ => "12"
当两个操作数都是数宁或都是字符串的时候，计算结果是显而易见的。然而对下其他惝
况来说; 则要进行一些必要的类型转换，井且运算符的行为依赖于类型转换的结果。加
号的转换规则优先考虑字符串连接，如果其中一个操作数悬字符串或者转换为宇符串的
对象，另外一个操作数将会转换为字符串，加法将进行字符串的连接操作。如果两个操
作数都不尼类宁:符串(string-like) 的。那么都将进行算术加法运算。
从技术上讲，加法操作符的行为表现为:
如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始
类值(参照3.8.3节): 日期对象通过toString()方法执行转换，其他对象则通过
译注2; 求余运算也叫做模运算，模就是佘数。
第4章
---
valueOf()方法执行转换(如果value0f()方法返回一个原始值的话)。由于多数对
象都不具备可用的value0f()方法，因此它们会通过toString()方祛来执行转换,
山8
在进行了对象到原始值的转换后，如果其4!一个操作数是字符串的话; 另一个操作
数也会转换为字符串，然后进行字符串连接。
不则，两个操作数都将转换为数字(或考NaN)，然后进行加法操作。
这里有--些例子:
1/=> 3: 加祛
1!=>"12": 字符串连接_.4.
1/=>"12": 数字转换为字符串后进行字符串连接
11=>"1[bject Dject]": 对象较换为宇符串后进行字符事连接
true + true 11=> 2: 布尔值转换为数宇后敷加法
!!=> 2: nu11转换为0后儆加祛
2 + nu1l
2 + undefined 11=> NaN: undefincd转换为NaN后儆加祛
最后，铺要特别往意的是，当加号运算符和字符串和数宇一起使用时，斋要考虑加法的
结合性的对运算顺序的影响。也就是说，运算结果是依赖于运算符的运算孤序的，比
如:
11=>"3 blind mice"
blind mice";
1! => "12 blind mice"
(2 + " blind mice");
第一行没有 圆 括号，
运算符具有从左至右的结合性，因此两个数字首先进行加祛
计算，计算结果和字符用进行连接。在第二行中，孤括弓改变了运算顺序: 数字2和字符
串连接，生成一个新字符串，然后数字1和这个新字符串再次连接,生成了最终结果。  

###  4.8.2 一元算术运算符  

一元运算符作用于一个单独的搛作数,并产坐一个新值。在JavaScript中，一元运算符
具有很高的优先级，而且都是有结合(right-associative)。本节将讲述一元算术运算符
(+、一.++和--)，必要时，它们会将操作数转换为数宇。需要注意的是，“+" 和
是一 元运 算符，也是 二元运 算符。
下面介绍一元算术运算符;
一元加法(+)
元加法运算符把操作数转换为数宁(或者NaN)，井返回这个转换后的数字。如
果操作数本身就恳数字，则直接返回这个数字。
表达式和运算符

---
一元减公(-)
当“-" 用做一元运算符时，它会根据需妥把操作数转换为数字，然后改变运算结
果的符号。
递增++
运算符对其操作数进行增盘(加一) 操作，操作数是一个左值
递增
(Ivalue)
(变量、数组元素或对象属性)。运算符将操作数转换为数字，然后给
数字加1,并将加1后的数值重新赋值给变展、数组元素或者对象属性。
递增运算符的返回值依赖于它相对于操作数的位置。当运算符在操作数之
{prc-incrcmcnt) 运算符，它对操作数进行增量计算，并返
前，称为“前增悬”
回计算后的值。当运算符在操作数之后，称为“后增”(post-inerement) 运算
符，它对操作数进行增盘讣算，但返回未做增量计算的(unincremented) 值。思考
一下如下两行代码之间的区别:
'1i和j的值都是2
vari=1jj=+i;
'I 1是2.j是1
Vari = 1g ]= i++;
“++”运算符从不进行宇符串
需要往意的是，表达式++x并不总和x=X+1完全一样，
迎接操作，它总是会将操作数转换为数字井增1。如果x是宇符率“1”,++x的结果
就是数字2,而x+1是字符串“11”。
同样需要往意的是，由fJavaScript会自动进行分号补全，因此不能在后增昼运算
符和操作数之间插人换行符。如果插人了换行符，JavaScript将会把操作数当做--
条单独的语旬，并在其之前补上一个分号。
不管尼前增量还匙后增量，这个运算符通常用在for循坏中，用于控制循环内的计
数器(见5.5.3节)。
邋减(--)
递减“一”运算符的操作数也是一个左值。它把操作数转换为数字，然后减l,并
将讣算后的值重新赋值给操作数。和“++”运算符一样，递减“--”运算符的返
回值依赖于它相对操作数的位置，当递减运算符在操作数之前。操作数减1并返回
减1之后的值。当递减运算符在操作数之后，操作数减1并返回减1之前的值。当递
减运算符在操作符的右侧时，运算符和操作数之间不能有换行符。  

###  4.8.3 位运算符  

位运算符可以对由数宁表示的二进制数据进行更低层级的按位运算。尽管它们并不是传
统的数学运算，但这里也将其归类为算术运算符，因为它们作用于数值类型的操作数并
返回数字。这些运算符在JavaScript编程中并不常用，如果你对十进制整数的二进制表示
72
第4章

---
并不熟悉的话，你可以跳过本节内容。这里的4个运算符都尼对操作数的每个位进行布
水运算，这里将操作数的每个位当做布尔值(J=true,0=false); 其他三个位运算符用
来进行左移位和右移位。
位运算符要求它的操作数是整数，这些整数表示为32位整型而不是64位俘点型。必要
时,位运算符首先将操作数转换为数字，并将数字强制表示为32位整型，这会忽咯原格
式中的小数部分和任何超过32位的二进制位。移位运算符要求右操作数在0~31之间。
在将其操作数转换为无符号32位整数后，它们将合弃第5位之后的二进制位，以便生成一
个位数正确的数字。需要注意的是，位运算符会将NaN、Infnity和-Infinity都转换为0。
按位与(&)
位运算符“&”对它的整型操作数逐位执行布尔与(AND) 操作。只有两个操作数
中相对应的位都是1,结果中的这一位才是1。例如。0x1234 & 0x00FF= 0x0034。
按位或(i)
位运算符“|”对它的憋型操怍数逐位执行布尔或(0R) 操作。如果其中一个操
作数相应的位为1，或者两个操作数相应位都是1,那么结果中的这一位就为1。例
如: 0X1234| 0X00FF = 0X12FF。
按位异或{^}
位运算符“I”对它的整型操作数逐位执行布尔异或(XOR) 操作。异或是指第，
个操作数为true或第二个操作数刈true,但两者不能|问时刈true。如果附个操作
数中只有一个相应位为1(不能同时为1)，那么结果中的这。位就足1。例如，
OXFFOO ^ 0xF0FO = 0x0FF0。
按位非(~)
运算符“~”是一元运算符，位子一个整型参数之前，它将操作数的所有位取反。
根据JavaScript中帮符号的整数的表示方法，对一个值使用“~”运算符相当于改
变它的符号并减l。例如，~0x0F= 0xFF0或-16。
左移(<<)
将第一个操作数的所有二进制位进行乐移操作,移动的位数由第二个操作数指定，
移动的位数是0~31之间的一个整数。例如，在表达式a<<1中，a的第一位变成了第
二位，a的第二位变成了它的第三位，以此类推。新的第一位用0来补充，舍弃第32
位。将一个值左移1位相当于它乘以2,左移两位相当于乘以4,以此类推。例如，
7<<2=28.
带符号石移{>>)
运算符“>>" 将第一个操作数的所有位进行石移操作，移动的位数由第二个操作
数指定，移动的位数是D~31之间的一个整数。右边溢出的位将忽略。填补在左边
表达式和运算符| 73

---
的位由原操作数的符号决定,以便保持结果的符号与原操作数一致。如果第一个操
作数是正数。移位后用0填补最高位; 如果第一个操作数是负的，移位后就用1填补
高位。将一个值右移1位，相当于用它除以2 (忽略佘数)，有移两位，相当丁它除
以4.以此类推，例如，7>>1=3，-7>>1=-4。
无符号方移(>>>)
运算苻“>>>" 和运算符“>”一样。只是点边的高位总是填补0，与原来的操作
数符号无关，例如，一1>>4=-1，但是-1>>>4=0xOFF  

##  [4.9 关系表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

本节介绍JavaScript的关系运算符。关系运算符用丁测试两个值之间的关系(此如“札
等”，“小于”，或“是..的属性”)，根据关系是否存在而返问true或false。关系表
达式总是返四一个布尔值，通常在if.while或者for语句(参照第5章) 中使用关系表达
式，用以控制程序的执行流程。接下来的几节将会讲述相等和不等运算符、比较运算符
和JavaScript中其他两个关系运算符in和instanceof。  

###  4.9.1 相等和不等运算符  

“= =”运算符用丁比较两个值是否相等，当然它们对相等的定义不尽相同。
两个运算符允许任意类型的操作数，如果操作数相等则返问true,否则返叫false。
"==="也称为严格相等运算符(strict equality)
(有时也称做恒等运算符(identity
operator})，它用来检测两个操作数是否严格相等。“==" 运算符称做相等运算符
(equality operator)，它用来检测两个操作数是否相等，这里“相等”的定义非常究
松。可以允许进行类型转换。  

“==" 和“===”运算符。你应当殂解这些(赋值相等、恒
JavaScript支持“=”
等) 运算符之间的区别，并在编码过程中小心使用。尽管它们都可以称做“相等”
但为了减少概念混淆，应该把“=”称做“得到或赋值”，把“==" 称做“相等”，把
*===”称做“严格相等”
“!=”和“!==" 运算符的检训规则忍“==" 和“===" 运算符的求反。如果两个值通
过“==" 的比较结果为true; 那么通过“!=”的比较结果则为fa1se。如果两值逍过
“===" 的比较结果为true,那么通过“!==* 的比较结采则为false。4.10节会提到，
“!" 运算符是布尔非运算符。我们只要记住“!=" 称做“不相等”、“!==”称做“不
严格相等”就可以了。
在3.7节已经提到,JavaScrip(对象的比较是引用的比较，而不是值的比较。对象和其本
第4章

---
身是相等的，但和其他任何对象都不相等。如果两个不同的对象具有相同数世的属性，
相同的属性名和值，它们依然悬不相等的。相应位置的数组元素是相等的两个数组也是
不相等的。
严格相等运算符“===”首先让算其操作数的值，然后比较这两个值，比较过程没有任
何类型转换:
如果两个值类型不相同，则它们不相等。
如果两个值都是nu11或者都是undefined,则它们不相等,
如果两个值都是布尔值true或都是布尔值false,则它们相等。
如果其中一个值是NaN,或者两个值都是NaN，则它们不相等。NaN和其他任狱值都
是不相等的，包括它本身! 通过xI==x来判断x是否为NaN,只有在x为NaN的时候; 这
个表达式的值才为true。
如果两个值为数字且数值相等，则它们相等。如果一个值为0,另一个值为~l),则
它们同样相等。
如果两个值为字符串，且所含的对应位上的16位数(参照3.2节) 完全相等，则它
们相等。如果它们的长度或内容不同，则它们不等。两个字符串可能含义完全一-样
且所显示出的字符也一样，但其有不同编码的16位值。JavaSeript并不对Unicodc进
行标催化的转换，因此像这样的字符串通过“===”和“==”运算符的比较结果也
术相等。第三部分的String,localeCompare()提供了另外一种比较字符串的方法。
如果两个张用位指向同一个对象、数组或函数，则它们是相等的。如果指向不同的
对象，则它们是不等的，尽管两个对象具有完全一样的属性。
相等运算符“==”和怄等运算符相似，但相等运算符的比较并不严格。如果两个操作数
不是同一类型，那么相等运算符会尝试进行一些类型转换，然后进行比较:
如果两个操作数的类型相同，则和上文所述的严格相等的比较规则一样。如果严格
相等，那么比较結果为相等。如果它们不严格相等，则比较结果为不相等。
如果两个操作数类型不同，“==" 相等操作符也可能会认为它们相等。检测相等
将会遵守如下规则和类型转换:
一如果.-个值是nu11，另一个是undefined,则它们相等。
一如果一个值是数宇，另一个是字符串，先将字符申转换为数宇，然后使用转换
后的值进行比较。
一如果其中一个值是true,则将其转换为1再进行比较。如果其中一个值是false,
则将共转换为0再进行比较。
75
表达式和运算符

---
一如果一个值尼对象，另一个值是数字或字符串，则使用3.8.3书所提到的转
换规则将对象转换为原始值，然后再进行比较。对象通过toString()方法或
者va1ue0f()方祛转换为原始值。JavaScript语言核心的内置类首先尝试使用
value0f(),再尝试使用toString(),除」日期奖，E 期类只使用toString()转
换。那些不是JavaScript语言核心中的对象则通过各白的实现中定义的方法转换
为原始值。
一其他不问类型之间的比较均不相等。
这里有一个判断相等的小例子;
"1"==true
这个表达式的结果是true; 这表明完全不问类型的值比较结果为相等。布尔值true首先
转换为数字1,然后再执行比较。接下来，字符审“l" 也转换为了数宇1,因为两个数
字的值相等，因此比较结果为true.  

###  4.9.2 比较运算符  

比较运算符用来检测两个操作数的大小关系(数值大小或名字母表的顺序) ;
小于(<)
如果第一个操作数小于第二个操作数，则“<”运算符的计算结果为trues 否则为
fa lse。
大于(>)
如果第一个操作数大于第二个操作数,则“>”运算符的计算结果为true; 否则为
false。
小于等于(<=)
如果第一个操作数小于或者等于第二个操作数，则“<=”运算符的计算结果为
true; 否则为false。
大于等于(>=)
如果第一个操作数大于或者等于第二个操作数，则“>=" 运算符的计算结果为
falses 否则为false。
比较操作符的操作数可能是任意类型。然而，只有数字和宇符串才能真正执行比较操
作，因此那些不是数字和字符串的操作数都将进行类型转换，类型转换规则如下:
如果操作数为对象，那么这个对象将依照3.8.3节结尾处所描述的转换规则转换为
76
第4章

---
原始值: 如录value0f()返叫一个原始值，那么真接使用这个原始值。否则，使用
toString()的转换结朵进行比较操作。
在对象转换为原始值之后，如果两个操作数都是字符串，那么将依照字母表的顺序
对两个字符申进行比较，这里提到的“字母表顺序”是指组成这个宇符串的16位
Unicode学符的索引顺序。
如果节少有一个操作数不是字符串，那么两个操作数都
在对象转换为原始值之后，
将转换为数宇进行数值比较。0和一0是相等的。Infinity比其他任何数字都大(除
了Infinity本身)，-Infinity比其他任何数字都小(除了它自身)。如哭其中一
个撮怍数是(或转换后是) NaN,那么比较操作符总是返叫false.
需要注意的是，JavaScript字符用是一个山16位整数值组成的序列，字符用的比较也只是
两个字符串中的字符的数值比较。由Uaicode定义的字符编码顺序和任何特定语言成者
本地语言宁符集中的传统宁符编码顺序不尽相同。往意，宁符申比较忍区分大小写的,
所有的大写的ASCII宁母都“小千”小写的ASCII=母。如果不注意这条不起眼的规则的
话会造成一些小麻烦。比如。使用“<”小于运算符比较“Zoo" 和“aardvark”，结果
刈t rue。
参照String.loca1Compare()方法来获取更多字符串比较的相关信息，String.
localCompare()方法更加健壮可靠，这个方法参照本地语言的字母表定义的字符次序。
对于那些不区分字母大小写的比较来说，则需要首先将宇符串较全部换为小写字母或者大
写字母，通过String.toLowerCase()和5tring.toUpperCase()做大小写的转换。
对于数字和字符串操作符来说，加号运算符利比较运算符的行为都有所不同，前者更偏
爱字符申，如果它的其中、个操作数足字符串的话，则进行学符串连接操作。而比较运
算符则更偏爱数宁，只有在两个操作数都是宁符串的时候，才会进行学符串的比较:
1! 加法.结果基3
字符中迹接，结果是"12"
/
!/ 字符串链接，2转矣为“2”,结果是"12"
11数字的比较，结果为fa1se
11字符中比较，结果为true
11数字的比较，“11"转换为11,结果为false
/ 数字的比较，"one“转换为NaN,结果为false
"one" < 3
最后，需要注意的是，“<=* (小于等于) 和“>=”(大于等于) 运算符在判断相等的
时候，并不依赖于相等运算符利严格相等运算符的比较规则。相反，小于等于运算符只
尽饰单的“不大干”，大于等于运算符也只是“不小子”。只有一个例外，那就是当其
一个操作数是(或者转换后是) NaN的时候，所有4个比较运算符均返回false。  

###  4.9.3 in运算符  

in运算符希望它的左操作数是一个字符书或可以转换为字符串，希望它的右换作数是一个
对象。如果右侧的对象拥有一个名为左操作数值的属性名: 那么表达式返回true,例如;
11定义一个对象
var point= {xi1j y:1};
/!=> true:对象有个名为“x”的属性
In point
in
/1=> false:对象中不存在名为“z"的属性
point
"toString" in point
11=> tue;对象继承「tostring()乃怯
var data= [7,B,9};
11拥有三个元类的数组
￥“.
HOU
"0" in data
// =?> true:数组包奔元索”0”
11=> true:数字转换为字符串
1in data
11=> false:役有索引为3的元或
3in data
4.9.4 instanceof 运算符
instanceof运算符希望左操作数是个对象，右操作数标识对象的类。如果左侧的对象
是右侧类的实例，则表达式返回true; 杏则返国fa1se。第9章将会讲到，JavaScript中对
象的类是通过初始化它们的构造晒数來定义的。这样的话，instanceof的右搡作数应当
是一个函数。比如:
ar d = new Date();
1通过Date()构追圃教亲创建一个新对象
/1计算结果为truer d是由Date()创建的
d instanceof Date;
instanceof bject; 11计算结果为tzue,所有的对象都是0ject的实例
d instanceof umber; 11北算结果为fa1se; d不匙个Number刘象
11通过数组直核盘的写祛创建一个数纰
var a = [1z 2s 9!;
/1计算结果为true,a是一个敷组
a instanceof Array;
;
a instanceof 0bject; 11计算结果为tue,所有的数组都尼对象
a instanceof RegExp; !1计算结果为fa1se,数组不尼正则长达式
需要注意的是，所有的对象都是0bject的实例。当通过instanceof判断--个对象是否
是一个类的实例的时候，这个判断也会包含对“父类”
(superciass) 的检测。如果
instanceof的左操作数不是对象的话。instanceof返回false。如果石i操作数不是函数,
则抛出一个类型错误异常。
为了理解instanceof运算符足如何工作的，必须首先理解“原型链”
(prototype
chain)。原型链作为JavaScript的继承机制，将在6 2.2节详细讲述。为了计算表达式o
instanceof f; JavaScript首先计算f.pxototype,然石在原型链中查找o,如果找到，那
么o是f (或者f的父类) 的一个实例; 农达式返口true。如果f.prototype不在o的原型链
中的话犀3，
那么o就不是f的实例，instanceof返回false。
译注3: 对象o中存在一个隐議的成员，这个成员指向其父类的原型，如果父类的原型是另外一个
类的尖创的话。则这个原塑对象中也存在一个隐我战弱指向另外-一个类的原型，这种链
条将许多对象或类串祧起来、既是点型链。原文所讲f.prolutypu不在o的原垄键中也就是
说f和o没有派生关系，变多细节谕参照6.2.2节。

##  [4.10 逻辑表达式](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

逻辑运算符“&&”、“| |" 利“!" 恳对操作数进行布尔算术运算，经常和关系运算符
一起配合使用，逻辑运算符将多个关系表达式组合起末组成-个史复杂的表达式。这些
运算符在下面几节中会一一讲述，为了更好地理解它们，应当首先回顾-下3.3节提到的
“真值”和“假值”的慨念。  

###  4.10.1逻辑与(&&)  

“&”运算符可以从二个不同的层次进行理解。墩简单的第一层理解是。当操作数都是
布尔值的时候，“&&" 对两个值执行布尔与(AND) 操作。只有在第一个操作数和第一个
操作数都是true的时候，它才返回true。如果共中个操作数是false,它返回false。
“&”常用来连接两个关系表达式;
x z 0 &8 y== 0 11只有在x和y都是0的时候。才返河true
关系表达式的运算结果总是为true或false,因此当这样使用的时候，“&”运算符术
身也返"true或false。关系运算符的优先级比“&* (和“I") 要商，因此类似这种
表达式可以放心地书写，而不用补充圆括号。
但是“”的操作数并不一定是布尔值，回想一下，有些值可以当做“真值”和“假
值”(鑫照3.3节，假值是false.nul1、undefined,0、-O、NaN和"'.所有其他的值
包括所有对象都忍真值)。对“&&”的第二层理解是，“&”可以对真值和假值进行布
尔与(AND) 操作。如果两个操作数都是真值，那么返回个真值; 否则，乡少个操作
数足假值的话，则返回个假值。在JavaScript中任何希望使用布尔值的地方，表达武利[
语句都会将其当做真俏或假值来对待，因此实际比“&&”并不总足返回true利false,但
也并无大碍。
省要往意的是，比文提到了运算符返回一个“真值”或者“假值”，但井役有说明这个
“真值”或者“假值”到底是什么值。为此，我们深人讨论对“&&”的第三层(也是最
后一层) 理解。运算符首先计算左操作数的值，即首先计算“&&”左侧的表达式。如果
计算结果是假位，那么整个表达式的结果一定也是假位，因此“&&" 这时简单地返回左
操作数的值，而并不会对右操作数逃行计算。
反过來讲，，如果左操作数是真值，那么整个表达式的结果则依赖于右操作数的值。如果
右操作数尼真值，那么整个表达式的值定恳真值; 如果右操作数尼假值，那么整个表
达式的值一定是假值。因此，当左操作数是真值时，
“&&" 运算符将计算右操作数的
值并将其返口作为整个表达式的计算结果:
表达式和运算符
|79

---
varo={x:1};
var P= rul1;
o & o.x
/! =>1;0 是其值，因此返回值为D.X
//=>nu1l: p是假宜，因此将其返回，而并不去计算P.X
& p.x
这对于理解“&&”可能不会去计算右操作数的情况至关重要，在上述示例代码中，变
量p的值是null,而如果计算表达式P.X的话则会抛出一个类型错误异常。但是示例代
码使用了“&&" 的一种符合语言习惯的用祛，因此只有在p为真值(不能是null或者
undefned) 的情况下才会训算P.X。
“8B”的行为有时称做“短路”(shot eircuiting),我们也会经常看到很多代码利用了
这一特性来有条佣地执行代码。例如，下面两行JavaScript代码是完全等价的:
if 臼== b) stop(); 11只有在a=-b的时候才绸用stop()
1/同上
a == b) 跟stop();
一般来讲，当“&&”右侧的表达式具有副作用的时候(赋值、递增、递减和函数调
用表达式) 要格外小心。因为这些带有副作用的表达式的执行依赖于左操作数的计算
结果。
尽管“&8”可以按照第二层和第三层的理解进行一些父杂表达式运算，犯大多数情况
下，“&" 仪用来对真值和假值做布尔计算。  

###  4.10.2 逻辑或(||)  

“I I”运箅符对两个操作数做布尔或(0R) 运算。如果其中一个或者两个操作数是真
值，它返回一个真值。如果两个操作数都是假值，它返回一个假值。
尽管“] ]”运算符大多数情况下只是做简单布尔或(OR) 运算，和“&”一样，它也具
有一些更复杂的行为。它会首先计算第一个操作数的值，也就是说会首先让算左侧的表
达式。如果计算结果为真值，那么返回这个真值。否则，再计算第二个操作数的值，即
计算右侧的表达式，并返回这个表达式的计算结果。
和“&&”运算符~样，同样向当避免右操作数包含。些具有副作用的表达式，除非你目
地明确地在右侧使用带副作用的表达式，而有可能不会计算右侧的表达式。
这个运算符最常用的方式是用来从、组备选表达式中选出第一个真值表达式:
1如果mx_vidth已经定义了，直接使用它: 否则在preferences对象中查找max_width
// 如果役有定义它。则使用一个写死的常章
var max = max_width ]I preferences.max_width Jl 500;
这种惯用法通常用在函数体内，用来绐参数提供默认值:
第4章
30|

---
11将o的成负属性复制到p中，并返网p
function copy(D,p) {.
p= p l1{}; 11如果向参数p投有传入任何对象，则使用=个新创建的对象
11函数体内的主逻辑  

###  4.10.3 逻辑非(!)  

“!”运算符是一元运算符。它放置在一个单独的操作数之前。它的日的是将操作数的布
尔值进行求反。例如，如果x是真值，则!x返!false; 如果x是假值，则!x返回true。
和“&&”与“| 1”运算符不同，“!”运算符首先将其操作数转换为布尔值(参照第3章
讲述的转换规则)，然后再对布尔值求反。也就是说“!”总是返回true或者false.并
且，可以通过使用两次逻辑非运算来得到一个值的等价布尔值: !!x (参照3.8.2节)
作为一个一元运算符，“!" 具有很高的优先级，并且和操作数紧密绑定在一起。如果
你希望对类似p & q的表达式做求反操作，则需要使用圆括号: !(p & q)。布尔计算的
更多原理性知识不必要做过多的解释,这里仅用JavaScript代码做简单说明:
11对于p利q取乐意值，这两个曾式都永远成立
!(p& q}=== !p :1Iq
!(p || q)=== !p & I
4.11赋值表达式
JavaScripu使用“=
运算符来给变量或者属性赋值。侧如:
1将变址i设置为0
//将对象0的属性x设咒为1
O.X 正1
"=* 运算符希望它的左操作数是一个左值:一个变量或者对象属性(或数组元素)
它的有操作数可以是任意类型的任意值。贼值表达式的值就是右操作数的值。赋值表达
式的副作用是; 右操作数的值减值给左侧的变盘或对象属性。这样的话，后续对这个变
量和对象属性的引用都将得到这个值。
尽管赋值表达式通常非常简单，但有时仍会看到一些复杂表达式包含贼值表达式的情
况。例如: 可以将赋值和检测操作放在一个表达式中,就像这样:
(a=b}==(
如果这样微的话，应当省楚地知道“=" 和“==" 运算符之问的区别! 需要注意的是，
表达式和运算符
81
---
1
---
“=* 具有非常低的优先级，通常在一个较长的表达式中用到了一条赋值语句的值的时
候，需要补充圆括号以保证正确的运算顺序。
赋值操作符的结合性是从右至左，也就尾说，如果一个表达式中出现了多个赋值运算
符，运算顺序是从右到左。因此，可以遁过如下的方式米对多个变曩赋值:
//把三个变盐初始化为
i=j=k=0 ;
带操作的赋值运算
除了常规的赋值运算“=”之外，JavaScrip还支持许多其他的赋值运算符，这些运算符
将赋值运算符和其他运算符连接起来,提供一种更为快捷的运算方式。例如，运算符
“+=”执行的是加法运算和赋值操作，下面的表达式;
total + sales_tax
和接下来的表达式是等价的:
total = total + sales_tax
运算符“+=" 可以作用于数字或字符串，如果其操作数是数字，它将执行加法运算和赋
值操作1如果操作数是字符串，它就执行宇符串连接操作和赋值操作。
这类运算符还包括“-=”、“*=”、“&=" 等。表4-2列出了这一类的所有运算符。
表4-2: 赋值运算符
等价子人个
运算符以(示例
a+=b
a=a+b
a=a-b
a- =b
-=
a *=b
a=a *b
*=
a=a/b
/=
a/=b
a=a%b
a%=b
%=
a=a<<b
a < <=b
<<=
a > >=b
a=a>>b
a>>>=b
a=a>>>b
a&=b
a=a&b
&=
|=
a=a |b
a |=b
a=a^b
a^=b
^=
82| 第4章

---
在大多数情况下，表达式为:
aop=b
这甲OP代表一个运算符，这个表达式和下面的表达式等价:
a啕op b
在第一行中，表达式a计算了。次，在第二行中，表达式a让算了两次。只有在a包含具有
副作用的表达式(比如函数调用和赋位操作) 的时候，两者才不等价。比如，下卣两个
表达式就不等价:
data[i++] *= 2;
data[i++].data[1+*] * 2;
4.12 表达式计算
和其他很多解释性语言一样,JavaScrip(同样可以解释运行出JavaScript源代码组成的字
符串，井产生一个值。JavaScript通过全屙函数eval()来完成这个工作:
l1=> 5
eva 1("3+2")
动态判断源代码中的字符串恳:种强大的语言特性，几乎没有必要在实际中应用。如果
你使用Jeval(); 你应当仔细考虑是占真的需要使用它。
下面讲解eva1()的基础用法，并且介绍严格使用它的两种方法，从代码优化的角度讲,
这两种方祛对于原有代码造成的影响是最小的。
eval()是一个函数还是一个运算符
eval()是一个函数，但由于它已经被当成运算符来对待了，因此将它放在本章耒讲
述。JavaScript语言的早期版本定义了eval()函数，从那时起、该语言的设计者和
解释器的作者对其实施了更多限制，使其看起来更像运算符。现代JavaScript解释
器进行了大量的代码分析和优化。而eval()的问题在于，用于动态执行的代码通常
来讲是不能分析。一般来讲，如果一个函数调用了eva1(),那么解释器将无法对这
个函数做进一步忧化。而将eva1()定义为函数的另一个问题是，它可以被轼予其他
的名宇:
var f = ev&l;
E，
vargwf
表达式和运算符| 83

---
如果允评这种情况的话，那么解释器将无法放心地优化任何调用g()的函数。而当
eval是一个运算符(并作为一个保留宇) 的时候，这种问题就可以避免掉。接下来
的4.12.2节和4.12.3节将会介绍如何对eval()实施更多的限制，以便让它的行为更
接近运算符。  

##  4.12.1 eval()  

eval()只有一个参数。如果传入的参数不足字符申，它直接返回这个参数。如果参数尽
字符申，它会把字符串当成JavaScript代码进行编译(parse) 伴在4，
如澩编译失败则抛
出~-个塔祛铧误(SyntaxError) 异常。如澩编译成功。则开始执行这段代码，开返叫字
符串中的最后一个表达式或语句的值，如果最后-个表达式或语句没有值，则最终返回
undefined。如果字符申抛出一个异常，这个异常将把该调用传递给eval()Fit.$。
关丁eval()最重要的是，它使用了调用它的变量作用域环境。也就是说，它查找变量的
值和定义新变量和函数的操作和局部作用域巾的代码完全一样。如果一个函数定义了一
个局部变量x，然后调用eva1("x"),它会返回局部变量的值。如果它调用eval("x=1"),
它会改变局部变量的值。如果函数调用了eval("var y= 3;")，它声明--个新的局部变
量y。同样地，一个函数可以通让如下代码芦明一个局部函数:
eval("function f(){ return x+1; }");
如果在最顶层代码巾调用eva](),当然，它会作用丁全局变量和全局函数。
-不能通过eval()往函数
需要往意的是，传递给eval()的字符串必须在语法上讲的通-
中任意粘贴代码片段，比如，eval("return;")是没有意义的,因为return只有任函数
中才起作用，并且事实上，eva1的字符串执行时的上下文环境和调用函数的上下文环境
是一样的，这不能使其作为函数的一部分米运行单注b。如果字符串作为一个单独的脚本
这里的原文是parse,意忠是“解折”这段宇符串,更精确地讲，应该是“编译”这段字
译 注 4 ;
符串，煽译不包括代码的执行。
原文有误、巳修改。
译注5:
译注6;
比如这段代码;
vaI foo= function(a){
eval(a) ;
};
foo("return;" );
按照原文的急恶，这段代码中执行eva1(a)的上下文是全局的，在全局上下文中使用
return会抛出语法错误;return not in function。
第4章

---
是有语义的(就像诸如x=o的短代码)，那么将其传递绐eva1()作参数是完全役有问题
的，否则，eval()将抛出语法错误异常详注7。  

###  4.12.2 全局eval()  

eva1()具有更改局部变量的能力，这对于JavaScript优化器来说是一个很人的问题。然
而作为一种权宜之计，JavaScript解释器针对那些调用「eval()的函数所做的优化并不
多。但当脚本定义了eval()的一个别名，且用另一个名称调用它，JavaScript解释器又会
如何T作呢? 为了让JavaScript獬释器的实现更加简化，ECMAScript 3标准规定了任何
解释器都不允许对eval()赋予别名。如果eva1()函数通过别名调用的话，则会抛出一个
EvalError异常。
实际上，大多数的实现并不是这么做的。当通过別名调用时，eval()会将其字符申当成
顶层的全局代码来执行。执行的代码可能会定义新的全局变盘和全局函数; 或考给余局
变盘斌值。但却不能使用或修改主调函数中的局部变量，因此，这不会影响到函数内的
代码优化。
当
ECMASeript 5是反对使用EvalError的,并且规范了eval() 的行为。“直接的eval"
直接使用非限定的“eval”名称(eval石起来像匙~个保留字) 来调用eval()函数时，通
常称为“直接eval”(direct eval)。直接调用eval()时，它总足在调用它的上下文作用
域内执行。共他的问接调用则使用全局对象作为共上下文作用域，并.且尤法读、写、定
义局部变录和幽数。下面有段示例代码:
1! 使用别名调用eval将是全局eval
var geval = eval;
/! 两个佥局变孟
var x= "global"，y= “global";
// 困数内执行的是局部eval
function f(] {
1定义局部变氩
vaI x = "local";
eval("x +'changed' ;") ;
直接eval更改了局部变盘的值
// 返回更改后的局郎变斌
return x;
'1这个函数内挑行了金局eval
funct ion 8(){
var y = "local";
'1定义局部变录
11闸接调用改变了全局变量的值
geval("y +='changed' ;");
/1返回术更改的局部变最
return y;
console.]0g(f(),x);
11更故了局部变氧: 输出"local changed global":
'1更改了全局变盈: 输出"local globalchanged":
console.log(g(); y) 
我们拉意到，全局eval的这些行为不仅仅是出丁代码优化器的需耍而做出的一种折中方
案，它实际上是一种非常有用的特性，它允许我们执行那些对上下文没有任何依赖的
译注7: 这里是指那些没有语义的代码片段通过evalQ}执行都会抛出语法错误异常。
表达式和运算苻| 85

---
全局脚本代码段。我们在本书开始处也提到，真正需要eval求执行代码段的场景并不多
见。但当你真的意识到它的必要性时，你更叮能会使用全局eval而不是局部eyal。
IB 9之前的早期版本IB和其他浏览器有所不同，当通过别名调用eva1()时并不尽全局
eval() (它也不会抛出一个Eva]Error异常，仅仅将其当做局部eva1来调用)。但IB的
确定义了一个彳叫execScript()的全局菌数来完成全局eval的功能(但和eval()稍有不
同，execScript ()总是会返回null)。
4.12.3 严格eval()
ECMAScript 5严格模式(参照5.7.3 书? 对eval()函数的行为施加了更多的限制，甚至对
标识符eva|的使用也施加了限制。当在严袼模式小调用eval()时,或者eva1()执行的代
码段以“use strict" 指令开始，这里的eval()是私有上卜文环境中的局部eval。也就是
说，在严格模式下,cval执行的代码段叮以查询或更改局部变量，但不能在局部作用域
中定义新的变氧或瓯数。
此外，严格模式将“eval”列为保留字，这让eval()更像，个运算符。不能用一个别彳
覆盖eval()函数。并且变虱名、的数名、困数参数或者异常捕获的参数都不能取彳为
“cval”。  

##  [4.13 其他运算符](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md#%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6)

JavaScript支持很多其他齐种务样的运算符，后续几节详细讨论它们:
4.13.1条件运算符(?:)
条科运算符是JavaScript中唯一的一个三元运算符(三个操作数)，有时直按称做“二元
运算符”。通常这个运算符写成“?:”，当然在代码中往往不会这么简写，因为这个运
算符拥有三个操作数，第一个操作数在“?”之前，第二个操作数在“?”和“:”之间，
第三个操作数在“:”之后,例如:
x > Q ? x :-X 11求x的绝对值
条件运算符的操作数可以是任意类型。第一个操作数当成布尔值，如果它是真值，那么
将计算第二个操作数，并返回具计算结果。不则，如果第一个操作数是假值，那么将计
算第三个操作数，并返回其计算结果。第二个和第三个操作数总是会讣算其中之一，不
可能两者同时执行。
其实使用if语句也会带来同样的效果(参照5.4.1节)，
“?:”运算符只是棍供了一种简
第4章
86

---
写形式。这里是一个“?:? 的典型应用场景，判断一个变量是否有定义(并拥有一个有
，单往8)，如果有定义则使用它，如果尤定义则使用~个默认值:
意义的真值
业品
"there") ;
greeting='hello" + (username ? usezname
这和下面使用if语句的代码是等价的,但显然上面的代码更加筛诘:
greeting " "hello";
if (username)
greeting += usezname;
else
greeting +="there";  

###  4.13.2 typeof运算符  

typeof是一元运算符，放在其单个操作数的前面，操作数可以恳任意类型。返回值为表
示操作数类型的一个字符串。农4-3列出丫任意值在typeof运算后的返回值:
表4-3: 任意值在typeof运算后的返回值
:.
typeof X
" undefined"
undefined
null
"object"
"boolean"
true或false
任 意数宁或NaN
"numbeI"
任意字符串
"string"
"function "
任意函数
"object"
任意内置对象(非函数)
由编译器各自实现的字符串,徂不是"undefined".
任意宿主对象
"boolean"、"number"或"string'
typeof最常用的用法是写在表达式中，就像这样;
(typeof value== "string")? u'u + value + u''; value
typeof运算符同样在sWitch语句(见5.4.3节) 中非常有用，需要往意的是，typeof运算
符可以带上圆括号，这让typeof看起来像一个函数名，而不是一个运算符关键宇:
typeof(i)
我们往意到，当操作数是nu11的时候，typeof将返回"object"。如果想将nu11和对象
译注8: 这里的场景其实不也括如采变量已经定义且值为false的情况。
表达式和运算符| 87

---
区分开，则必须针对特殊值显式检测。对于宿主对象来说，typeof有可能并不返
“objcct”，而返问字符串。但实际上客户端JavaScripl中的大多数宿半对象都是
“bject" 类型。
由于所有对象和数组的typeof运算结思是“bjec" T《是“funclion”.因此它对于
区分对象和其他原始值来说是很有帮助的。如果想区分对象的类，则需要使用其他的
手段，比如使用instanceof运算符(参照4.9.4节).class性(参照6.8.2节) 以及
constructor属性(参照6.8.1节和8 9.2.2节)。
尽管JavaScript中的闲教是对象的一种,俱typeof运筑符还是将闲数特殊对待，对函数
做typeof运算有着特殊的返回值。在JavaScript中,闲数和“可执行的对象”(callable
object) 有养微妙的区别。听有的闲数都是可执行的(callable); 但是对象也有可
能是可执行的，可以像调用函数一样调用它，但它并不是一个真正的函数。根据
ECMAScript 3规范，对于所有内馔可执行对象,typeof运算符一律返回“function”c
ECMAScript 5规范则扩允至所有可执行对象，包括内置对象(native bject) 和宥主对
象(host object)，所有可执行对象进行typeof运算都将返回“function"
大多数浏
览器[商也将JavaScript的原生凼数对象{nalive functiou object) 当成它们的宿乇对象
的方法来使用。但微软却~直将非原生叮执行对象(nor-native callable bject) 当成其
客户端的方法来使用，在IE 9之前的版本中、非原生叮执行对象的typeof运算将返回
“object”，尽管它们的行为和幽数非常相似。而在IB 9中.这些客户端方法是真正的内
置幽数对象(native functionobjec)。要了解真正的凼数利叮执行对象之间的详细差别请参
照8.7.7节。  

###  4.13.3 delete运算符  

de1ete足-。元操作符，它用来删除对象属性或者数组元素生。就像赋值、递增，递减运
算符。样，delete也是具有副作用的，它是用来做删除操作的，不是用来返回一个值的，
例如:
va[o口{x: 1; y: 2};
11定义一个对象
11删除一个展性
delete 0.X;
"x" in D
/1=> false;这个属性在对象中不再存在
11定义一个数组
var a= [1,2,3];
11删除最后一个数组元素
delete a[2] i
..
11=> false:元素2在数纰中已经小存在了
2ina;
和果你是C++程序员。请注恋JavaScript中的delete和C++中的delete是完全不同的。在
注1:
JavaScript中,内存的回收是通过拉圾困收自动回收的，你不用担心内存的显式释放问
题,这样则完全不用像C++那样通过delete来矧除整个对象。
第4章

---
alength
11=> 3:毖意，数组长度并没有改变，尽管上一行
代码删除了这个元素，仰删除操作留下了一个“河”、实际
上开没有修政数组的长度，因此a数组的长度仍然是3
需要往意的是，删除属性或者删除数组元素不仪仅是设置了一个undefined的值。当删除
一个属性时.这个属性将不再存在。读取一个不存在的属性将返回undefined.但是可以
通过in运算符(见4.9.3节) 来检测这个属性恳否在对象中存在。
de1ete希望他的操怍数是一个左值，如果它不是左值，那么delete将不进行任何操作同
时返lItrue。否则。delete将试图删除这个指定的左值。如果删除成功，delete将返回
true。然而并不是所有的属性都可删除，一些内置核心和客户端属性是不能例除的，用
户通过var语句声明的变意不能删除。同样，通过function语何定义的函数和函数参数也
不能删除。
在ECMAScript 5严格模式中，如果delete的操作数是非法的，比如变量，凼数或凼数参
数，delete操作将抛出:个语法锵误(SyntaxEror) 异常，只有操作数恳~个属性访闭
表达式(见4.4节) 的时猴它才会正常工作。在严格模式下，delete删除不叮配置的属性
(参照6.7节) 时会抛出一个类型铅误异常。在非严格模式下，这些de1ete操作都不会
报错，只是简单地返@false,以表明操作数不能执行删除操作。
这里有一些关于delete运算符的例子:
var 0 a {xX:1,y:z}; 11定义一个变母，初始化为对象
/1删除一个对象威性，返回true
delete Q.x;
项情1
11属性不存任，返回"undefined"
typeof Q,x;
//删除不存在的属性、返@true
delete o.x;
/!不能删除通过var声明的变盘，返回false
delete a;
/1在严格模式下，将抛出个异常
//参数不是一个左值，返@true
de1ete 1;
1!给全局对象定义--个属性。这里没有使用var
this.x= 1;
delete x;
//试!料删除它，在非严槲楔式下返回true
//在严格模式下会描凶异常。这附使用"delete this.x"来代替
/1运行时错误、役有定义x
6.3节还会布关于dclctc操作符的讨论。
###  4.13.4 void运算符
void是一元运算符，它出现在操作数之前，操作数叮以恳任意类型。这个运算符并不尽
经常使用;操作数会照常计算，但忽略计算结果并返回undefined。由于void会忽略搛作
数的俏; 因此在操作数具有副作用的时候使用void来让程序重具语义。
这个运算符最常用在客户端的URL---javascript:URL中,在URL中可以写带有副作用的
表达式和运算符
的9

---
表达式，而void则让浏览器不必显示这个表达式的计算结果。例如，经常在HTML代码
中的<a>标签里使用void运算符:
<a href="javascript :void window.open() ;">打开个新窗H <da>
道过给<a>的onclick绑定--个事件处理程序要比在href中写“javascript:URL" 要更加
请晰，当然，这样的话void操作符就可有可无了。
###  4.13.5 逗号运算符(,)
逗号运算符是二元运算符，它的操作数可以是任意类型。它首先计算左操作数，然后计
算右操作数，最后返回右操作数的值，看下面的示例代码;
i=0; j=1,k=2;
计算结果是2,它和下面的代码基本上是等价的:
i=0;j=1;k=2;
总是会计算左侧的表达式，但计算结果忽略掉，也就是说，只有左侧表达式具有副作
用，才会使用逗号运算符让代码变得更通顺。逗号运算符最常用的场景是在for循环中
(见5.5.3节)，这个for循环通常具有多个循环变录:
/'for错环中的第一个逗9 是var语句的一部分
/!第二个逗号是逗号运算符
11它将两个农达式(i+和j--) 放在一条(fox循环中的) 语句中
for(var i=0.j=10;i < j; i++;j--)
console.1og(i+j) ;
第4章
