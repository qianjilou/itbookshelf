## [第9章 类和模块](https://github.com/qianjilou/itbookshelf/tree/master/jsguide)  
###  9.1 类和原型  
###  9.2 类和构造函数  
###  9.3 JavaScript中Java式的类继承  
###  9.4 类的扩充  
###  9.5 类和类型  
###  9.6 JavaScript中的面向对象技术  
###  9.7 子类  
###  9.8 ECMAScript 5 中的类  
###  9.9 模块  
---
第9章
类和模块
笫6章详细介绍丁JavaScript对象，每个JavaScript对象都是一个属性集合，相互之间役
有任何联系。在JavaScript中也可以定义对象的类，让每个对象都共享某些属性，这种
“尖享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们
的状态。其中有些属性定义了它们的行为(通背称为方法)。这些行为通常是由类定义
的,而且为所有实例所共享。例如，假设有、个名为Complex的类用来表示复数，同时
还定义了一些复数运算。一个Complex实例应当包含复数的实部和虚部(状态)，同样
Complex类还会定义复数的加法和乘法操作(行为)。
在JavaScript中,类的实现是基于其原型继承机制的。如果两个实例都从同~个原型对象
上继承了属性，我们说它们是同一个类的实例。JavaScript原型和继承在6.1.3节和6.2.2节
中有详细讨论，为了更好地理解本章的内容，请务必首先阅读这两个章节。本章将会在
9.1节中对原型做进‘步讨论。
如果两个对象继承自同一个原型，往往意味羞(组不是绝对) 它们是由同个构造函数
创建并初始化的。我们已经在4.6节、6.2节和8.2.3节中详细讲解了构遣函数，9.2节会有
进一步讨论。
如果你对诸如Java和C++这种强类型中E的面向对象编茬比较熟悉，你会发现JavaScript
中的类和Java以及C++中的类有很大不同。尽管在写法上类似r.而且在JavaScript中也能
:洋生2; :但是最好要理解JavaScript的类和基于原型的继承
“模拟”出很多经典的类的特性
译注1:
强/弱类型是指类型裣查的严格程度，为所有变量指定数据类型称为“强类型”。
译注Z: 比如传统类的封装、继承和多态。
201

---
机制,以及和传统的Java (当然还有类似Java的语言) 的类和基于类的继承机制的不同
之处。93节展示了如f{在JavaScript中实现经典的类。
JavaScript中类的一个重要特性是“动态可继承”
(dynamically extendable)，9.4节详
细解释这一特性。我们可以将类看做是类型,9.5节讲解检测对象的类的几种方式，该节
向样介绍一种编程哲学
“鸭式辩型”[duck-typing)，它弱化了对象的类型，强化
了对象的功能。
在讨论了JavaScript中所有基本的面向对象编程特性之后，我们将关注点从抽象的概念转
向一些实例。9 .6节介绍两种非常重要的实现类的方法，包括很多实现面问对象的技术，
这些我术可以很大程度上增强类的功能。9.7节展示{包含很多示例代码) 如何实现类的
继承，包括如何在JavaScrjpt中实现类的继承。9.8节讲解如何使用ECMAScript s中的新
特性来实现类以及面向对象编程。
定义类是榄块开发和重用代码的有效方式之一，本章最后一节会集中讨论JavaScripl中的
模块。  

##  9.1 类和原型  

在JavaScript中,类的所有实例对象都从同一个原型对象上继承属性。因此，原犁对象是
类的核心。在例6-1中定义了inherit()函数，这个函数返回。个新创建的对象，后者继
承自某个原型对象。如果定义一个原型对象，然后通过inherit()函数创建一个继氏月它
的对象，这样就定义了一个JavaScript类。通常，类的实例还需要进--步的初始化，通常
是通过定义一个函数来创建并初始化这个新对象，参照例9-1.例9-1给一个表示“值的范
围”的类定义了原型对象，还定义了一个“工厂”函数术3用以创建并初始化类的实例。
例9-1:一个简单的JavaScript 类
/1range.js: 实现--个能表示值的范围的类
11这个工厂方法返回个新的“范围对象"
function zange(fzom; to)
/1使用inherit()函数来创建对象，这个对象维承自在下亚定义的原型对象
11原型对象作为函数的一个属性存储。并定义所有"恺圈对象”所共享的方法(行为)
var I 口inherit(xange.methods};
11存储新的“范围对象”的起始位歪和结束位置(状态)
11这两个属性是不可继承的，每个对象都批有峰一的属性
I.fIom= from;
z.to = to;
11返回这个新创建的对象
参 照:htp. //zh.wikjpedta.org 

!zh1工 厂方法。
译注3:
".. 一“，一一....
第9章
202

---
return I;
中此
1原型炒象定义力法，这些方法为每个范腻对象所继承
Iangc.mcthods = {
果x在范国内，则返阿true; 否则返网false
!I
xZHthe$
/1这个方法可以比较数字范囤，也可以比较字符串和日期范围
inckudes: function (x) {
return this.from <= x & x <= this.to 

; }
1! 对干范围内的每个整数都调用一次f
1这个方法只可用做数字范围
foreach: function (f) {
for (var x= Math.ceil(this.from); x < this.to 

; x++) f(x);
/返回表示这个范围的字符申
toString: function () {return "(" + this.from + “..." + this.to 

 +")";}
/1这里尾使用"范實对象”的一些例子
var r = xange(1,3);
/1侧建一个范用对象
r.inc1udes(2);
11=> true: 2 在这个范围内
I.foreach(console.log); 11蝓出12
11犏|[{ (1...3)
console.log(x);
在例9-1中有一些代码是没有用的。这段代码定义了一个工厂方祛range(),用来创建
新的范围对象。我们往意到，这里给range()函数定义了一-个属性range.methods,用以
快捷地存放定义类的原型对象。把原型对象挂在函数上役什么大不了，但也不是惯用
做法。冉者; 注意range()函数给每个范围对象都定义了from和to属性，用以定义范围
的起始位咒利结束位置,这两个属性是非共享的，当然也是不可继承的。最后，往意在
range.methods中定义的那些可尖享、可继承的方法都用到了from和to属性。而且使用了
this关键字，为了指代它们，二者使用this关键字来指代调用这个方法的对象。任何类
的方法都叮以通过this的这种基本用祛来读取对象的属性。
9.2 类和构造函数
例9-]展示了在JavaScripl中定义类的其中--种方法。但这种方法并不常用，毕竞它没有
定义构造函数，构造囱数是用来初始化新创建的对象的。8.2.3节已经讲到，使用关键
宁new来调用构造函数。使用new调用构造函数会自动创建一个新对象，因此构造凼数本
身只需初始化这个新对象的状态即可。调用构造函数的一个重要特征是，构造函数的
prototye属性被用做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继
承白一个相同的对象，因此它们都是向一个类的成员。例9-2对例9-1中的“范围类”敬
了修改,使用彬造函数代替工厂凼数:
类和模块

---
例9-2: 使用构造函数来定义“范围类”
1! rangez.js: 表示值的范围的类的另一种实现
!1这是一个构论函数，用以初始化新创建的“范圉对象"
/1比意，这里并没有创建并返回一个对象，仅仅是初始化
function Range(fro,to)
/1存储”范围对象”的起始位暨和结束位翌(状态)
1! 这两个属性是不可继承的，每个对象都拥有唯一的烤性
this.from = ftom;
this.to 

 口to;
11所行的”范围对象”都维承自这个对象
1往意。属性的名宁必须是"prototype'
Range.prototype= {
/! 如果x在范围内,则返回true; 否则返回false
/1这个方法可以比较数字抢围，也可以比较字符申和日期范围
includes: function (x){ return this.from <= x 跽x <= this.to 

; },
1/对于范围内的每个整数都谓用:次
11这个方法只可用于数宇范围
foreach: function (f) {
for (var x " Math.cell(th1s.fxom); x <= this.to 

; X++) f(x);
11返回表示这个范围的字符申
tostring: function () {return “(”+ this.from + "..." + this.to 

 + ")";}
}:
11这里悬使邢“范田对象”的一些例子
/1创建一个范围对象
var r = range(1.3);
1l => true: 2 在这个袍围内
T.includes(2);
r.foreach(console.1og) ;// 输出12 3
/1输出(1...3)
cnso1e.1cg(r);
将例9-1和例9-2中的代码做一个仟细的对比，可以发现两种定义类的技术的差别。首
先，往意当工厂函数range()转化为构造函数时被重俞名为Range()。这里遵循了个常
见的编程约定: 从某种意义上讲，定义构造函数既是定义类，并且类名首字母要大与。
而普通的函数和方法都是首字母小写。
再者,往意Range()构遣函数是通过new关键字调用的(在示例代码的末尾)，而range(}
工厂幽数则不必使用new。例9-1通过调用普通函数(见8.2.1书) 来创建新对象，例9-2则
使用构造函数调用(见8.2.3节) 来创建新对象。由于Range()构造函数是通过new关键字
调用的，因此不必调用inherit()或其他什么逻辑来创建新对象。在调用构造函数之前蒇
巳经创建了新对象,通过this关键字可以获取这个新对象。Range(}构造函数只不让是初
始化this而已。构造函数甚至不必返回这个新创建的对象，构遣函数会自动创建对象，
然后将构造函数作为这个对象的方法来调用一次，最后返问这个新对象。事实上，构遣
函数的命名规则(首字母大写) 和普通函数是如此不同还有另外一个原因，构造函数调
用和普通幽数调用是不尽相同的。构造函数就悬用来“构造新对象”的。它必须通过关
204[ 第9章

---
键字new调用、如果将构造函数用做普通函数的话，往往不会正常T作。开发者可以通过
丽
命名约定来(构造的数首宁母人大‘与，普通方祛肖字母小写) 判断是否应当在函数之前冠以
可啡
关键字mew。
例9-1和例9-2之间还有一个非常重要的区别，就尽原型对象的命名。在第~段示例代码
中的原型是range.methods。这种命名方式很方便同时具有很好的语义，但又过于随意。
在第二段示例代码中的原型是Range.prototype,这是。个强制的命名。对Range()构造
函数的调用会白动使用Range.prototype作为新Range对象的原型。
最后，需要注意在例9-1和例9-2中两种类定义方式的相同之处，两者的范围方法定义和
调用 方式是完全一样 的。  

###  9.2.1构造函数和类的标识  

上文提到，原型对象悬类的唯一标识: 当且仪当两个对象继承自同一个原型对象时，它
们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，两
个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实
例是属于向一个类的。
尽管构造函数不像原型那样基础，但构造凼数尽类的“外在表现”。很明显的,构造函
数的名宁通常用做类名。比如，我们说Range()构造晒数创建Range对象。然而，更根本
地讲,当使用instanceof运算符来检测对象足否属于某个类时会用到构造函数。假设这
里有一个对象r,我们想知道r是否是Range对象,我们这样写;
r instanceof Range 11如果r继承自Range.prototype,则返@true
实际kinstanceof运算符并你会检查r尾否尼由Range()构遣函数初始化而来,而会检查r
是千继承自Range.prototype。不过，instanceof的语祛则强化了“构造函数是类的公有
标识”的概念。在本章的后面还会碰到对instanceof运算符的介绍。
9.2.2 constructor属性
在例9-2中,将Range.prototype定义为一个新对象，这个对象包含类所需要的方法。
其实没有必要新创建一个对象，用单个对象直接量的属性就可以方便地定义原型上的
方法。任何JavaScripc函数都可以用做构遣函数，并且调用构造函数是需要用到一个
prototye属性的。因此; 每个JavaScript函数(ECMASeript 5中的Function.bind{)方法
返回的函数除外) 都自动拥有一个prototype属性。这个属性的值是一个对象.这个对象
包含唯一一个不可枚举属性constructor.constructor属性的值是一个函数对象:
var F " function() {};
1! 这起一个 函 数对 象
类和模块
205

---
/ 这恳F相关朕的原型对象
var P 中F-protatype;
11这悬与原型相关联的闲数
vaI c = p.constructor;
、E
c am F
'1=> true: 对于任意函数F.prototype.constructar==F
可以看到构选丽数的原型中存在预先定义好的constructor属性，这意味眷对象通常继
承的constructor均指代它们的构造闲数。由于构造函数是类的“公共标识”，因此这个
constructor属性为对象捉供了类。
!/创建类F的一个对象
vaI 0= new F();
:/1曰true,constructor屙性指代这个类
0.cOnstructor ===
如图9-1所示，图9-1展示了构遗丽数和原型对象之间的关系，创括原型到构造函数的反
间引[用以及构造闲数创建的实例。
原型
实例
构造函数
继承
E:nekange2 
..
fiduaes.xo
继承
Frey kangeci4t
......
".""
國9-1:构造函数及其原型和实例
需要往意的是，图9-1用Range()构造凼数作为示例，但灾际上; 例9-2中定义的Range类
使用它片身的一个新对象重写预定义的Range.prototype对象。这个新定义的原型对象不
含有constructor属性。丙此Range类的实例也不含有constructor属性。我们可以通过补
救措施来修正这个问题，显式给原型添加一个构造函数:
Range-pIototype= {
Range,// 显式设置构造函数反向引用
onstructor:
includes: function(x) {return this.from <= x & x <= this.to 

; }.
foreach: function(f)
for(var x = Hath,ceil(this.from); x <= this.to 

; x++} f(x);
toString: function(){ return "{" + this.from +"..." + this.to 

 + "}"; }
};
另一种常见的解决办法是使用预定义的原型对象,预定义的原型对象包含constructor
属性，然后依次给原型对象添加方法:
ll 扩展預定义的Range.prototype对象。而不重写之
/1这样就白动创建Range.pratotype.constructor属性
Range.pratatype,inc1udes = function (x) {return this.from <= x & x <= this.to 

;};
Range.pratotype.foreach = function
(f) {
for (var x= Math.cei1(this.fIom); x <= this.to 

; x++) f{x);
第9章
206

---
];
Range.prototype.tostring- function () {
return “{" + this.from + "..." + this.to 

 + ")";
oull
};  

##  9.3 JavaScript中Java式的类继承  

如果你有过Java或共他类似强类型面向对象语言的开发经历的话，在你的脑海中，类成
员的模样可能会足这个样子:
实例字殷
它们是基于实例的属性或变量，用以保存独立对象的状态。
实例方法
它们是类的所有实例所共享的方法.由每个独立的实例调用。
类字段
这些属性或变量是属于类的，而不是属于类的某个实例的。
类方迭
这些方去是属于类的，而不是属于类的某个实例的。
JavaScript和Java的一个不同之处在于，JavaScrjpt中的函数都是以值的形式出现的,方法
和字段之间并役有太大的区别。如果属性值是函数，那么这个属性就定义一个方法1否
则，它只是一个普通的属性或“字段”。尽管存在诸多差异，我们还是可以用JavaScript
模拟出Java中的这四种类成员类犁。JavaScript中的类牵扯三种不同的对象(参照
图9-1)，三种对象的属性的行为和下面三种类成员非常相似:
构造函数对象
之前提到，构造函数(对象) 为JavaScript的类定义了名宇。任何舔加到这个构遣
函数对象中的属性都是类字段和类方法(如果属性值是函数的话就是类方祛)。
原型对象
原型对象的属性被类的所有实例所继斥，如果原型对象的属性值是函数的话，这个
函数就作为类的实例的方祛来调用。
实例对象
类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例
对象所共享的。定义在实例上的非函数属性，实际上是实例的宇段。
在JavaScript中定义类的步骤可以缩减为一个分三步的算祛。第一步，先定义一个构造函
数，并设置初始化新对象的实例属性。第二步,给构造函数的prototype对象定义实例
类和模块
207

---
的方法。第三步.给构造函数定义类宇段和类属性。我们可以将这三个步骤封装进一个
简单的defineClass()甬数中(这里用到了例6-2中的extend()函数和例8-3中的改进版):
11一个用以定义简单类的瓯数
11用以设置实例的属性的函数
function defineClass(constructor,
/1实例的方法，复制至塬型中
methods,
11类属性，复制至构造函数中
statics)
if (methods) extend(constructor,prototype,methods);
1f (statics) extend(constructor,statics);
return constructpr;
/1这是Range类的另一个实现
var SimpleRange
defineClass(funct1on(f,t){ this.f = f; this.t = t; ]
inc1udes: function(x){ return this.f <= x & x < this.t;},
tostring: function(){ return this.f + "..." + this.t; }
upto: function(t}{ return new S1mpleRange(0; t);} });
例9-3中定义类的代码更长一些。这里定义了一个表示复数的类，这段代码胰示了如何使
用JavaScript米模拟实现Java式的类成员。例9-3中的代码没有用到上面的defineClass()
函数，而是“手动”来实现:
例9-3; Complex.js: 表示复数的类
Comp1ex.j s :
这个文件定义「Comp1ex类,H来猫述复数
回忆下，复数恳实数府应数的和。并且虚数i是一1的平方根
这个构造函数为它所创建的每个实例定义了尖例字段r和i
这两个宁段分别保存盆数的灾部和璩郎
它们是对象的状态
function Complex(real; imaginary)
1f (1sNaN(real) 111sNaN(imaginary}) 11确朵两个实参都是数字
11如果不都尼数字则抛出错识
throw new TypeError();
11复数的实部
this.I= real;
11复数的虚部
this.i = imaginary;
类的实侦方祛定义为原型对象的函数逍屦性
这里定义的方祛可以被所有实例继承、片为它们提供兵字的行为
需要往意的是，JavaScript的实例方祛必须使用关键字this
来存取实例的半段
第9章
208

---
/1当前复数对象加上另外..个贫數，并返回一个新的计算和值后的复数对象
complex.protatype.add = function (that)
部
有
return new Complex(this.I + that.I,this.i + that.i);
};
11当前复数乘以另外一个复数，并返回一个新的计算乘积之后的笪数对象
Complex.prototype.mul 兰function (that)
return new Camplex(this.r * that.r- this.i * that.1,this.r * that.i + this.i * that.r);
);
'1计算复数的模，复数的模定义为原点(0,o)到复平面的距离
Complex.prototype.mag= function (} {
retuzn Math.sqrt(this.r * this.r + this.1* this.i);
};
11复数的求负运算
Comp1ex.prototype.neg z function () {
return new complex(-thds.x,-thi5.I};
};
/1将复数对象转换为- 个字符申
Complex.prototype.tostring 。function () {
return"{"' +this.I +"," + this.i +"}";
};
11检测当前复数对象是否和另外一个复数值相等
Complex.prototype.equals= function (that} {
:Po+o4F
1必须有定义且不能是nu11
return that != nul1&
11并且必须是Comp1ex的实例
that.constructoru== Complex &
11并且必须包含相同的伉
this.I =on that.r & this.i xxt that.i;
};
类字段(比如常址) 和类方祛直接定义为构造函数的属性
需要往意的是。类的方法通常不使用关键字this;
它们只对其参数进行操作
11这里预定义了。些对复数运算有帮助的类字段
11它们的命名全都是大写，用以表明它们悬常女
/1(在ECMAStxipt 5中; 还能设避这些类字段的属性为只读)
Comp1ex.ZERO = new Complex(O,D);
Comp1ex.0NE = new Comp1ex(1,0};
Comp1ex.Iz new Cmplex{0,1};
11这个类方法将由实例对象的toString方祛返回的字符串格式解析为一个complex对象
l1或者抛出一个类型错误异常
Complex.parse= function (s) {
UOS
try{ // 假设解析成功
var m= comp1ex._format.exec(s); 11利用芷则表达式进行匹配
return new comp1ex(parseF1oat(m[1] ),parseFloat(m[2]));
catch(x){ 1! 如果解祈失败则抛出异常
throw new TypeError("Can't parse." + 5 +"' a5 a complex number.");
类和模块| 209

---
!I 定义类的“私有“字段。这个宇段在Comp1ex.parse()中用到了
/1下划线前级表明它是类内部使用的，而不属手类的公有API的部分
Comp1ex._foImat= /^\{([^,]+),([^}+)\}$/;
从例9-3中所定义的Complex类叮以看出，我们用到了构造函数、实例宁段、灾例方法.
类宇段和类方法，看一下这段示例代码;
/! 使用构造函数创鞑新的对象
Comp1ex(2,3);
var c = new
var d = new comp1ex(c.i,c.r); 11用到了c的实例画性
c.add(d}.toString();
1=>"{5,5}": 使用了实例的方祛
1这个稍微复杂的式达式用到了类方法和类字段
Complex.parse(c.toStr1ng()).11将c转换为字符申
11加上它的负数
add(c.neg()).
11结果应当永远尼"军"
equals(Comp1ex.ZER0)
尽管JavaScript可以模拟出Java式的类成员，但Java中有很多重要的特怍是尤法在
JavaScript类中模拟的。首先，对于Java类的实例方法来说，实例:宁段可以用做局部变
量,而不需要使用关键字this来引用它们。JavaScript足没办祛模拟，这个特性的，但叮以
使用with语句来近似地灾现这个功能(但这种做法并不推荐) :
complex.protatype.tostring = functi.an 

() {
with(this} {
return"{" + r + "." + i+"}";
};
任Java中可以使用final声明字段为常量，并且可以将字段和方祛声明为private,用以沾
示它们是私有成员且在类的外面是不可见的。在JavaScript中没有这些关键字。例9-3中
使用了一些命名写法上的约定来给出一些暗示，比如哪些成员是不能修改的(以大写字
母命名的命名)，哪些成员在类外部是不可见的(以下划线为前缀的命名)。关丁这两
个主题的讨论在本章后续还会碰到: 私有属性叮以使用闭包里的局部变氣来模拟(参照
9.6.6节) ，常量属性叮以在ECMAScript 5中直接实现(爹照9.8.2节)。
9.4 类的扩充
JavaScript中基于原型的继承机制是动态的: 对象从其原型继承属性，刘果创建对象之后
原型的属性发牛改变，也会影响到继承这个原型的所有实例对象。这意味着我们可以通
过给原型对象添加新方祛来扩充JavaScript类。这里我们给例9-3中的Comp1ex类添加方法
来计算复数的共矩复数
两个实邵相等，虚邴互为相反数的复黻互为共轭复数。
译注4;
第9章
210 f
---
!1返回当前复数的共轭复教
complex.prototype.conj= function(}{ return new complex(th15.T,-this.i}; };
前
JavaScript内置类的原犁对象也是一样如此“开放’
也就是说可以给数字、字符串、
数组，凼数等数据类型添加方法。在例8-5中我们曾给ECMAScript 3中的函数类添加了
bind()万法; 这个与法原来是役有的:
if (! Function.prototype.bind)
Function.prototype.bind= function(o /*,arg5 */) {
!1bind()方法的代码...
};
这里有些其他的例子:
11多次调用这个函数f,传人一个迭代数
11比如,要输出“hello"三次:
/1var n= 3;
11n.times(function(n){ console.1og(n +" hello"); });
Number.prototype.times- function(f,context) {
var n " Number(this};
fpr(var i= Q; i < n; i++) f.cal(context,i);
};
/1如果不存在E55的String.trin()方法的话，就定义它
11这个方法用以去除字符申开头和结尾的空格
String.pretotype.trim = String.prototype.trim l] function(} {
1空字符申不做处理
if {!this) return this;
return this.rep1ace(/^\s+|\s+$/g,"}; 11使用正则表达式进行空格眷换
};
11返回两数的名字，如果它有(非标谐的) name展性，则直接使Hname属性
1! 否则，将函数转换为字符串然后从中提取名牛
/1如果是没有名宁的函数，则返回一个空字符串
Function.pIototype.getName = function() {
return this,name ll this,toString().match(/function\s*([^()*]\(/)[1] ;
};
叮以给0bject.prototype添加方法，从而使所有的对象都叼] 以调用这些方法。但这种做
祛并不推荐，因为在ECMAScript 5之前，无法将这些新增的方法设置为不可枚举的，如
果給0bject.prototype添加属性; 这些属性恳叮以被for/in循环遍历到的。在9.8.1节中
会给出ECMASeript 5中的一个例子.其中悝用bject.defineProperty()方法可以安全地
扩充Dbject.pxototype。
然而并不是所有的宿主环境(比如Web浏览器} 都可以使用bject.defineProperty(),
这跟ECMAScript的具体实现有关。比如，在很多Web浏览器中，可以给HTMLElement,
prototype隊加方法，这样当前文档中表示HTML标记的所有对象就可以继斥这些方法。
但当前版本的1E则不支持这样做。这对客户端编程实用技术有着严玉的限制。
类和模块
211

---
##  9.5 类和类型  

回想-下第3章的内容，JavaScrip定义丁少盘的数据类型; null、undefined.布尔值、
数字、字符串、因数利对象。typeof运算符(见4.13.2节) 可以得出值的类型。然而，
我们往往更希望将类作为类型来对待,这样就可以根据对象所属的类来区分它们。
JavaScript语言核心巾的内置对象(通常是指宾户湍JavaScript的宿主对象) 可以根据它
们的class属性(见6.8.2节) 来区分彼此。比如在例6-4中用到了classof()函数。但当
我们使用本竞所提到的技术来定义类的话，实例对象的class属忪都是“Object”，这时
classof()函数也无用武之地。
接下来的几节介绍了三种用以检测任意对象的类的技术: instanceof运筑符，
constructor属性，以及构造的数的名字。但每种技术都不甚完美，本节总结讨论了鸭
式辩型，这种编程哲学更加关往对象可以完成什么工作(它包含什么方祛) 而不是对象
属于哪个类。  

###  9.5.1 instanceof运算符  

4.9.4节已经讨论过了instanceof运算符。左操作数是待检测其类的对象,右操作数是定
义类的构造函数。如果o继承自c.prototype,则表达武o instanceof c值为true。这里
的继承叮以不是直接继承，如果o所继承的对象继坻肖另一个对象，后一个对象继承自
c.prototype,这个表达式的运算结果也是true。
止如在本意前面所讲到的，构造囟数是类的公共标识，但原型是唯一的标识。尽管
instanceof运算符的右操作数是构遣幽数，但计算过程灾际上是检测了对象的继承关
系，面不是裣测创建对象的构造函数。
如果你想检侧对象的原型链上是否存在某个特定的原型对象，有没有不使用构遣闲数作
为中介的方法呢? 答案是肯定的，可以使用isPrototype0f()方法。比如，可以通过如
下代码来检测对象r是否是例9-1中定义的范围类的成员:
range.methods.isPIototype0f(r); //range.method 是原犁对象
instanceof运算符和isPrototype0f()方法的觖点是，我们无祛通过对象来获得类名。只
能检测对象是否属于指定的类名。在客户端JavaSeript中还有一个比较严重的不足，就是
在多窗口和多框架子页面的Web应用中兼容性不佳。每个窗口和框架子页面都具有单独
的执行上下文，每个k.下文都包含独有的全局变量和一组构造闲数。在两个不同框架页
血中创建的两个数组继爪自两个相同但相互独立的原型对象，其中一个框架页面中的数
组不是另一个稚架页面的Array()构造幽数的实例，instanceof运贷结果是false。
第9章
212 ]

---  

###  9.5.2 constructor属性  

PE
另:种识别对象是否属于某个类的方法是使用constructor属性。因为构造函数是类的公
叫6
地标识，所以最直接的方法就是使用constructor属性，比如;
function typeAndValue(x) {
if (x== nul1} return'""; 11Nul1和undefined 役有构造函数
switch(x.constructor)
1l 处理原始类型
ase Mumber; xeturn"lHurber: 。+ xj
case String: return"string;'" + x +"'";
l1处理内竖类型
case Date: return "Date: " +
case REgExp; teturn"Regexp;" t Xj
11处理自定义类犁
case Complex: return "Complex: " +x;
需要往意的是，在代码中关键字case后的表达式都是函数，如果政用typeof运算符或狄
取到对象的class属性的话，它们应当改为字符用。
使用constructor属性检喇对象属于某个类的技术的不足之处和instanceof一样。在多个
执行}上下文的场景中它是无法正常工作的(比如在浏览器窗口的多个框架子页面中)。在
个框架页面中的Alay构造
这种情况下.每个框架页面各自拥有独立的构造凶数集合,
凼数和另一个框架页面的Array构造函数不是同--个构造的数。
司榉，在JavaScript中也并非所有的对象都包含constructor属性。在每个新创建的函
数原型上默认会有constructor属性，但我们常常会忽觉原型上的constructor属性。比
如本章前面的示例代码中所定义的两个类(在例9-1和例9-2中)，它们的实例都没有
constructor属性。  

###  9.5.3 构造函数的名称  

使用instanceof运算符和constructor属性来检测对象所属的类有一个主要的问题，在
多个执行上下文巾存在构造函数的多个副本的时候，这两种方祛的捡测结果会出错。多
个执行H 下文中的函数看起来是一模一样的，他它们是相分独立的对象，因此彼此也不
相等。
一种叮能的解决方案是使用构造的数的名字1们不是构造困数本身作为类标识符。个窗
口里的Array构造函数和另一个窗日的Array构选函数是不相等的，仙是它们的名字是一
祥的。在一些JavaScript的实现巾为函数对象提供了一个非标准的属性name,用来表示函
数的名称。对丁那些没有name属性的JavaScript实现来说，可以将函数转换为字符用，然
后从中提取出函数名(在9.4 竹中的示例代码给Function光添加了getName()方法，.就是
使用这种方式求得到困数名)。
类和模块
|213

---
例9-4定义的type()函数以字符串的形式返回对象的类型。它用typeof运算符来处匣原始
值和函数。对于对象来说.它要么返回c1ass属性的值要么返回构造函数的名字。type()
函数用到了例6-4中的classof()函数和9.4节中的Function.getName()方法。为了简单起
见，这里包含了函数和方法的代码。
例9-4: 可以判断值的类型的bype0函数
j**
以宇符串形式返回o的类型:
-如果Q是nu11,返回"null"; 如果a是NaN,返国"nan”
-如果typeof所返四的值不是"object"，则返回这个值
{往意，有一些JavaScr1pt的实现将正则表达式识别为丽数)
如果o的类不是"0bject",则返回这个值
~如果a包含构造函数井且这个构遣函数其有名称，则返回这个名称
否测，一律返回"bject"
function type(% {
var t,C; n; 11type,class,name
11处理nu11值的特殊情形
f (o=== nul1l) retutn"nu1l";
11另外一种特殊情形: NaN和它自身不相等
if (o 1== 0 tetutn "nan" ;
11.如果typeof的值不是"oject"。则使用这个值
11这可以识别出原始值的类型和雨数
if {{t= typeof 0) !="bject") return t;
11返回对象的类名,除非慎为"Dbject"
这种方式可以识别出大家数的内罡对象
if {(c= classof(o)) !=="Dbject"} return c;
1如果对象构造函数的名字存在的话，则返回它
if {o.constructor 器typeof o,constructar a"function" &
n = o.constructor-getHame())) return n;
!! 其他的类型都无法判别，一律返回"0bject"
return"$bject";
/ 返回对象的类
function classof(} {
return 0bject.prototype.toString.call(o).slice(8,-1);
};
/1返回函数的名字(可能些空字符串)，不悬函数的话返回U11
Function.prototype.getName = function () {
if ("nane“in this) return this.name 

;
return this.name 

 = this.tostring().match(/function\s*( [^{]*)\(/)[1];
};
这种使用构造函数名字来识别对象的樊的做法和使用constructor属性一样有一个问
第9幸
214 |

---
题: 并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。
确“
如果使用不带名字的函数定义表达式毕往5定义一个构造函数，getName()方法则会返回空
DF
字符串:
1这个构造函数没有名宁
var Comp1ex " function(x,y){ this.x = x; this.i= y; }
11这个构造函数有名字
var Range= function Range(f,t){ this.fzom " f; this.to 

 口t; }  
 
###  9.5.4 鸭式辩型  

上文所描述的检铡对象的类的各种技术多少都会有些问题，至少在客户端JavaScript中悬
如此。解决办祛就是规避掉这些问题: 不要关注“对象的类是什么”，而是关往“对象
能做什么”。这种思考问题的方式在Python和Ruby中非常普遍，称为“鸭式辩型”(这
个表述是由作家James Whitcomb Riley 提出的)。
像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子。
对于JavaScript程序员来说，这句话可以理解为“如果一个对象叮以像鸭子一样走路、游泳
并且嘎嘎叫，就认为这个对象是鸭子，哪怕它并不是从鸭子类的原型对象继承而米的”。
我们拿例9-2中的Range类来举例好了。起初定义这个类用以描述数字的范围。但要注
意，Range()构造咽数并役有对实参进行类型检查以确保实参是数字类型。但却将参数
使用“>”运算符进行比较运算，因为这里假定它们是可比较的。同样，inc1udes()方
法使用“<=”运算符进行比较，但没有对范關的结束点进行类似的假设。因为类井役有
强制使用特定的类型，它的in1cudes()方法可以作用于任何结束点，只要结束点可以用
关系运算符执行比较运算。
var 1owercase = new Range("a","z");
var thisYear= new Range(new Date(2009,0,1); new Date(2010; 0,1));
Range类的foreach()方法巾也没有显式地检测表示范围的结束点的类型，但Math.ceil()
和“++”运算符表明它只能对数字结束点进行操作。
另外一个例子，「I想一下在7.11节中所讨论的类数组对象。在很多场景下，我们并不知
道一个对象是否真的是Array的实例，当然是可以通过判断是否包含非负的1ength属性
来得知是否是Array的实例。我们说“包含一个值是非负整数的lenglh”是数组的一个恃
征一“会走路”，任何具有“会走路”这个特征的对象都可以当做数组来对待(在很
多悄形中)，
详注5: 参照4.3节。
类和模块
215

---
然而必须要了解的是，真正数组的1ength属性有一些独有的行为: 当添加新的元素时，
数组的长度会自动更新，并且当给1ength属性设置一个更小的整数时，数组会被自动截
断。我们说这些特征是“会游泳”和“嘎嘎叫”。如果所实现的代码需要“会游泳”H.
能“嘎嘎叫”，则不能使用只“会走路”的类似数组的对象。
k文所讲到的鸭式辩型的例了提到了进行对象的“<”运算符的职责以及1ength属性
的特殊行为。但当我们提到鸭式辩型时,往往是说检测对象是否实现了一个或多个方
法。一个强类型的triathlon()函数所需要的参数必须是TriAthlete对象。而一种“鸭
式辩型”式的做法是，只要对象包含wa1k()、swim()和bike()这三个方祛就叮以作为
参数传人。同理，可以重新设计Range类,使用结束点对象的compareTo()和succ()
(succesor) 方法来代替“<”和“t+”运算符。
鸭式辩型的实现方法让人感觉太“放任自流”:仅仅是假设输人对象实现了必要的方
法，根木没有执行进一步的检查。如果输入对象没有遵循“假设”
那么当代码试图调
用那些不存在的方法时就会报错。另一种实现方法是对输人对象进行检查。但不是检查
它们的类，而是用适当的名字来检查它们所实现的方法。这样可以将非迭输入尽可能早
地拦截在外,并可给出带有更多提示信息的报错。
例9-5中按照鸭式辩犁的理念定义了quacks()函数(函数名叫“implements" 会更加合
适，但implements是保留字)。quacks()用以检查~个对象(第--个灾参) 悬否实现」「
剩下的参数所表示的万法。对于除第一个参数外的每个参数，如果恳字符串的话则直接
检查是否存在以它命名的方法1如果是对象的话则检查第一个对象中的方法是否在这个
对象中也具有同名的方法; 如果参数是函数，则假定它是构造函数。函数将检查第一个
对象实现的方法是否在构造函数的原犁对象中也具有同名的方法。
例9-5: 利用鸭式辫型实现的函数
11如果o实现了除第.个参数之外的参数所戏示的方祛，则返网true
functlon quacks(o /*,...*/) 1
for (var i= 1; i< arguments.length; i++}{ 11逭历o之后的所有参数
var arg = argunents[4] ;
ll 如果参数是:
switch (typeof arg) t
11string: 瓦拨用名字做检弃
case'string' :
1f (typeof o[arg] {nn"function") return false;
continue;
11function; 检查函数的原型对象上的方法
case'function' :
/1如果实参悬幽数,则使用它的原梨
arg= arg.pratotype; 11进入下一个case
l1abject: 检查匹配的方祛
case *abject' ;
for (var m in arg){ 11遍历对象的每个属性
if (typeof arg[m] l=="functian") continue; 11跳过不是方祛的属性
(typeof o[m] l=="function") retuzn false;
216] 第9章

---
/1如果柽序能执行到这里，说呗o实现了所有的方法
前
return true;
关于这个quacks()函数还有一些地方是需要尤为往意的。首先，这里只是通过特定的名
称来检测对象是否含有一个或多个值为函数的属性。我们无法得知这些已经存在的属性
的细节信息，比如，函数是十什么用的? 它们需要多少参数? 参数类型是什么? 然而这
是鸭式辩型的本质所在，如果使用鸭式辩型而不是强制的类型检测的方式定义API,那
么创建的API应当更具灵括性才可以，这样才能确保你提供给用户的API更加安全可靠。
关于quacks()凼数还有另--问题需要往意，就是它不能应用于内置类。比如，不能通过
quacks(o,Array)来检测|o是否实现「Array中所有同名的方法。原因是内登类的方法都是
不可枚举的，quacks()巾的for/in循环无祛遍历到它们(往意，在BCMAScript 仲有一
个补救办祛，就是使用0jbect.getOwnPropertyNames())。
9.6 JavaScript中的面向对象技术
到目前为止，我们讨论了JavaS$cript中类的基础知识; 原型对象的重要性、它和构造函数
之间的联系.instanceof运算符如何工作等。本节将目光转向一些实际的例子(尽管这
不是基础知识)，包括如何利用JavaScripl中的类进行编程。我们从两个取要的例f开
始，这两个例子中实现的类非常有意思，接下来的讨论都将基于此作展开。  

###  9.6.1 一个例子: 集合类  

集合{set) 是一种数据结构,用以表示非重复值的无序集合。檠合的基础方祛包括添加
值、检侧值是否在集合中，这种集合需要一种通用的实现，以保证操作效率。JavaScript
的对象是属性名以及与之对应的值的基本集合。因此将对象只用做字符串的集合是人材
小用。例子9-6用JavaScript实现了~个重加通用的Set类，它灾现了从JavaScript值到唯一
字符串的映射。然后将宇符串用做属性名。对象和函数都不具备如此简明可靠的唯一字
符串表示。因此集合类必须给集合中的每个对象或的数定义一个唯一的属性标识。
例9-6: Set.js: 值的任意集合
11这是一个构造的数
functlon Set() {
11集合数据保存在对象的斌性里
this.values= {};
this.n= 0;
11集企中值的个数
this.add.appIy(this,aguments); 1l 把所有参数都舔加进这个集合
1l 将每个参数都舔扪垒集合中
Set.prototype.add= function {) {
!1迫历每个黎数
(var i= 0; i < arguments.length; i+*) {
/! 待術加剑集合中的值
var va1= arguments [1};
类和模块| 217

---
11把它转换为字符申
var str = Set._v25(val);
/! 如果不在集合中
if {!this.values.hasOwnProperty(str}) {
this.va1ues[str]= val;
11将字符串和伉对应起来
this.n++;
11集合中值的计数加-
/1支持缝式方祛调用
return this;
};
!! 从集合删除元案,这些元素由参数捐定
Set.prototype.remove = functian (} {
// 遍厉每个蠡数
for (vaI i= 0; i 《argunents.length; 1++) {
vaI stx = 5et._vzs(arguments[i]);
11将宁符串和值对应起来
/! 如果它在巢斧中
lf (this,values.hasOunProperty(str)) {
delete this.values[str];
11删除它
//集合中值的计数猿一
this. n-- ;
return this; 11支持链式方祛调用
};
11如果集合包含这个值，则返回true; 否则，返回false
set.prototype.contains: = function (vaLue)
return this. val ue s.has0wnProperty (Set. _v2s( val ue)} ;
11返回集合的大小
Set.prototype.size= function () {
return this.n;
};
11遍历集分中的所有元素，在指定的上卜文中调用f
Set.prototype.foreach= function (f,context) {
11遍历乘合中的所有字符申
for (vaI 5 in this.values}
忽略继承的爬性
if (thi 5. values
ha sOwn F roperty( s )}
f.call(context,this.values[$]};
11调用f,传人value
};
/1这是一个内部函数，用以将任意JavaScript值和唯一的字符串对应起来
Set._v2s = function (val) {
switch (val) {
11待殊的原始伉
case undefined :
return 'n';
1/植只有一个半母
case nul1:
'/ 代码
retuIn
case true:
return
case false:
os i+." c
defau1t; switch (typeof val) {
!1数字都带有# 前竣
case'number'; return'#' + val;
!1半符串都带有“前缀
case'string' :return '' + val;
defau1t; return'@' + objectId{val); /! 0bjs and funcs get @
11对任意对象来说，都会返回一个字符申
11针对不同的对象，这个函数会返回不同的半符串
11对于同一个对象的多次调用。总是返网相同的字符串
11为了做到这一点，它给0创迷了一个属性，在ES5中，这个属性是不可枚举且是只读的
218 |
第9章

---
function objectId(o)
var prop一" I**bjectid**l"; 1/私有属性，H以存放id
的
(la.has0wnPropexty(prop)) 11如果对象役有id
Q
o[prop] " Set._v2s.next++; //将下一个值赋给它
/1返回这个id
return o[prop] ;
};
Set._v2s.next= 100; 1! 设置初始d的值  

###  9.6.2一个例子:枚举类型  

枚半类型(enumerated type) 是。种类型，它是值的有限集合，如聚值定义为这个
类型则该值是可列出{ (或“可枚举”)的。在C及其派生谮言中，枚举类梨是通过关
键宇enum声明的。Enum是ECMAScript 5中的保留学(还未使用)，很有可能在将来
JavaScript就会内置支持枚举类型。到那时，例9-7展示了如何在JavaScript中定义枚举类
型的数据。需要注意的是，这里用到了例6-1小的inherit()函数。
例9-7包含一个单独函数enumeration()。但它不是构造函数，它并没有定义一个名叫
"enumeration" 的类。相反，它是一个工厂方法，每次调用它都会创建并返四一个新的
类，比如:
11使用4个值创建新的Coin类; Coin,Penny,Coin,Nickel等
var Coin = enumeratson({Penny: 1,Ndckel:5; Dime:10,Quarter;25});
这是新类的实例
var C = cain.Dime;
11=> true; instanceof亚常工作
[ instanceof Coin
11=> true: 构造的教的属性正常工作
c.constructor 四Coin
Cain.Quarter + 3*Coin.Nickel
40: 将值转换劣数字
!/=> true; 更多转换为数字的例了
Coin.Dime== 10
11=> true; 关系运算符正常工作
Coin.Dime ? Coln.NIckel
String(Coin.Dime) +":" t Coin.Dime 11=>"Dime:10"; 强制转换为字符申
这个例子猜楚地展示了JavaScrip类的灵活性，JavaScript的类要比C++和Java语言中的静
态类要更加灵括。
例9-7: JavaScript中的枚举类型
/1这个函数创建-个新的枚举类型，实参对象表示类的每个实例的名半和值
!! 返回值是一个构造函数.它标只这个新类
1口
11注意.这个构造丽数也会抛出异常: 不能使用它来创建该类型的新实例
1l 返回的构造函数包含名/值对的映射表
11包括出值组成的数组，以及一个foreach()迭代器函数
function enumeration(namesToVa1ues) {
11这个虑拟的构遣函数是返问值
var enumeration = functian (){ thzow “Can't Instantiate Enuseratians"; };
/1枚举值绯承自这个对象
vaI pzoto = enuneration.prototype = {
11标识类型
constructor: enumeration,
类和模块| 219

---
tostring; function (){ return this.name 

; }，
11返回名字
va1ue0f: function () .
11返问殖
return this.value; };
// 转换为]S0N
to]SQN: function (){ return this.name 

;
};
enumeration.values = []; !1用以存放枚举对象的数组
l1现在创建新类型的奕例
11遍历每个值
for (name 3n namesToValues) {
var e= inherit(proto);
11创建一个代表它的对象
e.name 

 = name;
'! 给它一个名字
11给它一个值
e.value = namesToValues[name] ;
11将它设登为构造函数的属性
enumertion[name]= B;
/1将它存储到值数组中
en um e ation. 妇 lues.p u sh( e) ;
11一个类方法，用来对类的实例进行迭代
enumeration.foreach = function (f,c) {
for (var i = 0; i < this.values.length; i++) f.call(C,this.values[i] );
};
11返回标识这个新类犁的构遗函数
retuIn enumeration;
如果用这个枚举类型束实现“个“he1lo world”小程序的话,就可以使用枚举类型来表
示一副扑克牌。例9-8中使用enuneration()函数实现了这个表示一副扑克牌的类诈1。
例9-8: 使用枚举类型来表示一副扑克牌
1! 定 义一 个 表 示” 玩 牌”的类
function Card(suit,rank){
i1雒张牌都有花色
this.suit = suit;
this,rank
11以及点数
= rank;
/1使用枚举类型定义花色和点数
Card.Suit = enumeration({C]ubs: 1,Dlamonds; 2; Hearts: 3,Spades: 4});
Card.Rank = enumeration({Twc: 2; Three: 了。Four: 4,Five: 5,Six: 6;
，Ten; 1C
Seven: 7; Eight: 8,Nine;
ack: 11,Queen: 12,King: 13,Ace: 14});
11定义用以描述牌面的文本
Card.prototype.ta5tring= function ()
return th1s.rank.toString() +" of" + this.suit.toString();
11比较扑克牌中两张牌的大小
Card.pratatype.compareTo = function {that)
if (this.rank < that.rank) return-1;
If (thIs.rank > that.rank) return 1;
return C
这个例子的作者足Joshua Blocb,最初是基于Jay8写的，可以在这里蚩看到: http:l/icp.
注1:
org/aboutJava/commaniyprocessjsrger/enum.hml.
220| 第9章
---
11以扑克牌的玩法规则对牌进行排庄的函数
Card.orderByRank = function (a,b){ return a.compareTo(b); };
11以桥牌的玩法规则对扑牌进行排序的函叛
Card.orderBySuit= function (a,b) {
:f (a.suit < b,sudt) return-1;
f (a,suit > b.suit) return 1;
1f (a.rank < b.rank) return-1j
t{
fotutn
h.onh\
if (a.rank > b.rank) return 1
return 0
ll 定义用以表示一副标准扑兑牌的类
function Deck() {
11一剡牌就是由牌组成的数组
var cards= this.cards= [];
Card.Suit.foreach(function (s}
/1初始化这个数组
Card.Rank.foreach(function (r) {
cards.push(new card(s,r));
});
}};
11洗牌的方祛: 重新洗牌井返回冼好的牌
Deck.prototype.shufAle = function () .
i'l 遍历数组中的每个元彩，随机找出牌面最小的元素，并与之(当前邀历的元素) 交换
var
deck = this.cards; len= deck.length;
for(vari=len- 1; i>D; i--}{
if 随机数
var I= Math.flor(Math.random() * (i + 1)); temp;
l1交换
temp= deck[i]= deck[i] = deck[r],deck[t] 四temp;
return this ;
};
11发牌的方迭: 返回牌的数组
Deck.protatype.dea1= fumction (n) 、
if (this.cards.length < n) throw"0ut of tards";
return this.cards.splice(this,cards,length- n,n);
};
'I 创建副新扑兑牌，洗牌并发牌
var deck 口(neN Deck()).shufe();
var hand= deck.deal(13).sort(Card.ozder8ySuit);  

###  9.6.3 标准转换方法  

3.8.3和6.10节讨论了对象类型转换所用到的重要方法，有一些方法是在需要做类型转换
时由JavaScript解释器自动调用的。不需要为定义的每个类都实现这些方法，但这些方祛
的确非常重要，如果役有为自定义的类实现这些方祛，也应当是有意为之，而不应当因
为疏忽而漏掉了它们。
最重要的方祛首当toString{)。这个方法的作用是返回一个可以表示这个对象的宇符
类和模块| 221

---
串。在希望使用宁符串的地方用到对象的话(比如将对象用做属性名或使用“+”运算
符来进行宁符串连接运赏》，JavaScript会自动调用这个方法。如果役有实现这个方祛，
类会默认从0bject.prototype中继承to5tring()方让，这个方祛的运算结果是“[object
0bjecr]”，这个字符串用处不大。toString()方祛应当返问一个可读的字符串，这样最
终用户才能将这个输出值利用起来，然而有时候并不定非要如此，不管怎样，可以返
P[可读字符串的toString()方法也会让程序调试变得更加轻松。例9-2和例9-3中的Range
类和Complex类都定义了toString()方法,例9-7中的枚举类型也定义J'to5tring()。下
面我们会给例9-6中的Sel类也定义toString()方法，
tolocaleString()和tostring()极为类似: toLocaleString()是以本地敏感性
(locale-sensitive) 的方式来将对象转换为字符串。默认情况下，对象所继承的
toloca1eString()方法只是简单地调用toString()方法。有一些内置类型包含有用的
toLocaleString()方法用以实际上返回本地化相关的宇符串。如果需要为对象到字符串
的转换定义toString()方法，那么同样需要定义toLocaleString()方法用以处理本地化
的对象到宇符串的转换。下面的Set类的定义中会有彬关代码。
第三个方法是value0f()，它用来将对象转换为原始值。比如，当数学运算符(除了“+"
运算符) 和关系运算符作用于数字文本表示的对象时，会自动调用va1ue0f()方让。大多
数对象都没有合适的原始值来表示它们，也没有定义这个方法。但在例9-7中的枚举类犁
的实现则说明va1ue0f()方法是非常重要的。
第四个方祛悬toJSON(),这个方祛是由JSON.stringify()自动调用的。JSON格式用于序
列化良好的数据结构，而且可以处理JavaScript原始值、数组和纯对象。它和类无关,
当对一个对象执行序列化操作时，它会忽略对象的原型和构遣函数。比如将Range对
象或Complex对象作为参数传人]SON.stringify(),将会返冈诸如{"form":1,"to":3}
或{"r":1,"i":-1}这种宁符串。如果将这些字符串传人JS0N.parse(),则会得到个
和Range对象和Complex对象具有相同属性的纯对象,但这个对象不会包含从Range和
Complex继承来的方法。
这种序列化操作非常适用于诸如Range和Complex这种类，但对于其他一些类则必须自
定义to]SON()方法来定制个性化的序列化格式。如果一个对象有toJS0N()方法，JSON.
stringify()并不会对传人的对象做序列化操作，而会调用toJSON()来执行序列化操
乍(序列化的值可能是谅始值也可能是对象)。比如，Date对象的toJS0N()方法可以
返回一个表示日期的学符串。例9-7中的枚举类型也是如此: 它们的toJSON()方法和
toString()方祛完全-样。如果要榄拟一个集合，最接近JSON的表示方法就是数组，因
此在下面的例子中将定义t0J50N()方法用以将集合对象转换为值数组。
例9-6中的Set类并没有定义卜.述方法中的任何一个。JavaScript中没有哪个原始值
-一---一
222! 第9章

---
可以表示集合，因此也没必要定义value0f()方法。但该类应当包含toString().
toLocaleString()和to]SQN()方法。可以用如F代码来实现。往意extend()函数
叫
(例56-2) 的用法，这里使用extend()来向Set.prototype来忝加方祛;
11将这些方祛忝加至Set类的頃型对象巾
extend(Set.prototype,{
w@ts
11物集合转换为字符串
to5tring: function () {
vaI s ="{"}
i=0
this.foreach(function (v) {s += ((It>0) ?"，" :"P) + v; });
return s +"}";
类似tostring,何是对十所有的侑都将调用toLocalestring()
talocaleString: function () {
var S = "{";i = 0;
this.foreach(function (v}
if (i++>0} s +="
if (v== null} s += v; 1l null 和undefined
else 5 += v.toLocale5tring{); 11其他情祝
return s +
将乘合转搀为侑数组
toArray: function () {
this.foreach(function (v){ a.push(v); });
return a;
});
/1对于要从J50N转换为半符串的集含都被当做数组来对待
Set.prototype.toJS0N= Set.prototype.toAlay;  

###  9.6.4 比较方法  

JavaScript的相等运算符比较对象时，比较的恳引用而不是值。也就是说，给定两个对象
引i用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名
和相同的属性值，而是直接比较这两个单独的对象是否相等，或者比较它们的顺序(就
像“<”和“>”运算符进行的比较一样)。如果定义一个类，并且希望比较类的实例。
应该定义合适的方祛来执行比较操作。
Java编程语言有很多用于对象比较的方法，将Java中的这些方法惜用钊JavaSeripl中恳
个不错的主意。为了能让自定义类的实例具备比较的功能，定义:个名叫equa1s()实例
方法。这个方法只能接收一个尖参，如果这个实参和调用此方法的对象相等的话则返回
true。当然，这里所说的“相等”的含义是根据类的上下文来决定的。对丁简单的类，
可以通过简单地比较它们的constructor臧性来确保两个对象是相同类型，然片比较两
类和模块
223

---
个对象的实例属性以保证它们的值相等。例9-3F的Complex类就实现了这祥的equals()
方祛。我们可以轻易地为Range类也实现类似的方法:
!! Range类重写它的constructor属性，现在将它派加进去
Range.prototype.constructor = Range;
11一个Range对象和其他不恳Range的对象均不相等
11当且仅当两个范用的端点相等，它们才相等
Range.prototype.equals = function(that} {
1处埋nu1l 和undeined
if (that = nu1l) return false;
'1处理非Range对象
if (that.constructor !== Range) return false;
11当且仪当两个端点相等，
片返问true
return this.from == that.from 跛this.to 

 =.that.to 

;
给Set类定义equals()方祛法稍微有些复杂。不能简单地比较两个集合的values属性，还要
进行更深层次的比较:
Set.prototype.equa1s= function (that) {
11一些次要情况的快捷处理
if (this xxx that) retuzn true;
I! 如果that对象不恳个集合; 它和this不相等
11我们川甸「instanceof,使得这个方祛可以用于St的任何了类
11如果希望来用鸭式辫型的方祛，可以降低检查的严旃型度
! 或者叮以通过this.constructor == that.constructor 米加强检查的严格程度
十
/1往意，nu11和undefined两个省是无法]川于instanceof运算的
if (l (that Instanceof Set)} retuzn false;
11如果两个集合的大小不。样，则它们不相等
if (this.size() I= that.size()) return false;
/ 现在检花两个集合中的元素悬否完全一样
/ 如果两个集合不相等，则通过抛出异常来终止foreach循环
try
this.foreach(function (v){ if (!that.contains(v)} throm :false; });
11所有的元素都匹配; 两个集合相等
return true;
}catch(x).
if ix=== false} return false; 11如果集合中有元素在另外-个集合中不存在
11垂新抛出异常
throw >
按照我们需要的方式比较对象是否和等常常恳很有用的。对于某些类来说，往往需耍比
较一个实例“大于”或者“小干”另外一个示例。比如,你可能会垄于Range对象的下
边界束定义实例的大小关系。枚举类型可以根据名字的字母表顺序来定义实例的大小，
也可以根攒它包含的数值(假設它包含的都是数字) 来定义大小。另一方面，Set对象其
灾足无祛排序的。
如果将对象用TJavaScript的关系比较运算符，比如“<”和“<=”，JavaScript会首先调
224{ 第9章

---
用对象的value0f()方法，如果这个万法返回一个原始值; 则直接比较原始值。例9-7中
由enumeration()方法所返回的枚举类型创含value0f()方法,因此叮以使用关系运算符
对它们做有意义的比较。仙大多数类并没有value0f()方法，为了按照显式定义的规则
来比较这些类犁的对象，可以定义一个名叫compareTo()的方祛(同样.这里遵照ava中
的命名约定)。
compareTo()方祛应当只能接收一个参数，这个方法将这个参数和调用它的对象进行比
较。如果this对象小于参数对象，compareTo()应当返回比0小的位。如果this对象大乎
参数对象，应当返回比0大的值。如果两个对象相等,应当返同0。这些关于返回值的约
定非常重要，这样我们可以用下面的表达式替换掉关系比较和相等性运算符:
待替换
替换为
a<b
a.compareTo(b)<0
a.compareTo(b)<=0
a < =b
a.compareTa(b)>0
a>b
a.compareTo(b)>=0
a >mb
a.compareTo(b)=O
a=-b
a.compareTo(b) !=0
a !=b
例9-8中的Card类定义了该类的compareTo()方法，可以给Range类添加一个类似的方
法，用以比较它们的下边界:
Range.pratotype.compaxreTo= function(that} {
return this.from- that.from;
需要往意的是，这个方法中的馘祛操作根据两个Range对象的关系正确地返叫了小于O.
等于0和大于的值。例9-8中的Card.Rank枚举侑包含value0f() 方法，其实也可以给Card
类实现类似的compareTo()方法。
上文所提到的equals()方法对其参数执行了类型检查，如果参数类型不合祛则返
回false.compareTo()方法并没有返回一个表示“这两个值不能比较”的值,由f
conpareTo()没有对参数儆任何类型检查，因此如果给compareTo()方祛传人错误类型的
参数，往往会抛出异常。
往意如果两个范围对象的下边界相等，为Range类定义的compareTo()方法会返问0。
这意味着就compareTo()n言，任何两个起始点相同净注6的Range对象都相等。这个相
等概念的定义和equa1s()方法定义的相等慨念是相背的，cqua]s()要求两个端点均相
译注6: 这里所说的起始点相同就是下边界相同。
类和模块I
225

---
等才算相等。这种相等概念上的差另性会造成很多bug,最好将Range类的equals()和
compareTo()方法中处理相等的逻辑保持一致。这里是Range类修正后的compareTo())
法，它的比较逻辑和equals()保持--致,但当传入不可叮比较的值时仍然会报错:
/ 根据下边界米对Range对象排序，如果下边界相等则比较上边界
11如果传人非Range值、则抛出异常
11当且仅当this.equa1s(that)时,才返回0
Range.prototype.compareTo = function(that) {
:f (! (that instanceof Range))
throw new Error{"Can't compare a Range with“+ that);
/1比较下边界
var diff = this.from- that.from;
if (diff=s 0) diff= this.to 

- that.to 

; // 如果机等，比较上边界
return diff;
};
给类定义了compareTo()方法。这样就可以对类的实例组成的数组进行排序了。Array.
sort()方祛可以接收一个可选的参数，这个参数是一个函数，用来比较两个值的大小，
这个函数返回值的约定和compareTo()方祛保持一致。假定有了上文提到的compareTo()
方法，就叮以很方便地对Range对象组成的数纠进行排序了:
ranges.$ort(function(a,b}{ return a.compareTo(b); });
排序运算非常重要，如果已经为类定义了实例方法compareTo(),还应当参照这个方法
定义一个可传入两个参数的比较函数。使用compareTo()方法可以非常轻松地定义这个函
数，比如;
Range.byt.owerBound = function(a,b){ return a.compareTo(b); };
使用这个方祛可以让数组排序的操作变得非常简单:
ranges.sozt(Range.byLDwerBound) ;
有些类可以有很多方法逃行排序。比如Card类，可以定义两个方祛分别按照花仓排序和
按照点数排序。  

###  9.6.5 方法借用  

JavaScripl中的方法役有什么特別: 无非是一些简单的函数，贼值给了对象的属性，可
以通过对象来调用它。一个函数可以赋值给两个属性，然后作为两个方法来调用它。
比如，我们在Set类中就这样做了，将toArray()方法创建了一个副本，井让它可以和
toJSON(方法一样完成同样的功能。
多个类中的方法可以共用一个单狐的函数。比如，Array类通常定义了一些内避方法，
如果定义了一个类，它的实例是类数组的对象，则可以从Array.prototype中将函数复
226
第9章

---
制至所定义的类的原型对象中。如果以经典的面向对象语台的视角束矛JavaScript的话.
确
把一个类的方法用到其他的类中的做祛也称做“多重继承”
(multiple inheritance)。
然而，JavaScript并不昆经典的面向对象语言，我更倾向于将这种方法重用更止式地称为
“方祛错用”
{borrowing)。
不仅Aray的方法可以借用，还可以自定义泛型方法(generic method)。例9-9定义了泛
型方法toString()和equals(),可以被Range、Complex和Card这些简单的类使用。如枣
Range类役有定义equals()方法，可以这样惜用泛型方法equals() :
Range.prototype.equal$口gneric.quals;
注意，generic.equals()只会执行浅比较，因此这个方法并不适用于其实例太复杂的
类、它们的实例属性通过其equals()方法指化对象。同样需要注意，这个方法包含。世
特殊情况的程序逻辑。以处理新增浴Set对象小的属性(见例9-6)。
例9-9: 方法借用的泛型实现
!! 返回一个字符串，这个字符审包今构造闷数的名字(如果构造丽数包含名宇)
11以及所有非继承来的.非函数属性的名字和埴
to5trIng: function ()
ars= '[';
11如果这个对象包含构造函数，且构造函数包含名字
/1这个名字会作为返因宇符串的一部分
/1需要性意的尽，函数的名字属性恳非标难的。并不尼在所有的坏浇中都可用
if (this.constructor & this.constructor.name 

)
s += this.constructox.name 

 + ": ";
/! 改举所有非继承H 非崩数的属性
vaI n = 0;
for (vaI name in this) {
if (!this.hasOunProperty(name)) continue; 1/跳过继承来的属性
var value = this[name]
'function") continue; 11跳过方法
f (typeof value ===
:汇
if {n++) 5 += "，";
s += name +‘=‘+ value;
return 5+'l';
11通过比较this和that的构造函数和实例属性来判断它们是否相等
11这种方法只适合于那些实例属性尾原始值的情况，原始值可以通过"=="来比较
1这里还处理一种特殊情况，就悬忽胳由Set炎裕加的特殊属性
equals: function (that) {
+qatc-c
if (that == null) retuzn false;
if (this.constructor !== that.constructor) return false;
for (var name in this) {
"$**bjectid**j") continue;
l1跳挝特殊展性
if {name===
11跳过继承来的属性
if (!this.hasOwnProperty(name)) continue;
/! 比较是否桕竽
if (this[nane] !== that[name]) retuzn false;
类和模块
227

---
return true; 11如怨所有属性都匹配，两个对象相等  

###  9.6.6 私有状态  

在经典的面向对象编程中，经常需要将对象的某个状态封装或隐藏在对象内，只有通过
对象的方祛才能访问这些状态，对外只暴露一些重要的状态变量可以直接读写。为了实
现这个月的，类似Java的编程语言允诈声明类的“私有”实例字段,这些私有实例卞段
只能被类的实例方祛访问，且在类的外部是不可见的。
我们可以通过将变昼(或参数) 闭包在一个构造函数内来模拟实现私有实例字段，调用
构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数(因此
这个函数可以访问构造函数内部的参数和变昼)，并将这个函数斌值給新创建对象的属
性。例9-10展示了对Range类的另。种封装，新版的类的实例包含from()利to()方祛用
以返回范围的端点,而不是用from利to属性来获取端点。这里的from()和to()方法是定
义在每个Range对象上的，而不是从原型中继承来的。其他的Range方祛还是和之前一样
定义在原型中，但获取端点的方式从之前直接从属性谈取变成了通过from()和to()方祛
来读取。
例9-10: 对Range类的读取端点方法的茼单封装
functicn Range(from,to) {
/1不要将端点保存为对象的属性，相反
11定义存取器函数来返回端点的值
1这些值都保存东闲包中
this.from= function (){ retuIn from; };
th1s.to 

 。function (){ return to; }
11原梨[:的方迭无法直接操作端点
11它们必须调用存取器方陆
Range.prototype= ，
constructoI: Range,
<= x 品x <= this.to 

(); };
includes: function (x){ return this.from()
foreach: function (f) {
far (var x= Math.ceil(this.from()); max= this.ta(}; x <= max; x++) f(x};
toString: function (){ retutn "(" + this,fxom() +"..." + this.to 

() + ")"; }
这个新的Range类定义了用以读取范围端点的方法; 但没有定义设置端点的万祛或属
性。这让类的实例着起来是不可修改的，如果使用正确的话，
旦创建Range对象，端
点数摒就不可修改了。除非使用BCMAScript 5 (参照9.3节) 中的某些特性，但from和to
属性依然是可写的，并且Range对象实际上并不是真正不可修改的:
228| 第9章

---
!1一个不可修改的范围
var r = new Range(1;5);
的名
//通过方法替换术修改它
x.from = functicn(}{ Ieturn 0; };
但需要往意的尼，这种封装技术造成了更多系统开销。使用闭包来封装类的状态的类一
定会比不使用封装的状态变量的等价类运行速应更慢，非占用更多内存。  

###  9.6.7 构造函数的重载和工厂方法  

有时候，我们希望对象的初始化有多种方式。比如，我们想遁过半径和角度(极坐标)
来初始化一个Complex对象，而不是通过实部和虚邵米初始化，或者远过元素组成的数
组来初始化一个Sct对象，而不是通过传入构造函数的参数来初始化它。
有一个方祛可以实现，通过重载(overload) 这个构造函数让它根据传人参数的不同来
执行不同的初始化方法。卜面这段化码就是重载Set()构造函数的例子;
function Set(} {
11用这个刈象的属性来朵仟这个秉合
this.values= {};
// 集合中值的个黻
this.n " (;
11如果传人一个类教纠的对象，将这个元卖爵加至集公中
11否则，将所有的参数都忝加至集合巾
if (arguments.length u 1&& isArrayLike(arguments[]))
this.add.apply(this; arguments[Q]);
else if (arguments.length > 0
this.add.apply(thi5; arguments);
这段代码所定义的Set()构造函数可以显式将一组元索作为参数列表传人，也可以传入
元裁组成的数组。但是这个构造函数有多义性，如果集合的某个成员是一个数组就无祛
通过这个构造函数来创建这个集合了(为了做到这一点，需要首先创建一个空集合，然
石显式调用add()方法)。
在使用极水标来初始化复数的例子中，实际上并没有看到有函数重裁。代表复数两个维
度的数宇都是浮点数，除非给构造函数传人第三个参数，否则构造函数无法识别到底传
入的是极佟标参数还是直角坐标参数。相反，可以写一个工方法-
个类的方法用
以返回类的.个实例。下面的例子即是使用工厂方法来返回一个使用极烬标初始化的
CouplexI t象:
complex.polar= functicn(I,theta) {
return new Complex(r*lath.cos(theta),r*Math.sin(theta});
};
下面这个工厂乃法用来通过数组初始化Set对象:
类和模块
|229

---
5et.frouArray= function(a) {
1/朗建一个空集合
s= new Set();
//将数组a的成员作为畚数传人add()方祛
s.add.app1y(s,a};
11返回这个新集合
return 5;
可以给工厂方法定义征意的名字; 不同名字的工厂方祛用以执行不同的初始化。但由于
构造函数是类的公有标识，因此每个类只能有一个构造函数。但这并不是一个“必须遵
守”的规则。在JavaScript中是可以定义多个构造函数继承自一一个原型对象的，如果这
样做的话; 由这些构造函数的任意一个所创建的对象都属于同一类型。并不推荐这种技
松，但下面的示例代码使用这种技术定义了该类梨的一个辅助构造函数:
11Set类的一个辆助构造函数
funct ion SetF romArray(a) {
1! 通过以函数的形式调用Set()来初始化这个新对象
l1将a的兀素作为参数传人胜性7
Set.apply(this,a);
11设置原型，以便5etFromArray能创建Set的实例
Set FromAtray.prototype = Set.prototype;
var s = new SetFxomAay([1,2;3]);
iinstanceof Set /1=> true  

##  9.7 子类  

在面向对象编程中，类B可以继承自另外一个类A。我们将A称为父类(superclass)
将B称为子类(subclass)。B的实例从A继承了所有的实例方法。类B可以定义自己的实
例方法，有些方法可以重载类A中的同名方法，如果B的方法重载了A中的方法，8中的
重載方法可能会调用A中的重载方法，这种做法称为“方法链”
(mclhod chaining)。
同样，子类的构造函数B()有时需要调用父类的构造函数A(),这种做祛称为“构造函数
链“
(constructor chaining)。子类还可以有子类，当涉及类的层次结构时，往往需要定
义抽象类(abstract c1ass)。抽象类中定义的方法没有实现。抽象类巾的抽象方法是在
抽象类的具体子类中实现的。
在JavaScript中创建了类的关键之处在于，采用合适的方法对原型对象进行初始化。如果
类B继承自类A,B.prototype必须是A.prototype的后嗣。B的实例继承自B.prototype,
后者同样也继承自A.prototype。本节将会对刚才提到的子类相关的术语做一一诽解，还
会介绍类继承的替代方案:“组合”
(compo sition )
我们从例9-6中的Set类开始讲解，本节将会讨论如何定义子类，如何实现构造函数链并
apply()的第二个参数是一个数纪，数组成员就是参数列表。
译注7:
第9章
230
---
重载方法。如何使用组合来代替继承，以及最后如何[通过抽象类从实现中提炼出接H。
本节以一个扩展的例子结束，这个例子定义了Set类的层次结构。往意，本节开始的几个
例子着重诽述了实现子类的基础技术。其巾某些技术有着重要的缺陷，后续几节会讲到。  

###  9.7.1 定义子类  

JavaScript的对象可以从类的原型对象中继承属性(通常继承的是方法)。如果0是类B
的实例，8是A的子类，那么0也一定从A中继承了属性。为此，首先要确保B的原型对
象继承自A的原型对象。通过inherit()函数(例6-1)，可以这样米实现:
1子类振生自父类
B.prototype " inhexit(A.prototype) ;
//重载继承来的constructor属性
3.prototype.constructor = B;
这两行代码是在JavaScript中创建子类的关键。如果不这样做，原型对象仪仪是一个普
通对象，它只继承自0bject.prototype.这意味着你的类和所有的类一样是0bjecl的子
类。如裂将这两行代码舔加分defineClass()函数中(參照9.3节)，可以将它变战例9-11
中的defineSubclass( )函数和Function.prototype.extend()方法:
剑9-11: 定义子类
11用一个简单的的数创建简单的子粪
11父类的构造函数
function defineSubclass (supexclass,
11新的子类的构造昀数
constructor,
11实例方法: 复制歪原型中
methads,
1! 类属性: 复制伞构遄卤數中
statics)
11建立了类的原型对象
onstructor-prototype= inherit (superclass.prototype);
constructor.pzototype.constructor = constructor;
11像对常规类。样复制方祛和类属性
if (methods) extend(constructor.prototype,methods);
if (statics) extend(constructor,statics);
ll 返回这个类
Ieturn constructor;
/1也可以通过父类构遣函数的方法来散到这:点
Function.prototype.extend = function (constructor,methods,statics) ，
return defineSubclass(this,constructor; methods; statics) ;
};
例9-12展示了不使用defi.neSubclass()函数如何“手动”实现子类。这里定义了Set的子类
SingletonSt。SingletonSet是--个特殊的集合，它是只读的，而且含有单狲的常量成员。
例9-12: SingletonSet:一-个筒单的子类
/ 构造函数
function SingletonSet(member) {
//记供集合中这个翟一的成贝
this.member 口member;
类和模块| 231

---
l1创建一个点型对象，这个原型对象继承自Set的原型
Singletonset.prototype = inherit(5et.prototype) ;
ll 绍原型舔加属性
11如果有同名的闾性沈覆盖Set.prototype中的同名展性
extend(SingletonSet.prototype,{
ll 设贸合适的constructor属性
constructor: SingletonSet,
11这个集合是只读的: 调用ad()和xemove()都会报错
dd: function (){ throw "read-only set"
十1
aoo.l.E.+
remove; function () {throw "Iead-only set"; };
/ SingletonSet的实例巾永远只有一个元紧
size; function () {return 1; ;
'1这个方法只调H一2
传人这个聚含的唯一成员
foxeach: function (f; cDntext){ f.cal(context,this.membex); }，
1contains()方祛非常简单: 只须检查传人的谊是台匹配这个集介唯一的成员即可
contains: function (x){ return xc=c this.member; }
});
这里的SingletonSet类是一个比较简单的实现，它包含5个简单的方法定义。它实现了5个
核心的Set方法,但从它的父类中继承了toString().toArry()和equals()万法。定义子
类就是为了继承这些方法。比如，Set类的equals()方法(在9.4节中定义) 用来对Set实
例逃行比较.只要Set的实例也含size()和fareach()方法，就可以通过equals()比较。
因为SingletonSet悬Set的了类，所以它自动继承了equals()的实现，不用再实现一次。
当然，如果想要最简单的实现方式，那么纷SingletonSet类定义它自己的equals()版本会
更高效~些:
SingletonSet.prototype.equals= function(that] {
retuin :that instanceof Set 踞that.size()==1& that.contains(this,member) ;
};
需要注意的是，SingletonSet不是将Sel中的方法列表静态地偕用过来，而是动态地从Set
类继承方法。如果给Set.prototype黹加新的方法，Set利1SingletonSet的所有实例溉会立
即拥有这个方法(假定SinglelomSet没有定义与之间名的方法)。  

###  9.7.2 构造函数和方法链  

最后、节的SingletonSet类定义了全新的集合实现，而且将它继承自其父类的核心方法会
部替换。然而定义了类时，我们往往希望对父类的行为进行修政或扩充，而不是完佥替
换掉它们。为了做到这一点，构造函数和子类的方祛需要调用或链接到父类构造函数和
父类方法。
例9-13 对此做了展示。它定义了Ser的子类NonNullset,它不允诈nu11和lundefined作刈
第9章
232

---
它的成员。为了使用这种方式对成员做限制，NonNullSet需要在其add()方法中对null和
undefined值做检测。但它需要完杂重新实现一个add()方法，因此它调用了父类中的这
个方法。往意，NonNu11Set()构造函数同样不需要重新实现。它只须将它的参数传人父
类构造函数(作为晒数来调用它，而不是通过构造函数来调用)，通过父类的构造函数
来初始化新创建的对象。
例9-13: 在子类中调用父类的构造函数和方法
NonNu1l5et 是Set的于类。它的成员不能是null Cundefined
function NonNu11Set() {
//仪链控到父类
11炸为普通函数调用父类的构笾的数来初始化通过该构造函数调用创建的对象
Set.app1y(this,aguments);
/1将NonNu1lSet设置为Set的子类
NonNull5et.prototype= inherit($et.prototype);
NonNullSet.prototype.constructor = NonNu115et;
1为了将nul1和undefned排除在外，只须童写add()方法
NonNul15et.prototype.add 四function() {
/1检耷参数是不是nu11或undefined
for (var i= D;i < aIguments.length; i++)
if {azguments[i]== null)
throw new Error("Can' tadd nu11or undefined t a NonNul1Set");
//调用父类的ad()方法以执行实冻括人操乍
TetuIn Set.prototype.add.apply(this,arguments) ;
}=
让我们将这个非nu11集合的概念推而广之: 称为“过滤后的集合”，这个集合中的成员
必须首先传人~个过滤函数冉执行舔加操作。为此，定义一个类工厂函数(类似例9-7中
的enumeration()函数)，传人--个过滤丽数，返回一个新的Set 「类。实际上，可以对
此做进一步的通用化的处理，定义一个可以接收两个参数的类丁厂: 子类和用于add{)
方祛的过滤函数。这个工厂方让称为filteredsetSubclass{).井通过这样的代码来使用它:
I 定义一个只能保存字符串的“集合"类
var Stringset = flteredSetSubclass(Set,
function(X) {return typeof x-"'tring"; });
11这个集今类的成认不能是null.undefined或函数
vaI MySet= flteredSetSubclass{NonNu1lSet;
function(x) {return typeof x !== "function"; }) ;
例9.14是这个类工厂函数的实现代码。注意，这个例「中的方祛链和构造函粼链和
NonNullset中的实现是一样的。
类和模块
233

---
例9-l4: 类工厂和方法链
& 这个函数返回具体Set类的子类
* 并重写该类的add()方祛用以对添加的元索做特殊的过旎
function filteredSetSubtlass(superclassj f1ter) {
var constructor = function{){" Il 子类构造函数敷
supexclass.apply(this,arguments}; 1l 调用父类构造函数
var proto = constiuctor.prototype= inhexit(superclass.prototype);
proto.constructor = constructor;
proto.add= function{ )
1/在掭加任何成员之前首先使用过褪器将所有参数进行让遮
fox (var i " 0; i < arguments.length; it+) {
var v = arguments[i];
1f ([flteI(V)) throw ("value" + v + “rejected by flter");
11调州父类的add()方法
superclass.prototype.add.邮ply(this,arguments);
re tu rn < c nstructor;
例9-14中一个比较有趣的事情是，用一个函数将创建子类的代码包装起来，这样就可以
在构造函数和方祛链中使用父类的参数，而不是通过写死某个父类的名字来使用它的
参数。也就是说如果想修改父类，只须修改-处化码即可，fj不必对每个用到父类类
名的地方都做修改。巳经有充足的理由证明这种技术的可行性，即使在不是定义类工
厂的场景中，这种技术也是位得提倡使用的。比如，可以这样使用包装丽数和例9-11的
Function.prototype.extend()方法米重写NonNullSet:.
/1定义并立即调用这个函教
vaI NonNullSet= (function() {
11仅指定父类
var Superclass = Set;
Ieturn superclass.extend(
/1构造喇数
function(){ superclass.apply(this,aguments}; }，
11方祛
add; function() {
11检登参数是否是nu1l或undefined
for (var i= 0; i< arguments.length; i++)
if (arguments[i]== null}
throw new Error("Can 't add nu11or undefined") ;
//调用父类的add()方祛以执行实际插人操作
return superclass.prototype.add.appIy(thi5j arguments) ;
());
最后.值得强调的是，类似这种创建类丁厂的能力是JavaScript语言动态特性的一个体
现，类工厂是一种非常强大和有用的特性，这在Java和C++等语言中是役有的。

###  9.7.3 组合VS 子类  

加M |
在前一节巾，定义的集合可以根据特定的标雒对集合成员做限制，而且使月了子类的技
术来实现这种功能，所创建的自定义子类使用了特定的过滤函数来对集合中的成员做限
制。父类和过德函数的每个组合都需要创建一个新的类。
然而还有另-种更好的方法来完成这种需求，即面向对象编程中一条广为人知的设计原
“组合优于继承”律2。
这样，叮以利用组合的原理定义一个新的集合实现，它“包
则:
装”了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个(包装的) 集合对
象。例9-15展示了其工作廓埋;
例9-15: 便用组合代替继承的集合的实现
实现一个FilteredSet,它包装某个指定的”集合“对象。
并对传人add()方法的值应州了某种指定的过艴器
“范围"类中其他所有的核心方法延续到包装石的实例中
var FilteredSet = Set.extend(
function Filtered5et(set; flter){ 11构遣函数
this.set= set;
this.filter = filter;
;11实例方去
add: function() {
11如梁已有过滤器，直接使用它
if (this.fi1ter) {
for {var i= 0; i < arguments.length; i++) {
ar v 二argument$[i] ;
if {Ith1s.flter(v) )
throw new Error("FilteredSet: value“+ v +
rejected by fter") ;
}
11调用set中的add()方祛
this.set.add.apply(this.set,arguments);
return this;
剩下的方法都保持不变
remove: function() {
this.set.remove.apply(this.5ets arguents) ;
return this;
contains: function(v){ retumn this.$et.contains(v}; },
this-set.size()i>}'
size: function(){ xetutn this.set.si 

;
foreach: function{f,c){ this.set.foreach(f,c); }
});
可参照Erich Gacma et al所茅(Design Patterns) 和Joshua Bluch所菩《Efectivc Java2 。
主2:

###  9.7.3 组合VS 子类  

加M |
在前一节巾，定义的集合可以根据特定的标雒对集合成员做限制，而且使月了子类的技
术来实现这种功能，所创建的自定义子类使用了特定的过滤函数来对集合中的成员做限
制。父类和过德函数的每个组合都需要创建一个新的类。
然而还有另-种更好的方法来完成这种需求，即面向对象编程中一条广为人知的设计原
“组合优于继承”律2。
这样，叮以利用组合的原理定义一个新的集合实现，它“包
则:
装”了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个(包装的) 集合对
象。例9-15展示了其工作廓埋;
例9-15: 便用组合代替继承的集合的实现
实现一个FilteredSet,它包装某个指定的”集合“对象。
并对传人add()方法的值应州了某种指定的过艴器
“范围"类中其他所有的核心方法延续到包装石的实例中
var FilteredSet = Set.extend(
function Filtered5et(set; flter){ 11构遣函数
this.set= set;
this.filter = filter;
;11实例方去
add: function() {
11如梁已有过滤器，直接使用它
if (this.fi1ter) {
for {var i= 0; i < arguments.length; i++) {
ar v 二argument$[i] ;
if {Ith1s.flter(v) )
throw new Error("FilteredSet: value“+ v +
rejected by fter") ;
}
11调用set中的add()方祛
this.set.add.apply(this.set,arguments);
return this;
剩下的方法都保持不变
remove: function() {
this.set.remove.apply(this.5ets arguents) ;
return this;
contains: function(v){ retumn this.$et.contains(v}; },
this-set.size()i>}'
size: function(){ xetutn this.set.si 

;
foreach: function{f,c){ this.set.foreach(f,c); }
});
可参照Erich Gacma et al所茅(Design Patterns) 和Joshua Bluch所菩《Efectivc Java2 。
主2:
235
类和模块

---
在这个例了中使用组合的一个好处是，只须创建一个单独的FilteredSet子类即可。可
以利用这个类的实例米创延任意带有成员限制的集合实例。比如，不用上文中定义的
NonNullSet类,可以这样做:
var s = new FilteredSet(new 5et(); function(x){ return x 1== nu11; });
甚至还可以对已经过滤后的集合进行过滤;
v虹t 。neW FIlteredSet(s,{ function(x){ return !(x instanceof Set); }};  

###  9.7.4 类的层次结构和抽象类  

在上一节中给出了“组合优于继承”
的原则，但为了将这条原测阐述清楚，创建rSet
的子类。这样做的原因是最终得到的类是Set的实例评庄8，它会从Set继承有用的辅助方
法，比如toString()和lequa1s()。尽管这是一个很实际的原因，但不用创建类似$et类这
种具体类的子类也可以很好的用组合来实现“范围”。例9-12中的SingletonSet类可以有
另外一种类似的实现，这个类还是继承自Set,因此它可以继承很多辅助方法，但它的实
现和其父类的实现完会不一样。SingletonSet并不是Set类的专用版本，而是完全不同的
另一种Set。任类层次结构中SingletonSet和Set应当是兄弟的关系，而非父子关系。
. 译 往 9
“从
不管是在经典的面向对象编程语言中还是在JavaScript中,通行的解决办迭是
实现中抽离出接口”。假定定义了一个AbstractSct类，其中定义了一些辅助方法比如
toString(),但并役有实现诸如foreach()的核心方法。这样，实现的Sel,SingletonSet
和FiltcrcdScl都是这个抽象类的子类，FilteredSel和SinglelonSet都不必再实现为某个不相
关的类的子类了。
例9-16在这个思路上更进一步; 定义了一个层次结构的抽象的集合类。AbstractSet只定
义了一个抽象方祛; contains()。任何类只要“声称”自己是一个表示范围的类。就必
须至少定义这个contains()方法。然后，定义AbstractSet的子类AbstractEnumerableSet。
这个类增加「抽象的size()和foreach()方法，而且定义了一些有用的非抽象方祛
(toString()、toArray().equals()等)，AbstractEnumerableSet并没有定义add()和
remove()方法，它只代表只读集合。SingletonSet可以实现为非抽象了类。最后，定义r
AbstractEnumerableSet的子类AbstractWritableSet。这个final抽象集合定义了抽象方法
add()和xemove(),并实现了诸如union()和intersection()等非具体方祛。这两个方祛
作者这里的表述稍有含泥，作者的意思应该是“Set子美的实例也是Set的实例”，而不是
译注8 :
“子类是8el的实剑”
译注9; 这里指的是实现类的不同定制版本的解决办法，更直接地讲就是实现多态的方法。
第9章
236 !

---
调用了add()和remove()。AbstractWritableSet&Sert和FilteredSet类相应的父类。但这
个例子中并没有实现它，而是实现了。个新的名叫ArraySet的非抽象类。
叫
例9-16中的代码很长。但还是应当完整地阅读一遍。社意这里用到了Function.
prototype.extend()作为创建子类的快捷方式。
例9-16: 抽象类和非抽象Set类的层次结构
11这个雨数叮以用做任何抽象方法，非常方侦
function abstractmethod{){ throw new Error("abstract mthod"}; }
!*
* AbstractSet类定义了一个泊象方祛: contains()
function AbstractSet(}{ throw new Error{"Can' t instantiate abstract classes"); }
AbstractSet.prototype.contains= abstractmethod;
Not5et是AbstractSet的一个非抽象了类
所有不在其他集合中的成员都在这个染合中
* 因为它是在其他每合是不可写的条件下定义的
* 同时由于它的成员七无限个,因此它是不可放举的
我们只能用它来检测元業成员的! |属惰况
注意，我们使用广Function.prototype.extend()方头来定义这个子类
var NotSet 口Abstract5et,extend(
function NotSet(set){ this.set 四set; }↓
contains: function (x) {retuin lthis.set.contains(x); },
(x) i
return"~" + this.set.to5tring(); }
toString: function
equals: function (that){
retuzni that instanceof Notset 蹈this.set.equals(that.set);
);
* AbstractEnumerableSet 尼AbstractSet的一个抽象子奖
它定义了抽象方法size()和foreach()
然后实现了非抽象方法isEmpty().toArray().to[Locale]String()和equals()方法
了类灾现丁contains().size()和foreach().这三个方法可以很轻易地调用这5个非抽象方祛
var AbstractEnumerableSet= AbstractSet.extend(
functicn (){ throw new Error("Can't instantiate abstract classes"); },
size: abstractmethod;
foreach: abstractmethod,
;Eono*
isEmpty: function (){ return this.size()a= 0; },
toString: function
var 5 = "{"} i= 0;
this.foreach(function (v} {
if (i++>0) s += “;";
s 切v;
});
类和模块| 237

---
调用了add()和remove()。AbstractWritableSet&Sert和FilteredSet类相应的父类。但这
个例子中并没有实现它，而是实现了。个新的名叫ArraySet的非抽象类。
叫
例9-16中的代码很长。但还是应当完整地阅读一遍。社意这里用到了Function.
prototype.extend()作为创建子类的快捷方式。
例9-16: 抽象类和非抽象Set类的层次结构
11这个雨数叮以用做任何抽象方法，非常方侦
function abstractmethod{){ throw new Error("abstract mthod"}; }
!*
* AbstractSet类定义了一个泊象方祛: contains()
function AbstractSet(}{ throw new Error{"Can' t instantiate abstract classes"); }
AbstractSet.prototype.contains= abstractmethod;
Not5et是AbstractSet的一个非抽象了类
所有不在其他集合中的成员都在这个染合中
* 因为它是在其他每合是不可写的条件下定义的
* 同时由于它的成员七无限个,因此它是不可放举的
我们只能用它来检测元業成员的! |属惰况
注意，我们使用广Function.prototype.extend()方头来定义这个子类
var NotSet 口Abstract5et,extend(
function NotSet(set){ this.set 四set; }↓
contains: function (x) {retuin lthis.set.contains(x); },
(x) i
return"~" + this.set.to5tring(); }
toString: function
equals: function (that){
retuzni that instanceof Notset 蹈this.set.equals(that.set);
);
* AbstractEnumerableSet 尼AbstractSet的一个抽象子奖
它定义了抽象方法size()和foreach()
然后实现了非抽象方法isEmpty().toArray().to[Locale]String()和equals()方法
了类灾现丁contains().size()和foreach().这三个方法可以很轻易地调用这5个非抽象方祛
var AbstractEnumerableSet= AbstractSet.extend(
functicn (){ throw new Error("Can't instantiate abstract classes"); },
size: abstractmethod;
foreach: abstractmethod,
;Eono*
isEmpty: function (){ return this.size()a= 0; },
toString: function
var 5 = "{"} i= 0;
this.foreach(function (v} {
if (i++>0) s += “;";
s 切v;
});
类和模块| 237

---
retuin s +"}"i
toLocaleString: function () {
vaI 5="{"↓i= 0;
this.foreach(function (v)
if (i++>0) S =■"，";
if (v== nu1l) s = v; 11nullTundefined
else 5 = v.tDLocaleString(); !! 其他的悄况
return s + "}";
taArIay: function () ，
var a= [];
this.foreach(function (v){ a.push(v); });
return a;
equals: function (that) {
if (I (that.instanceof AbstractEnumerabIe5et)) return false;
/1如果它们的大小不同，则它们不相等
if (this.size() != that.size()) return false;
//检在每一个元素是否也在that中
tzy
this.foreach(function (v){ if (!that.contains(v)) throw false;.});
return tiue; 11所有的元素邯匹配: 集合相等
}catch(x) 、
if (x== false) return false; 11聚命不相竿
thzow x; 1/发生了其地的异帑: 盂新抛出异常
});
/市
SingletonSet是AbstractEnumerab1e5et的非抽象千类
singleton.合是只读的,它只包含一个成员
vaI SingletonSet = AbstractEnumerableSet.extend(
function singleton5et(member}{ this.membeI= member; };
contains: function (x){ return x === this,member; };
$ize: function (){ return 1; }
foreach: function (f; ctx){ f.call(ctx,this,mmbet); }
Ab s t rz cthrit ab1 eSet是 Abstra ctE n umera ble Set 的抽象 子类
它定义「抽象方祜add()和remove()
然片实现了非抽象方法union()、intersection()和difference()
var AstracthritableSet= AbstractEnumerableSet.extend(
functi.on (){ throw new Error("Can't instantiate abstract classes"); },
add: abstractmethod,
abstractmethod,
removE
union: function {that) {
第9章
238 |
---
foreach: function(f) {for(var x=Math.cei1(this.from};x<=this.to 

;X+) f(x);},
toString: function(){ xetuzn "(" + this.from + "..." + this.to 

 +")";
});  

###  9.8.3 封装对象状态  

如9.6.6节和例9-10所示; 构造函数中的变最和鑫数叮以用做它创建的对象的私有状态。
该方法在ECMAScript 3中的-个缺点是，访问这些私有状态的存取器方祛是可以替换
的。在ECMAScript 5中叮以通过定义属性geller和seller方i法将状态变昼更健壮地封装起
来，这两个方法足尤祛删除的，如例9-21所示。
例9-21: 将Range类的端点严格封裴起来
! 这个版卡的Range类是可变的，但将端点交盘进行了良好的封装
11但端点的大小)顺序还是固定的: from 仁tr
function Range(fIom,to) {
11如果fiom大午ta
if (from > to) thIow new Error("Range: from must be <= to");
/1定义存取器方法以维持不变
function getFIom(){ return from; }
function getTa()_{ return to; }
11设置from的值时。不允许from大子to
function setFrom(f} {
if (f <= to) fi吻= f;
else thzow new Error("Range: from must be (= to");
'/ 设置to的值时，不尤许to小于fyom
function setTo{t)
if (t >= from) to = t;
else throw new Error("Range: t must b >= fzom");
11将使用取值器的腐性设置为可枚举的，不叫配翌的
bject.defineProperties(this,{
from: {get; getFrom,set: setFrom,enumerable: true,configurable; false },
o: {get :getTo,set: setTo,enumerab1e: true,confgurable: false }
});
/1和前面的恻子相比，原犁对象役有做任何修改
11实例方法可以像谈取普通的属性一样读取from私to
Range.prototype= hideProps({
constructor: Range,
inc1udes: function(x){ retuin this.from c= x 品x <= this.to 

; }，
foreach: function(f}
{for (var x= Math.ceil(this.ftom); x (= this.to 

; x++) f(x};};
toString: function(}{ xeturn "(" + this.fxom +"..." + this.to 

 + ")"; }
}};  

###  9.8.4 防止类的扩展  

通常认为，通过给原型对象添加方法可以动态地对类进行扩展，这是JavaScript本身的
类和模块! 243

---
特性。ECMAScript 5可以根据需荽对此特性加以限制。0bject.preventExtensions()
可以将对象设置为不可扩展的(见6.8.3书)，也就是说不能给对象添加任何新属性。
0bject.seal()则更加强大，它除了能殂止用户给对象添加新属性; 还能将当前已有
的属性设置为不可配胃的，这样觥不能删除这些属性了(但不可配置的属性可以是
可写的，也可以转换为只读属性)。可以通过这样一句简单的代码来阻止对0bject.
prorotypei的扩展:
0bject.sea1(object.protatype) ;
JavaScript的另外一个动态特性是“对象的方法可以随时替换”(或称为“monkcy-
patch") :
ar original_sort_method= Array.prototype.sort;
Array.prototype.sort = functipn() {
tar start = new Date();
original_sort_method.邮ply(this,aguments);
var and = new Dat();
console.1og("Alay sort took ”+ (end- stact) + " milliseconds.");
};
可以通过将实例方法设置为只读来防止这类修改，--种方法就是使用上面代码所定义的
freezePIops()工具函数。另外--种方法尼使用0bject.fxeeze()，它的功能利Qbject.
seal()完全一样,它问样会把所有属性都设咒为只读的利不可配咒的。
理解类的只读属性的特性至关重婆。如果对象o继承了只读属性p,那么给O.P的赋值操
作将会失败，就不会给o创建新属性。如果你想重写一个继承来的只读属性，就必须使用
bject.definePropertiy().bject.defineProperties()或0bject.create()来创建这个
新属性。也就足说，如果将类的实例方法设咒为只读的，那么重写它的子类的这些方祛
的难度会更大。
这种锁定原型对象的做法往往没有必要，似的确有一些场悬是需要阻止对象的扩展的。
回想下例9-7中的erumeration(),这是一个类工厂函数。这个函数将枚举类型的每个
实例都保存在构造凼数对象的属性里，以及构造函数的values数组中。这些属性和数组
(frcczing) 操作的，这样就
是表示枚举类犁实例的止式实例列表，是可以执行“冻结”
不能给它添加新的实例，已有的实例也无法删除或修改。可以给enumeration()函数舔
加儿行简单的代码:
object.fxeeze(enumeration.values);
bject.freeze(enumeration) ;
第9章
244

---
特性。ECMAScript 5可以根据需荽对此特性加以限制。0bject.preventExtensions()
可以将对象设置为不可扩展的(见6.8.3书)，也就是说不能给对象添加任何新属性。
0bject.seal()则更加强大，它除了能殂止用户给对象添加新属性; 还能将当前已有
的属性设置为不可配胃的，这样觥不能删除这些属性了(但不可配置的属性可以是
可写的，也可以转换为只读属性)。可以通过这样一句简单的代码来阻止对0bject.
prorotypei的扩展:
0bject.sea1(object.protatype) ;
JavaScript的另外一个动态特性是“对象的方法可以随时替换”(或称为“monkcy-
patch") :
ar original_sort_method= Array.prototype.sort;
Array.prototype.sort = functipn() {
tar start = new Date();
original_sort_method.邮ply(this,aguments);
var and = new Dat();
console.1og("Alay sort took ”+ (end- stact) + " milliseconds.");
};
可以通过将实例方法设置为只读来防止这类修改，--种方法就是使用上面代码所定义的
freezePIops()工具函数。另外--种方法尼使用0bject.fxeeze()，它的功能利Qbject.
seal()完全一样,它问样会把所有属性都设咒为只读的利不可配咒的。
理解类的只读属性的特性至关重婆。如果对象o继承了只读属性p,那么给O.P的赋值操
作将会失败，就不会给o创建新属性。如果你想重写一个继承来的只读属性，就必须使用
bject.definePropertiy().bject.defineProperties()或0bject.create()来创建这个
新属性。也就足说，如果将类的实例方法设咒为只读的，那么重写它的子类的这些方祛
的难度会更大。
这种锁定原型对象的做法往往没有必要，似的确有一些场悬是需要阻止对象的扩展的。
回想下例9-7中的erumeration(),这是一个类工厂函数。这个函数将枚举类型的每个
实例都保存在构造凼数对象的属性里，以及构造函数的values数组中。这些属性和数组
(frcczing) 操作的，这样就
是表示枚举类犁实例的止式实例列表，是可以执行“冻结”
不能给它添加新的实例，已有的实例也无法删除或修改。可以给enumeration()函数舔
加儿行简单的代码:
object.fxeeze(enumeration.values);
bject.freeze(enumeration) ;
第9章
244

---
需要注意的是。通过在枚举类犁中调用0bject.fxeeze().例9-17中定义的bjectId属性
之后也无祛使用了。这个问题的解决办法是，在枚举类型被“冻结”之前读取一次它的
bjectId属性(调用潜在的存取器方法并设置内部属性》。  

###  9.8.5 子类和ECMAScript 5  

例9-22使用KCMAScript 5的特性实现子类。这里使用例9-16中的AbstractWritableSet
类来做进一步说明，来定义这个类的子类StringSct。下面这个例子的最大恃点是使用
bject.create()创建原型对象，这个原型对象继承白父类的原型，同时给新创建的对
象定义属性。这种实现方法的困难之处在丁，正如上文所提到的，它需耍使用难看的属
性描述符。
这个例子中另外一个有趣之处在丁，使用0bject.create()创建对象时传入了参数null,
这个创建的对象没有任何继承任何成员。这个对象用来存储集合的成员，同时，这个对
象役有原型，这样我们就能对它直接使用in运算符详注l,
而不须使用has0wnProperty()
方法。
例9-22: StringSet: 利用ECMAScript5的特性定义的子类
function 5tringSet () {
this.set= 0ject.create(null); 1! 创建一个不包含原型的对象
this.n= 0;
this.add.apply(this,aguments);
11注意，使用bject.create(}可以继承父类的原型
1i 页且可以定义单独调用的方祛，因为我扩没有指定属性的可写性、可枚举性和可配置性
/! 因此这些属性特性的器认恨都是false
11只读方法让这个类难于子类化(被继承)
5tringset.prototype= bject.create(AbstractHritable5et.prototype,{
value: StringSet }。
constructor:
contains: {value; function(x){ return x in this.set;} },
size:{ va1ue: function(x}{ return this.n;} },
foreach:{ vaiue: function(f,c){ 0bject.keys(this.set).forEach(f,c);} },
dd: {
value: function() {
for (var i= 0; i< arguments.length; itt) {
if (!(axguments[1] in this.set)) {
this.set[arguments[ i]]= true;
th is. n+ ;
return this;
};
remove:
泽注12: 使用in运算符可以时对象成负进行遍历，包括对原型对象中的非内置成负进行避历。
类和模块
245

---
value :funct ion()
for (var i= 0; i< aguments.length; i+) {
f(arguments[i] in this.set} {
delete this.set[arguments[1]];
this.n--;
return this;
});  

###  9.8.6 属性描述符  

6.7节讨论了ECMAScript 5中的属性描述符，但役有给出它们的示例代码。本节给出
个例子，用来讲述基于ECMASeript 5如何对属性进行各种操作。在例9-23中给0bject.
prototype添加了properti.es 

()方祛(这个方法是不可枚举的)。这个方法的返回值是
一个对象，用以表示属性的列表，并定义了有用的方法用束输出属性和属性特性(对于
调试非常有用)，用来狄得属性描述符(当复制属性同时复制属性特性时非常有用) 以
及用来设置属性的特性(是上文定义的hideProps()和freezeProps()函数不错的巷代方
案)。这个例子展示了ECMAScript 5的天多数属性相关的特性，]同时使用了一种模块编
程找术，这将在一节讨论。
例9-23: ECMAScript 5属性裸作
绐bject.prototype定义properties()方法，
这个方法返回“个表示调用它的对象上的属性名列表的对象
(如果不带参数调用它，就表示该对象的所有属性)
返回的对象定义了4个布用的方法: taString(}、descriptors().hide()和show()
(function namespace(){ 11将所布逻辑闭包在一个私有函数作用域中
11这个数成为所有对象的方祛
function properties(] {
var names; 11寫性名组战的数组
.f (arguments.length== 0) 11所有的自有焖性
names := oject.getQwnPropertyNames(this);
else if (agument5.length== 1跟Array.isArray(arguments[0]))
昨guments[0]; 11名字组成的数组
na mes
'1参数列表本身就是名字
else
names= Aray'prototype.splice.call(axguments; );
11返四.个新的Properties对象，用以表示属性名字
return new Properties(this,names);
'1将它设置为0bject.prototpye的新的不可枚举的属性
/1这是从私有的数作用城导山的唯一一个值
Object.definepIoperty(Qbject.prototype,"propperties" ，{
value: properties,
第9章
246

---
value :funct ion()
for (var i= 0; i< aguments.length; i+) {
f(arguments[i] in this.set} {
delete this.set[arguments[1]];
this.n--;
return this;
});
###  9.8.6 属性描述符
6.7节讨论了ECMAScript 5中的属性描述符，但役有给出它们的示例代码。本节给出
个例子，用来讲述基于ECMASeript 5如何对属性进行各种操作。在例9-23中给0bject.
prototype添加了properti.es 

()方祛(这个方法是不可枚举的)。这个方法的返回值是
一个对象，用以表示属性的列表，并定义了有用的方法用束输出属性和属性特性(对于
调试非常有用)，用来狄得属性描述符(当复制属性同时复制属性特性时非常有用) 以
及用来设置属性的特性(是上文定义的hideProps()和freezeProps()函数不错的巷代方
案)。这个例子展示了ECMAScript 5的天多数属性相关的特性，]同时使用了一种模块编
程找术，这将在一节讨论。
例9-23: ECMAScript 5属性裸作
绐bject.prototype定义properties()方法，
这个方法返回“个表示调用它的对象上的属性名列表的对象
(如果不带参数调用它，就表示该对象的所有属性)
返回的对象定义了4个布用的方法: taString(}、descriptors().hide()和show()
(function namespace(){ 11将所布逻辑闭包在一个私有函数作用域中
11这个数成为所有对象的方祛
function properties(] {
var names; 11寫性名组战的数组
.f (arguments.length== 0) 11所有的自有焖性
names := oject.getQwnPropertyNames(this);
else if (agument5.length== 1跟Array.isArray(arguments[0]))
昨guments[0]; 11名字组成的数组
na mes
'1参数列表本身就是名字
else
names= Aray'prototype.splice.call(axguments; );
11返四.个新的Properties对象，用以表示属性名字
return new Properties(this,names);
'1将它设置为0bject.prototpye的新的不可枚举的属性
/1这是从私有的数作用城导山的唯一一个值
Object.definepIoperty(Qbject.prototype,"propperties" ，{
value: properties,
第9章
246

---
enumerable: false,writable: true,configurable: true
});
咖
1这个构造函数是由上而的properties()函数所调用的
'1Pxoperties类表示一个对象的属性集合
function Properties(o,names}
11属性所属的对象
this.0= 0
!I 属性的名字
this,names = naes;
11将代表这些属性的对象设贸为不叮枚举的
Properties.prototype.hide= function()
vaI Q= this.o,hidden = {enumerable; false };
this.names.forEach(function(n)
if (o.hasDnnProperty(n))
bject.defineProperty(O,n,hidden);
});
Ieturn this;
);
11泞这些属性设置为只读的和不可配冠的
Properties.prototype.fIeeze= function() {
var o = this.O,frozen ={ Nritable: false,configurable: false };
this.nanes.forEach(function(n) {
if (o.hasOwnProperty(n))
bject.defhneProperty(o,n fxozen);
});
return this;
};
/1返回一个对象，这个对象是名宇圳每性描逃符的映射表
11使用它米复制属尘，遂同展性特性~起复制
1{ 咖ject.defineProperties(dest,src.pxoperties().descr1ptors());
Properties.prototype.descriptors= function() .
var 。= this.o,desc= {};
this.names.forEach (functlon(n) {
if (lo.hasQwnPIoperty(n)) retuin;
desc[n]= bject.getownPropertyDescriptor(o,n);
}};
return desc ;
};
11返回一个格式化良好的属性列表
1! 列表中包含名字、值和国性特性，使用"permanent"表示不可配置
1! 使用"readonly"表示不可写,使用"hidden"表示不可枚爷
!/ 普通的可放举、可写和可配髀撼性不包含特性列表
Properties.prototype.toString= function() {
;五、
vaI o= this.o; 1! 在下面嵌套的函数中使用
var lines = this.names.map(nameToString) ;
return"{\n" + lines.join(";\n") +"\n}";
function nameToString(n}
desc= bject.get0unPropertyDescriptor(o; n) ;
V打$ =”
1f (!desc) return"nonexistent " + n + ": undefined";
if (ldesc.configurable) s +="permanent "
类和模块
|247

---
if ((desC.get & ldesc.set) I1Idesc.witable) s 如"readonly";
if (idesc,enumerable) s +"hidden .
if (desc.get || desc.set) s + '
"accessor“+ 1
else s 七n +“:“+ ((typeof desc,value=== "function") ?"function"
desc.value);
return 5
};
11最后，将原犁对象中的实例方法设置为不可收举的
11这里用到了刚定义的方法
Pxoperties.pIototype.properties().hide() ;
}{)); 11立即执行这个匿名函数  

##  9.9 模块  

将代码组织到类中的一个重要原因是，让代码更加
“模块化”，可以在很多不同场最巾
实现代码的重用。但类不是唯一的模块化代码的方式。一般来讲，模块是一个独立的
JavaScript文件。模块文件可以包含一个类定义、一组相关的类、一一个实用函数岸或者是
一些待执行的代码。只要以模块的形式编写代码，任例JavaScript代码段就可以当做一个
模块革往13。
JavaSctipt中并役有定义用以支持榄块的语盲结构(但imports和exports的
确是JavaScript保留的关键字，因此JavaScript的未来版本可能会支持)，这也意味省在
JavaScript中编写模块化的代码更多的是避循某一种编码约定。
很多JavaScript库和客户端编程框架都包含一些模块系统。比如，Dojo工具包和Google的
Closure库定义了provide()和require()函数，用以声明和加裁模块。并且.CommonJS
服务器端JavaScript标准规范(参照http://commonjs.org 

) 创建了一个模块规范，后者同
样使用require()函数。这种模块系统通常用来处理模块加载和依赖性管埋，这些内容
已经超出本书的讨论范围。如果使用这些框架，则必须按照框架提供的模块编写约定来
定义模块。本节仅对模块约定做一些简单的讨论。
模块化的目标尼支持人规模的程序开发，处理分散源中代码的组装，并且能让代码正确
运行，哪怕包含了作者所不期望出现的模块代码，也可以正确执行代码。为了做到这一
点不向的模块必须避免修改全局执行上下文，因此后续模块应当在它们所期望运行的
泽往14.
这实际上意味著模块应当尽叮能少地定义全局
原始《或接近原始) 上下文中执行
译注13: 作者这里的表还是囿绕“模块是一个可重用的代码片段* 这一观念的。不论是从代码语
法结构上寄耦，还是将代码拆分至不同的丈件中，只要用某种方法将代码“分离”，就
认为是一个模块，国此作者说任何代码都可以处理为一个模块。
译注14: 这里的“原始上下文" 是指调用模块时所在的上下文，可能处在一个很深的闭包当中，
但这个模块的逻释不应试影响到共他的上下文特别是全局上下文,
第9章
248
---
标训，理想状猊是，所有模块都不应当定义超过一个(全局标识)。接下来我们给出的
一种简单的方关可以做到这。点。你会发现在JavaScrip中实现一个模块代码并不困难;
啡
在本书中很多示例代码都用到了这种技术。  

###  9.9.1 用做命名空间的对象  

在模块创建过租中避专染全局变量的一种方法是使用一个对象作为命名空间。它将咱
数和值作为命名空间.泉属性存储起来(可以通过全局变量引用)，而不是定义全局函
数利变量。拿例9-6的Set类求说,它定义了一个伞局构造函数Set()。然后给这个类定义
了很多实例方法，但将这些实例与祛存储为Set.prototype的属性，因此这些方法不是全
局的。示例代码也包含一个_v2s()工具凼数; 但也没有定义它为全局函数，而是把它存
储为Set的属州。
接下来看一下例9-16，这个例子定义了很多抽象类和非抽象类。每个类都只包含一个
企局标训，但整个模块[这个JavaScript文件) 定义了很少的全局变量。基于这种“保持
干净的全局命名空间”的观点，一种更好的做法是将“集合”类定义为一个单独的全局
对象:
ar sets = {};
这个sets对象是模块的命名空间，并且将每个“集合”类都定义为这个对象的属性:
sets.5ingletonSet= sets.AbstractEnumerableSet.extend(...);
如果想使用这样定义的类，需要通过命名空间来调用所需的构造函数:
var 5= new sets.SingletonSet(1};
模块的作者并不知道他的模块会和哪些其他模块一起工作，因此尤为往意这种命名空问
的用法带来的命名冲突。然而，使用这个模块的开发者是知道它用了哪些模块、用到了
哪些名字的。程序员并不一定要严格遵守命名空间的写法，只宿将常用的值“导人”到
全局命名空间中。程序员如果要经常使用sets命名空间中的Set类，可以这样将它导人:
'I 将5et导人到垒局命名空间巾
var 5et = sets.5et;
11这样每饮使用它就不必加set前缀了
vat 5= new Set(1;2j3);
有时模块作者会使用更深层嵌龚的命名空间。如果sets模块是另外一组更大的模块集仓
的话，它的命名空间可能会是collections.sets,模块代码的开始会这样写:
11声明(或重新声明)这个全局变量
var collections;
if (!collections)
11如果它疏本不存在
1l 创建一个顶层的命名空间对象
collections= {};
11将sets命名空间创建在它的内部
collections.sets = {
类和模块
249

---
l1在collections.sets内定义set癸
collectlons.sets.AbstractSet= functian{){...}
最顶层的命名空问往往用来标识创建模块的作者或组织，并避免命名空间的命名冲突。
比如，Google的Closure库在它的命名空间googstructs中定义了Set类。每个开发者都反
转瓦联网域名的组成部分; 这样创建的命名空间前级是全局唯一的，一般不会被其他模
块作者采用。比如我的网站悬davidflanagan.com 

,我可以通过江拿命名空间来发布我的
sets榄块; com.davidflanagan.clooectinos.sets.
使用很长的命名空间来导人模块的方式非常重要，然而程序员往往将整个模块导人余局
命名空间，而不是导入(命名空间中的某个) 单独的类。
var sets = com,davldnanagan.collections.sets;
按照约定，模块的文件名应当和命名空间匹配。sets模块应当保存在文件sers.js中。如
果这个模块使用命名空间collections.sets,那么这个文件应当保存在目录collecions下
(这个目录还应当包含另一个文件maps.js)。并且使用命名空间com.davidflanagan.
colections.sets的模块应当在文件comidavidflanaganlcollectionsisets.js中.  

###  9.9.2 作为私有命名空间的函数  

模块对外导出一些公用API,这些API是提供给其他程序员使用的，它包括函数、奖、属
性和方法。但模块的灾现往往需要一些额外的铺助闲数和方法，这些函数和方法并不需
要在模块外部可见。比如，例9-6中的Set._v2s()函数，模块作者不希望Set类的用户在
某时刻调用这个函数，因此这个方祛最好在类的外部是不可访问的。
可以通过将模块(本例中的Set类) 定义在某个函数的内部来实现。正如8.5节所揣述的
一样，在一个函数中定义的变量和函数都属于函数的局部成员，在函数的外部是不可
见的。实际上，可以将这个函数作用域用做模块的私有命名空间(有时称为“桢块函
数”)。例9-24展示了如何使用“模块函数”来奕现Sel类:
例9-24: 模块函数中的Sel类
11声明全局变量Set,使用一个函数的返叫值给它斌值
11的数结束时紧跟的一对圆括号说助这个函数定义后立即执行
1它的返回值将赋值给Set,而不是将这个函数赋值给Set
/1注意它悬个函数表达式，不是-条语旬，因此函数"invocation"并没有创建全局变量
ar 5et= {function invocation() {
function Set(}{ 11这个构造函数是局部变量
this.values = {};
11这个对象的属性州来保存这个集命
11集合中值的个数
this.n- 0;
this.add.apply(this,argunents); 1/ 将所有的参数都添加垒集合中

---
11给Set.prototype定义文例方祛
11这里省路了详细代码
a码
Set.prototype.contains = function(va1ue) {
l1往总我们调月了v25(),而不是调附带有笨爾的前缀的set._v2s()
return this.values.has0wnPIoperty(v2s(value);
function(}{ rcturn this.n; };
set.prototype.size
Set.prototype.add= function()
Set.prototypc.remove = function(){ /*...*/ };
biw
Set.prottype.foreach= function(f,context){ /*...*/ };
1! 这里是上，面的方法用到的一些辅助函数和变盘
它f]不属于模决的共有API,但它们都隐蔑在这个闲数作用城内
11状此我们不必将它们定义为5et的属性或使用下划线作为比前级
function v25(va1) {1*...*{ }
function ojectId(o}{ 1*...*1}
war nextId = 1;
/1这个模块的共有API是Set()构造函数
11我们需吸把远个函数从私有命名空间中导出来
11以更丕外部也可以使用它，在这种情况下，我们通让返回这个构造函数来导出它
11它变成第一行代码所指的表达式的直
return Set;
}()); !! 定义用数后立明执行
注意，这里使用了立印执行的匿名雨数，这在JavaScript中是一种惯用法。如果想让代
码在一个私有命名空间中运行，只须给这段代码加F前缀“(function(){“和后缀”}
0)]”。开始的左囫括号确保这是一个函数表达式，而不尾因数定义语句，因此可以给该
前缀忝加一个函数名来让代码变得更加清晰。在例9-24中使用了名字“invocation”，用
以强调这个函数应当在定义之后立即执行。名宁“namespace? 也可以用枣强调这个函
数被用做命名空间。
一旦将模块代码封装进一个函数，就需要一些方祛导出其公用AP1，以便在模块两数的
外部调用它们。在例9-24中，模块函数这回构造函数，这个构造函数随后斌值给一个全
局变昼。将值返回已经清楚地表明API已经导出在函数作用域之外。如果模块API包含多
个单元，则它可以返回命名空间对象。对下sets模块来说，可以将代码写成这样:
11创建一个仝局变盘川来存放集合相关的模块
var collections;
(lcol1ections) collections = {};
/1定义sets模块
co1lections.sets= (function namespace() {
/1在这里定义多种“集合"类、使用局部变丘和瓯敷
/---这里省路很多代码.....
11通过返回命名空间对象将API导出
return {
l1导出的属性名; 局部变敏名字
AbstractSet: AbstractSetj
类和模块| 251

---
Notset: Notset,
AbstractEnumerableSet; AbstractEnumerableSet,
SingletonSet: SingletonSet,
AbstractWrItableSet :AbstractNritableset,
AraySet: ArraySet
}());
另外一种类似的技术是将模块函数当做构造凼数，通过new来调用，通过将它们详让1赋
值给this来将其导出择注16:
var collections;
if (Icollect1ons} collectians= {};
collections.sets= (new function namespace() {
/1".这里省略很多代码......
11将API长出至this对象
this.AbstractSet = AbstractSet;
this.NotSet = NatSet;
!--...
11社意，这里没有返回值
}());
作为一种替代方案，如果已经定义了全局命名空间对象，这个模块凼数可以直接设凳那
个对象的属性，不用返回任何内容:
var collections;
f (Icollections) co1lections= {};
collections,sets ■{};
(function namespace()
11...这里省略很多代码.....
11将共用API导出到上面创尴的命名空间对象上
collections,sets.AbstractSet " AbstractSet;
collections.sets.NotSet= NoatSet; 11....
11导出的操作已经执行了，这甲不需要再"etun诵句J
}());
有些框架实现了模块加载功能，其中包括其他一些导出模块API的方法，比如，使用
provides(}幽数来往册其API,提供exports对象评注17用以存储模块API。由于JavaScript
日前还不具备模块管理的能力，因此应当根据所使用的框架和工具包来选择合适的模块
创建和导出API的方式。
译注15: 这里作者所说的“它们”是指构造函数创建的断实例。
译注16: 使用构遥函敷和模块函数来实现私有成员的原理是一模一样的，只是调用的方式不一样。
译注l7: 可以 ;参照CommouJS规 范htp:/commnjis org.
第9章
252