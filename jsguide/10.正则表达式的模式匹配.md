## [第10章 正则表达式的模式匹配](https://github.com/qianjilou/itbookshelf/tree/master/jsguide)  
###  [10.1 正则表达式的定义](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.md#101-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89)
###  [10.2 用于模式匹配的String方法](https://github.com/qianjilou/itbookshelf/blob/master/jsguide/10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.md#102-%E7%94%A8%E4%BA%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84string%E6%96%B9%E6%B3%95)
###  [10.3 RegExp对象]
---
第10章
正则表达式的模式匹配
正则表达式(regular expression) 是一个描述字符榄式的对象。JavaScript的RegExp类表
示正则表达式，String和RegExp都定义了方张，后者使历正则表达式进行强大的模式匹
配和文率检索与替换功能。JavaScript的止则表达式语法是Perl5的正则表达式语祛的大
型下集，所以对于有Per1编程经验的程序员来说，学爿JavaScript中的正则表达式庄!是小
菜一碟。
本章首先介绍用以描述“文本模式* 的正则表达式语法。随后讲解广使用正则表达式的
String和RegExp方法。  

##  10.1 正则表达式的定义  

JavaScript中的正则表达式用RegExp对象表示，可以使用RegExp(}构造函数米创建
RegExp对象，不过RegExp对象更多的是通过一种特殊的直接量语祛来创延。就像通过
引号包襄字符的方式米定义字符串直接量一样，正则表达式直接量定义为包含在一对斜
杠(1) 之间的字符,例如;
var pattern = /s$/;
运行这段代码创建一个新的RegExp对象，并将它赋值给变星patteznis 这个特殊的
RegExp对象用来匹配所有以字母“s”结尾的字符串。用构造函数RegExp()也可以定义
个与之等价的止则表达式，代码如下:
有一些Per]正财表运式语法特性并不被BCMAScript支持。这些特性包括; s (单行模式)
注1Z
和x (扩展语法) 标记; \白、\e、\I: \u、\L、\U、\E、\Q< \A、\Z、\z和\C啭义字符;
“(?<=" 正向后行断言和“(?<1" 负向后行断言;“(?#”注释和扩展“(?”的语法。
..
253

---
var pttern " new RegExp("s$");
RegExp直接量和对象的创建
就像宇符串和数字一样，程序中每个取值相同的原始类型直接量均表示相同的位，
这是显而必见的。程序运行时每次遢到对象直接量(初始化表达式) 诸如{}和[]的
时候都会创建新对象。比如，如罘在橘环体中写var a= [],则每次遍历都会创建
一 个断 的 空 数 组。
正则表达式直接量则与此不同，ECMAScript 3规范规定，一个正则表达式直接
景会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接
量的每次运算都返回同一个对象。ECMAScript 5规范则做了相反的规定，同一
段代码所表示的正则表达式直接量的每次运箕都返回断对象。]E一直都是按照
ECMAScript 5规范实现的，多数最新版本的浏览器也开始逆循ECMAScript 5,尽
洋往1
管目前该标准并未全面广泛推行
正则表达式的模式规则是由一个字符序列组成的。包括所有字母和数字在内，大多数
的字符都是按照直接量仅捎述待匹配的字符的。如此说米，正则表达式/java/可以匹配
任何包含“java”子串的字符串。除此之外，正则长达式中还有其他具有特殊语义的字
符,这些字符并不按照字面含义进行匹配。比如，正则表达式/s$/包含两个字符，第一
个字符“s" 按照字面含义阢配，第二个字符$是一个具有特殊语义的元字符，用以阢配
字符串的结求。因此这个正则表达式可以匹配任何以“s”结束的宇符串。
译注1: 作者在这里揭示了一种非常容易忽略的情况，比如，这段代码在Firefox 3 .6和Firefox 4+
中的运行结采不一致:
function getRE(){..
var re= /[a-z]/;
e.foa ="bar";
return re;
var reg= getRE(),
re2= getRE ();
console.1og(xeg === rez); il 在Firefox 3.6H返回true,在Firefox 4+中返回false
console.1g{re2.foo); 11在Firefox 3,6中返叫"baz".在Firefox 4+中返回"bax"
原因可以在ECMAScript 5规范第24页和第247页找到，也就是说在ECMAScript 3规范
中，用正则表达式创建的RegExp对象会共享刚一个实例，而在ECMAScript 5中则是两个
独立的实侧。而最断的Firefox 4.Chrome和Safari 5都遵循ECMAScript 5标准。以至于
IE6~1E8都没有很好地遵街ECMAScript 3标准，不过在这个河题上反而处理对了。很明
显ECMA.Script5的规范更符合开发者的期望。
第10章
254

---
接下来的儿节会逃一步讲解JavaScript下则表达式中使用的各种字符和元字符。  

###  10.1.1 直接量字符  

正如上文提到的，正则表达式中的所有字母和数字都是按照宇面含义进行匹配的。
JavaScriptT则表达式语法也支梅非字母的字符匹配，这些字符需要通过反斜线(\) 作
为前缀进行转义。比如，转义字符\n用以匹配换行符。表10-1中列出了这些转义字符。
表10-1; 正则表达式中的直接量字符
字符
匹配
自身
字母和数字字符
\o
NUL 字符(u0000)
制表符(\u0009)
换行符(\u00OA )
\n
垂直制表符(\u000B)
\
换页符(\u000C )
\f
叫I车符(\u000D)
\tr
由十六逃制数nn指定的拉丁字符，例如，\x0A等价于\n
\xnn
由十六进制数:XX指定的Unicode字符，例如\u0009等价于\t
\uxxr
\cX
控制字符^X,例如;cJ等价于换行符\n
在正则表达式中，许多标点符号具有特殊含义,它们是:
^$。*+?a!:[\/{}[]{}
在接下来的几节里，我们将学习这些符号的含义。某些符号只有在正则表达式的某些上
下文中才具有某种特殊含义，在其他上下文中则被当成直接量处理。然而，如果想在止
则表达式巾使用这些字符的直接量进行匹配，则必须使用前缀\，这是一条通行规则。其
他标点符号(比如@和引号) 役有恃殊含义,在正则表达式中按照宇面含义进行匹配。
如果不记得哪些标点符号需要反斜线转义，可以在每个标点符号前都加上反斜线。另外
惴要往意，许多宁母利数字在有反斜线做前缀时也有特殊含义，所以对于想按照直接量
进行匹配的字母利数宁，尽量不要用反斜线对具转义。当然，要想在正则表达式中按照
直接量阢配反斜线本身,则必须使用反斜线将具转义。比如，正则表达式“NV" 用以匹
配任何包含反斜线的字符串。

###  10.1.2 字符类  

将直接量字符单独放进方括号内就组成了字符类(character class)。一个字符类可以匹
配它所包含的任意字符。因此，正则表达式/[abc]/就和字母“a”，“b”、“c" 中的
任意一个都匹配。另外，可以通过“A”符号來定义否定字符类，它匹配所有不包含在方
括号内的字符。定义否定字符类时，将一个“^。符号作为左方括号内的第、个字符。正
则表达式/[^abc]/匹配的是“a”、“b”、“c" 之外的所有字符。字符类叮以使用连字符
来表示字符范围。要匹配拉丁“字母表中的小写宇母，叮以使用/[a-z]/,要匹配拉丁字母
表中任何字母和数字; 则使用/[a-zA-ZO-9]/。
由于某些字符类非常常用。因此在JavaScript的正则表达式语法中，使用了这些特殊宁符
的转义字符来表示它们。例如、\s匹配的是空格符、制表符和其他Unicode空白符，\5匹
配的是非Unicode空白苻的字符。表10-2列出了这些宇符,开且总结了字符类的语祛(往
意,有些字符类转义宇符只能匹配ASClI宇符，还役有扩展到可以处理Unicode字符,但
可以通过十六进制表示方法来显式定义Unicode字符类，例如，/[\u0400-\u04FF]/用以
匹配所有的Cyilli符评江2)
表10-2: 正则表达式的字符类
字符
匹配
[...] 方插号内的任意卞符
[^..] 不在力括号内的任意宁符
除换行符和其他Unicode行终止符之外的任意字苻
任何ASCI宇符组成的单词,等价于[a-zA-ZD-9]
任何不是ASCI字符组成的单词，等价丁[^a-zA~-Z0-9]
任何Unicode空白符
S
任何非Unicode空白符的字符，往意\w利\5不同
任何ASCI数字，等价十[0-9]
\(
除「ASCI数字之外的任何字符，等价f[^0-9]
D
退格直接量(特例)
[\b]
往意，在方括号之内也可以写这些特殊转义宇符。比如，由于\s心配所有的空白宇符,
\d匹配的是所有数字，因此/[\s\d]/就匹配任意空白符或者数字。往意，这里有一个特
例。下面我们将会看到转义符\b具有的特殊含义，当用在字符类中时，它表示的是退格
符。所以要在止则表达式中按照直接盘表示一个退格符，只器要使用具有一个元素的字符
类/[\b]/.
译注2: Cyrilli宇符是一种斯拉夫语字母; 请参照: http://er.wikipedia 

 org/wiki/Cyrillic_alphabel。

###  10.1.3 重复  

新会
用刚刚学过的正则表达式的语法，可以把两位数描述成Ad\d/，凹位数描述战入\dd\d/。
但到目前为止，还没有一种方法可以用来描述任意多位的数字,或者描述由三个字母和
一个数字构成的字符串。这些正则表达式语法中较为复杂的模式都提到了正则表达式中
某元素的“重复出现次数”。
我们在正则模式之后跟随用以指定字符重复的标记。由于某些重复种类非常常用，囚此
就有一些专门用了表示这种情况的特殊宇符。例如，“+”用以匹配前一个模式的- 个
或多个副本。表10-3总结了这些表示重复的正则语祛。
表10-3; 正则表达式的重复字符语法
字符‘含义
匹配前一项至少n次,但不能超过m次
{n,m}
匹配前一项n次或者更多次
{n,}
{n}
匹配前一项n次
匹配前一项0次或者1次,也就是说前一项是可选的，等价于{o,1}
匹配前一项1次或多次，等价于{1,}
匹配前~项0欲或多次，等价丁{o,}
这里有一些例f;
/d{2,4}/ 11匹配2~4个数字
/\w{3}\d?! 11精确匹配三个单词和一个可选的数宁
/s+java\s+! 11匹配前后带有一个或多个空格的宇符串"java"
l' TBs
/[^{j*/
/1匹配:个或多个非左括号的牛符
在使用“*”和“?”时要往意，由于这些字符可能匹配0个字符，因此它们允许什么都不
匹配。例如，正则表达式/a*/实际上与字符串“bbb”匹配; 因为这个字符串含有0个a。
非贪婪的重复
表10)-3中列出的匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续
匹配。因此，我们称之为“贪娑的”匹配。我们同样可以使用正则表达式进行非
负婪阢配。只须任待阢配的字符后眼随一个问号即可:“??”、
“{1,5}?"。比如，正则农达式/a+/可以匹配一个或多个连续的字母a。当使用“aa"
作为匹配字符申时，正则表达式会匹配它的三个字符。但是/a+?也可以匹配一个或多
个连续字母a，但它是尽可能少地匹配。我们同样将
作为匹配字符串，但坛一个
"aaa'
模式只能匹配第一个a。
正则表达式的模式匹配] 257

---
使用非贪婪的匹配模式所得到的结果叮能和期望并不-致。考虑以下正则裘达式
/atb/,它可以匹配一个或多个a，以及-个b。当使用“aab" 作为匹配字符串时，它会
匹配整个宁符串。现在再试一下非贪婪匹配的版本/a+?b/,它匹配尽可能少的a和一个
b。当用它米匹配“aab”时，你期望它能匹配一个a和最后一个b。但实际上，这个模式
却匹配了整个宇符串，和该模式的贪婪匹配一模一样。这是因为正则表达式的模式匹配
总是会寻找宇符串中第一个可能匹配的位置。出于该匹配是从字符串的第一个字符开始
的，因此在这里不考虑它的子串中更短的匹配。
10.1.4 选择、分组和引用
正则表达式的语祛还包括指定选择项.子表达式分组和引用前一子表达式的特殊宇符。字
夺“I”用于分隔供选择的字符。例如，/ablcd|ef/可以匹配宇符串“ab”，也可以匹配字
符申“cd”，还可以匹配字符审“ef”。八d{3}|[a-z]{4}/匹配的是三位数字或者四个小
写字母。
注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹
配，就忽略右边的匹配项，即使它产生更好的匹配。因此，当正则表达式/alab/匹配宇
符串“ab" 时，它只能匹配第一个字符。
正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以
像处理一个独立的单元那样用“|"、“*”、“+”或者“?”等来对单元内的项进行处理。
例如，/java(script)?/可以匹配宇符串“java”，其后可以有“script”也可以役有。1(ab]
cd)+|ef/可以匹配宇符串“ef”，也可以匹配宇符串“ab" 或“cd" 的一次或彩次重复。
在正则表达式中，圆括号的另一个作用是在完整的模式中定义了模式。当一个正则表达
式成功地和目标宇符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的
部分(我们将在本章随后的部分中看到如何取得这些匹配的子串)。例如，假定我们
正在检索的模式是一个或多个小写宇母后面跟随了一位或多位数字，则叮以使用模式
/[a-z]+\d+/。但假定我们真正关心的是每个匹配尾部的数字，那么如果将模式的数字
部分放在拓号中(/[a-z]+(\d+)/),就可以从检索到的匹配中抽取数字了，之后我们会
有详尽的解释。
带圆括号的表达式的另--个用途是允许在同一正则表达式的后部引用前面的子表达式。
这是通过在字符“\”后加一位或多位数字来实现的。这个数宇指定了带圆括号的子表
达式在正则表达式中的位置。例如，\1引用的是第一个带圆括号的子表达式，\3引用的
是第三个带圆括号的子表达式。往意，因为子表达式可以嵌盒另一个子表达式，所以它
的位置是参与计数的左括号的位置。例如，在下面的正则表达式中，嵌套的子表达式
([Ss]cript) 可以用\2来指代:
/([Jj]ava([Ss]cript)?)\sis\s(fun\w*}/
对正则农达式中前一个「农达式的引用，并不是捐对「表达式模式的引用，而指的是与
那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个
单独部分包含的是完全相同的卞符。例如，下面的正则表达式匹配的就是位于单引号或
观引号之内的0个或多个学符。但是，它并不要求左侧和右侧的引号匹配(即，加人的
两个引号都是单引号或都是双引[号) :
/[""J[^**]*['"]/
如果婆匹配左侧和右侧的引号，可以使用如下的引用:
/(["])[^**]*1/
\I匹配的足第一个带圆括号的「表达式所匹配的模式。在这个例了中，存在这样一条约
束，那就是左侧的引号必须和右侧的引[号相匹配。正则表达式不允许用双引兮括起的内
容中有单引号，反之亦然。不能在宇符类中使用这种引用，所以下面的写法是非祛的;
/([""])[^\1]*\1/
在本章随后儿节中，我们会寿到:种对带圆括号的「表达式的引用，这是正则找达式的
检索利替换操作的强大特性之..-
同样,在止则表达式中不用创建带数字编码的引用，也叮以对子表达式进行分组。它不足
以“(”和“)”逃行分组，而足以“(?:" 利|“)”来进行分组，比如，考虑下面这个模式:
/([Jj ]ava(?; [$s]cxipt)?)\sis\s(fun\w*}/
这里，子表达式(?:[Ss]cript)仅仅用十分组，因此复制符号”?”可以应用到各个分组。
这种改进的圆括号并不牛成引用，所以在这个下则表达式中，\2引用「与(fun\W*)匹配
的文本。
表10-4 对正则表达式的选择，分组和引用运算符儆了总结。
表10-4: 正则表达式的选择、分组和引用字符
字符; 含义
选择，匹配的是该符号左边的子衣达式或右边的子表达式
(...) 组合，将儿个项组合为一个单元,这个单元可通过“*”、
*?”和“I
系符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用
{?:...只组合，把项组合到--个单汇，但不记亿与该组相匹配的宁符
和第n个分组第一次匹配的字符相匹配，组是圆挢号中的子表达式(也有可能是嵌
n
套的)，组索引是从左到右的系括号数，
形式的分组不编码
(7:

###  10.1.5 指定匹配位置  

正如前面所介绍的，正则表达式中的多个元素才能够匹配宇符串的.个宁符。例如，
\s匹配的只是一个空白符。还有一些止则表达式的元素匹配的是字符之间的位宵，而不是
实际的字符。例如，\b匹配‘个单词的边界，即位于\w (ASCII单词) 字符和\W (非ASCII
单词) 之间的边界，或位于一个ASCI单词与字符中的开始或结尾之间的边界出2。像\b
这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元
素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。最常用的锱元
素是^，它用来匹配宇符串的开始，锚元素$用以匹配字符串的结束。
例如，要匹配单词“JavaScript”，可以使用正则表达式/^JavaScript$/。如果想匹配
“Java”这个单词本身(不像在“Java$cript*" 中作为单词的前缀)，可以使用正则表达
式A8Uavas/; 可以匹配前后都有空格的单词“]ava”。但是这样做有两个问题，第。.
如果“Java" 出现在字符串的开始或者站尾，就匹配不成功，除非开始利结尾处各有一
个空格。第二个问题恳，当找到了与之匹配的字符申时，它返回的匹配字符串的前端
和后端都有空格。这并不是我们想要的。因此我们使用单词的边界\b来代替真正的空格
符\s进行匹配(或定位)。这样正则表达式兢写成J/\b] ava\bl。元素\B将把阢配的
锚点定位在不是单词的边界之处。因此，正则表达式八[Ss]cript/与“JavaScript”和
“postscript”匹配; 但不与“script”和“Scripting”匹配=
征意正则表达式部可以作为锚点条件。如果在符号“(?=" 和“)”之间加人一个表达
式，它就是一个先行断言，用以说明圆括号内的表达式必须正确匹配中让3，但并不
是真正意义上的匹配。比如，要匹配一种常用的程序设计语言的名字，怛只在其后
有臂号时才匹配，可以使用/[Jj]ava([Ss]cr1pt)?(?=\:)/。这个正则表达式可以匹
配“JavaScript: The Definitive Guide”中的“JavaScript”，但是不能匹配“Java in a
Nutshcll? 中的“Java”，因为它后面没有冒号。
带有“(?!”的断言是负向先行断言，用以指定接下来的字符都不必匹配。例如，
/]ava(?! Sczipt)([A-Z]\w*)/叫[以匹配“Java”后跟随-个火写字母和任意多个
ASCII单词，但Java后面不能跟随“Script”。它叫以匹配“JavaBeans”，但不能匹配
“Javancse" ，它可以匹配“JavaScripl”，但不能匹配“JavaScripter”。
表10-5总结了正则表达式中的锚。
除了在字符类(方括号) 中，、b匹配这格符。
注2:
译注3: 原书此处有误，“(?=" 和“)”之间的表达式只用乎指定一个位置。它是零宽的，这里提
到的“断言”通常也称为“零宽断言”。
第10章
260

---
表10-5: 正则表达式中的锚字符
字符
含义
匹配宇符串的开头，在多行检索巾，匹配一行的开头
匹配字符串的结尾，在多行检索中，匹配一行的结尾
匹配一个单词的边界，简育之,就是位于宁符\w和\W之间的位置,或位于宁符\w
b
和字符串的开头或者结尾之间的位置(但需娶注意，[\b]匹配的是退格符)
匹配非单词边界的位置
B
(?=p) 零宽下向先行断言，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符
(?!p)_ 零宽负向先行断言，要求接下来的宁符不与p匹配  

###  10.1.6 修饰符  

形则表达式中的语法还有最后一个知识点，即止则表达式的修饰符,用以说明高级匹配
模式的规则。和之前讨论的下则表达式语法不同，修饰符是放在“1”符号之外的，也就
是说，它们不是出现在两条斜线之间，而是第二条斜线之后。JavaScript支持三个修饰
符,修饰符“i" 用以说明模式匹配是不区分大小写的。修饰符“g”说明模式匹配应该
是全局的，也就是说，应该找出被检索宇符用巾所布的匹配。修饰符“m”用以在多行模
式巾执行匹配，在这种模式下，如果待检索的宇符申包含多行，那么^和$锚字符除了匹配
整个字符串的开始和结尾之外，还能匹配每行的开始和结尾。比如正则表达式/java$/im
可以匹配“java”也可以匹配“Java\nis fun”。
这些修饰符可以任意组合，比如，要想不区分大小写匹配宇符申中的第一个单词
“java”(“Java”或“JAVA”等)，可以使用不x分火小写的修饰符来定义正则表达
式/bjava\b/i。要想匹配字符串中所有的单词，则需要舔加修饰符g :/bjava\b/gi。
表10-6对止则表达式的修饰符做了总结，往意，在本章的后续内容中还会介绍在String和
RegExp的方祉中使用修饰符g的示例。
表10-6: 正则表达式修饰符
字符含义
执行不区分大小写的匹配
执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第--个之后就停E.
多行匹配模式，*匹配一行的开头和字符用的开头，$匹配行的结束和字符串的结束  

##  10.2 用于模式匹配的String方法  

到目前为止，尽管本章已经讨论过创建正则表达式的语法，但还没有尝试过如何在
JavaScript代码中使用这些止则表达式。本节将计论String对象的一些用以执行正则表达
式榄式匹配和检索替换操作的方法，后续几节还会继续讨论如何使用JavaScript正则表
达式的模式四配，不过将侧重于RegExp对象和它的方法及属性。往意，下面的讨论只
是与正则表达式相关的方法和属性的概述。同样，可以在本书第三部分中查找到完整的
介绍。
String支持4种使用正则表达式的方法。最简单的足search()。它的参数是一个正则表达
式，返回第，个与之匹配的了串的起始位置，如果找不到匹配的子串，它将返叫一1。
比如，下面的调用返回值为4:
"]avaScript".seach(/script/i);
如果search()的参数不是正则表达式，则首先会通过RegExp构遣囟数将它转换成正则表
达式。search()方法不支掩籴局检索，因为它忽洛正则表达式参数中的修饰符g。
replace()方法用以执行检崇与替换操作。其中第个参数是一个正则衣达式，第二个
参数是要进行替换的宁符串。这个方法会对调用它的宁符串进行检索，使用抬定的榄式
来匹配。如果止则表达式中设置「修饰符g，那么源字符串中所有与模式匹配的子串都将
替换成第=个参数指定的字符串; 如果不带修饰符g，则只替换所匹配的第一个子串。如
果replace()的第一个参数是字符串i而不是正则表达式，则rep1ace()将直接搜索这个字
符串，而不是像search()--样首先通过RegExp()将它转换为正则表达式。比如，可以使
用下面的方法，利用replace()将文本中的所有javascript (不区分大小写) 统一替换为
"JavaScript”;
11将所有不区分火小写的javascript都替换成大小写正确的JavaScript
text.replace(/javascript/gi;"JavaScript") ;
但replace()的功能远不止这些。回忆一下前文所提到的，止则表达式中使用圆拓号括
起来的子表达式是带有从左到右的索引编号的，而且止则表达式会记忆与每个子表达式
匹配的文本。如果在赫换字符串中出现了$加数字，那么replace()将用与指定的了丧达
式相匹配的文本来替换这两个字符。这是一个非常有用的特性。比如，可以用它将一个
宁符串中的英文引号替换为中文半角引号;
11一段引用文本起始于引号，结米于引号
/1中问的内容区域不能包含引号
var quote = /"([^"]*)"/g;
/1用中文半角引号替换英文引号，同时要保持引号之间的内容(存诸在$中) 没有被修改
text.replace(quote,'*$1"' };
replace()方法还有-些其他重要特性，这些特性将在本书第三部分关于string.
replace()的卡题页中进行介绍。最值得往意的足，replace()方法的第二个参数可以是
函数，该函数能够动态地计算巷换字符串。
262| 第1C章

---
matth()方法是最常用的String止则表达式方法。它的唯一参数就是一个止则表达式(或
通过RegExp()构造函数将其转换为正则表达式)，返回的是一个由匹配结果组成的数
组。如果该正则表达式设置了修饰符g，则该方法返回的数组包含字符串巾的所有匹配
结果。例如:
"1plus 2 equal5 3".match(/\d+/g) 11返回["1","2";“3"]
如果这个止则表达式役有设置修饰符y,match()就不会进行企局检索，它只检索第~个
匹配。但即使match()执行的不是全局检索，它也返回“个数组。在这种情况下，数组
的第一个元素就是匹配的宇符串,余下的元素则是正则表达式中用阈括号挢起米的子表
达式。因此，如果match(}返回一个数组a，那么a[0]存放的是完整的匹配，a[1]存版的
则是与第一个用圆括号括起来的表达式相心配的子冉，以此类推。为了和方法replace()
保持一致，a[门]存放的是$n的内容。
例如，使用如下的代码来解析-.个URL;
var url= /(\wt);\/\/([\w.]+)\/(\S*)/;
_'
var text = "Visit my blog at http://www.example.com/~david 

";
var result = text.match(ur1);
if (result 1= null)
var ful1ur1
[0]; 11包含"http://www.example.com/~david 

"
result
var protocol = result[ 1]; 11包含"http"
vaT host = result [2] ;
11包含“wWW.txample.com 

"
11包含'david"
var path = result[3] ;
值得往意的是，给宇符串的match()方法传人一个非全局的正则表达式，实际上和给这
个正则表达式的exec()方法传人的字符串是一模一样的，它返回的数组带有两个属性:
index和input,接下来对exec() 方法的讨论中会提到:
String对象的最后一个和正则裁达式相关的方祛是split()。这个方法用以将调用它的字
符串拆分为一个子串组成的数组，使用的分隅符是split()的参数，例如;
"123,456,789".split(","); 11返回["123","456"."789"]
sp1it()方法的参数也可以是一个正则表达式，这使得sp1it()方祛异常强大。例如，可
以指定分隔符，允许两边可以留有任意多的空白符:
“1,2,3,4,5".split(/\s*,\s*/}; 11返回["1""Z","3","4","5"]
split()方法还有其他一些特性，本书第三部分有关子String.split()更详尽的说明。  

##  10.3 RegExp对象  

正如本章开始所讲到的，正则表达式是通过RegExp对象来表示的。除「RegExp()构造函

数之外，RegExp对象还支持三个方法和一些属性。接下来的两节会对RegExp模式匹配
方法和属性展开讲述。
RegExp()构造函数带有两个字符串参数，其中第二个参数是可选的，RegExp()用以创建
新的RegExp对象。第一个参数包含正则表达式的主体部分，也就是正则表达式直接最
中两条斜线之间的文本。需要注意的是，不论是字符串直接量还尽正则表达式，都使
用u!”宁符作为转义宁符的前缀，因此当纷RegExp(传人一个字符串表述的正则衣达式
时,必须将“\" 替换成“\”。RegExp()的第二个参数是可选的，如果提供第二个参数，
它就指定正则表达式的修饰符。不过只能传入修饰符g、i.m或者它们的组合。比如:
! 全励匹配宇符率中的5个数字,往意这里使用r"\\"，而不是"\"
zipcode= new RegExp("\\d{5}","g");
ar
RegExp()构造函教非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往
没办法通过写死在代码中的正则表达式直接量来实现。例如，如果待检索的宇符串是由
用户输人的，就必须使用RegExp()构造函数，在綦序运行时创建正则表达式单4。
10.3,1RegExp的属性
每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的
文本。属性g1obal是一个只读的布尔值，用以说明这个正则表达式是否带有修饰符g。
属性ignoreCase也是一个只读的布尔值，用以说明正则表达式是否带有修饰符i。属性
multiline是--个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性
lastIndex,它是一个可读/写的整数。如果匹配模式带有g修饰符，这个属性存储在整个
字符串中下一次检索的开始位馔，这个属性会被exec()和test()方法用到,下面会讲到。  

###  10.3.2 RegExp的方法  

RegExp对象定义了两个用于执行模式匹配操作的方法。它们的行为和上文介绍过的
String方祛很类似。RegExp最主要的执行模式匹配的方让是exec(),它与10.2节介绍过
的String方祛match()相似，只是RegExp方法的参数是一个字符串，而String方法的参数
是一个RegExp对象。exec()方法对一个指定的字符串执行一个正则表达式，简言之，
就是在一个字符串中执行匹配检索。如果它没有找到任何匹配，它就返回null,但如果
它找到了一个匹配，它将返回一个数组，就像match()方法为非全局检索返回的数组一
样。这个数组的第一个元素包含的是与正则表达式相匹配的字符串，余下的元素悬与囡
括号内的子表达式相匹配的子串。属性index包含了发生匹配的字符位置，属性input引
用的是正在检索的字符串。
译注4: 其实通过eval()也可以实现运行时动态创建正则表达式，但不推荐使用cval)。

和match()方法不同，不管正则表达式是否具有全局修饰符g，exec()都会返回‘样的数
组。回忆一下，当match()的参数基一个仝局正则表达式时，它返回由匹配结果组成的
数组。相比之下，exec()总是返回一个匹配结果，并提供关于本次匹配的完整信息。当
调用exec()的正则表达式对象具有修饰符g时，它将把当前正则表达式对象的lastIndex
属性设置为紧挨着匹配子串的字符位置。当同一个正则表达式第二次调用exec()时，它
将从lastIndex属性所指示的字符处开始检索。如果exec()没有发现任何匹配结果，它
会将1astIndex亚置，为0 (在任何时候都可以将1astIndex厮性设置为0，每当在字符申
中找最后一个匹配项后.在使用这个RegExp对象开始新的宇符申查找之前，都应当将
lastIndex设霞为0)。这种特殊的行为使我们可以在用正则表达式匹配字符串的过程中
反复调用exec(),比如:
vat pattern n /Jv/g;
var text = "JavaScript is more fun than Java!";
var result;
While((result = pattern.exec(text)) !四null) {
alert('Matthed'" + result[o] +"'n +
.result.index
at.position
next search begins at " + pattern.lastIndex) ;
另外一个RegExp方法是test()，它比exec()更简单-些。它的参数是一个字符串，用
test()对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回true:
vaI pattern= /java/i ;
pttern.test("JavaScript"); !! 返回true
调用test()和调用exec()等价，当exec()的返四结果不是nu1l时,test()返@true.由
于这种等价性，当一个全局正则表达式调用方法test()时，它的行为和exec()相同，因
为它从lastIndex指定的位置处开始检索某个宇符串，如果它找到了一个匹配结果。那么
它就立即设置1astIndex为当前匹配子串的结束位置。这样一来，就可以使用test()来遍
历字符书，就像用exec()方法一样。
与exec()和test()不同，String方法search()、replace()和match()并不会用到lastIndex
属性。实际上，String方化只是简单地将1astIndex属性值重置为0。如果让一个带有修
饰符g的正则表达式对多个字符申执行exec()或test(}.要么在每个字符串中找出所有
的匹配以便将lastIndex自动重置为零，婆么显式将lastIndex手动设置为0 (当最后一
次检索失败时需婪手动设置lastIndex)。如果忘了手动设置lastIndex的值，那么下
一次对新字符串进行检索时，执行检索的起始位登可能就不是宇符申的开始位登，而
正则表达式的模式匹配
265

---
可能是任意位置第出5。当然，如果RegExp不带有修饰符g,则不必拥心会发生这种情
况。同样要记住，在ECMAScript 5平，正则表达式直接量的每次计算都会创建一个新
的RegExp对象，每个新RegExp对象具有各自的1astIndex属性，这势必会大大减少“残
留”lastIndex对程序造成的意外影响。
译注5: 这里所说的任意位置实际上是由lastIndex的傥决定的，如米]ast[ndex的值不为0; 必定会
对新开始的正则表达式匹配检索造成不碗定的影响。
266
第10章
