# 第4章　变量、作用域和内存问题([返回首页](https://github.com/qianjilou/javascript3))
**本章内容**
- 理解基本类型和引用类型的值  
- 理解执行环境  
- 理解垃圾收集  

照ECMA-262的定义，JavaScript的变童与其他语言的变fi有很大区別。JavaScript变童松散 类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某 个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的牛.命周期内改变。尽管 从某种角度看，这可能是一个既冇趣又强大，同时又容易出问题的特性，但JavaScript变量实际的复杂 稈度还远不止如此。
##  4.1 基本类型和引用类型的值
&emsp;&emsp;ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是 简单的数据段，而引用类型值指那些可能由多个值构成的对象。  
&emsp;&emsp;在将一个值賦给变贵时，解析器必须确定这个值是基本类型值还是引用类型值。第3章讨论了5种 基本数据类型：Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问 的，因为可以操作保存在变M中的实际的值。  
&emsp;&emsp;引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置, 也就楚说不能直接操作对象的内存空间。在操作对象时，实际i是在操作对象的引用而不是实际的对象。 为此.引用类型的值是按引用访问的。  

---

在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。 ECMAScript放弃了这一传统。

---

###  4.1.1  动态的属性
&emsp;&emsp;定义棊本类型值和引用类型值的方式是类似的：创建一个变贵并为该变量賦值。但是，这个值保存到变以后，对不同类型值以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子：
```javascript
var person = new Object();
person.name = "Nicholas";
alert(person.name);    //"Nicholas"
```
&emsp;&emsp;以上代码创建了一个对象并将其保存在了变量person中。然后，我们为该对象添加了 •个名为 name的属性，并将字符串值"Nicholas"赋给了这个属性。紧接着，又通过alert()函数访问了这个 新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。  
&emsp;&emsp;但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如：
```javascript
var name = "Nicholas";
name.age = 27;
alert(name.age);    //undefined
```
&emsp;&emsp;在这个例子中，我们为字符串name定义了一个名为age的属性，并为该属性賦值27。但在下一 行访问这个属性时，发现该屈性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。  
###  4.1.2  复制变量值
&emsp;&emsp;除了保存的方式不同之外，在从一个变童向另一个变量复制基本类型值和引用类型值时，也存在不 同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制 到为新变tt分配的位置上。来看个例子：  
```javascript
var numl = 5;
var nun2 = numl;
```
&emsp;&emsp;在此，numl中保存的值是5。当使用numl的值来初始化num2时，num2中也保存了值5。但num2 中的5与mml中的5是完全独立的，该值只是numl中5的一个副本。此后，这两个变量可以参与任 何操作而不会相互影响。图4-1形象地展示了复制基本类型值的过程。    
&emsp;&emsp;从一个变董向另一个变it复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到 为新变贽分配的空间中。不同的是，这个值的副本实际上是•个指针，而这个指针指向存储在堆中的一 个对象。复制操作结束后，两个变：S实际上将引用同一个对象。因此，改变其中一个变量，就会影响另 一个变贵，如下面的例子所示：
```javascript
var objl = new Object();
var obj2 = objl;
objl.name = "Nicholas";
alert(obj2.name); //"Nicholas"
```
&emsp;&emsp;訖先，变量objl保存了一个对象的新实例。然后，这个值被复制到了 obj2中;换句话说，objl 和obj2都指向同一个对象。这样，当为objl添加name届性后，可以通过obj2来访问这个属性， 因为这两个变量引用的都是同一个对象。图4-2展示了保存在变M对象中的变董和保存在堆中的对象之 间的这种关系。  
复制前的变:tt对象	堆内存
###  4.1.3 传递参数
&emsp;&emsp;ECMAScript中所有函数的参数都是按值传递的。也就是说，把闲数外部的值复制给函数内部的参 数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变置的复制一样，而 引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因 为访问变M有按值和按引用两种方式，而参数只能按值传递。  
&emsp;&emsp;在向参数传递基本类铟的值时，被传递的值会被复制给一个局部变M (即命名参数，或者用 ECMAScript的概念来说，就是arguments对象中的一个元素）。在向参数传递弓丨用类遛的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变fi的变化会反映在函数的外部。请看下面 这个例子：
```javascript
function addTen(num) {
	num += 10;
	return num;
}

var count = 20
var result = addTen(count);
alert(count);    //20
alert(result);   //10
```
&emsp;&emsp;这里的函数addTen ()有一个参数mrau而参数实际上是函数的局部变童。在调用这个函数时，变 ttcount作为参数被传递给函数，这个变量的值是20。于是，数值20被复制给参数num以便在addTenO 中使用。在函数内部，参数num的值被加上了 10,但这一变化不会影响函数外部的count变童。参数 num与变量count互不相识，它们仅仅是具有相同的值。假如num是按弓丨用传递的话，那么变量count 的值也将变成30,从而反映函数内部的修改。汽然，使用数值等基本类型值来说明按值传递参数比较简 中-，但如果使用对象，那问题就不怎么好理解了。再举一个例子：
```javascript
function setName(obj) {
	obj.name = "Nicholas";
}

var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"
```
&emsp;&emsp;以上代码中创建一个对象，并将W保存在了变量person中。然后，这个对象被传递到setName <> 函数中之后就被复制给了 obj。在这个函数内部，obj和person引用的是同一个对象。换句话说，即 使这个对象是按值传递的，obj也会按引用来访问同一个对象。T是，当在函数内部为obj添加name 属性后，函数外部的person也将有所反映;W为person指向的对象在堆内存中只有一个，而且是全 局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明 参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：
```javascript
function setName(obj) {
	obj.name = "Nicholas";
	obj = new Object();//加粗
	obj.name = "Greg";//加粗
}
var person = new Object();
	setName(person);
	alert(person.name);//"Nicholas"
```
&emsp;&emsp;这个例子与前-个例子的唯一区别，就是在setName ()函数中添加了两行代码：一行代码为obj 重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递给 setName ()后，其name属性被设置为"Nicholas"。然后，又将Jj'•新对象陚给变量obj ,同时将其name 属性设置为-Greg•。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值 为"Greg"的新对象。但是，.当接下来再访问person.name时，显示的值仍然是"Nicholas"。这说明 即使在闲数内部修改了参数的值，但原始的弓丨用仍然保持未变。实际上，当在函数内部重写Obj时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。
###  4.1.4 检测类型
&emsp;&emsp;要检测一个变量是不是基本数据类型？第3章介绍的typeof操作符是最佳的工具。说得更具体一 点，typeof操作符是确定一个变童是字符串、数值、布尔值，还是undefined的最佳丁具。如果变 量的值是一个对象或null,贝lUypeof操作符会像下面例子中所示的那样返回"object":
```javascript
var s = "Nicholas";
var b = true;
var i = 22;
var u;
var n = null;
var o = new Object();

alert(typeof s);   //string
alert(typeof i);   //number
alert(typeof b);   //Boolean
alert(typeof u);   //undefined
alert(typeof n);   //object
alert(typeof o);   //object
```
&emsp;&emsp;虽然在检测基本数据类型时typeof是非常得力的助手，但在检测引用类型的值时，这个操作符的 用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript 提供了 instanceof操作符，其语法如下所示：  
```javascript
result = variable instanceof constructor
```
&emsp;&emsp;如果变a是给定引用类® (根据它的原型链来识别;第6章将介绍原型链）的实例，那么 instanceof操作符就会返冋true。请看下面的例了-:
```javascript
alert(person instanceof Obiect);//变量person是Obiect吗?
alert(colors instanceof Array);//变量colors是Array吗?
alert(pattern instanceof RegExp);//变量pattern是RegExp吗?
```
&emsp;&emsp;根据规定，所有引用类型的值都是Object的实例。W此，在检测•个引用类型值和Object构造 函数时，instanceof操作符始终会返W true。当然，如果使用instanceof操作符检测基本类型的 值，则该操作符始终会返回false,因为基本类沏不是对象。
使用typeof操作符检到函數时，该操作符会返回"functicm"。在Safari 5及 之前版本和Chrome 7及之前版本中使用typeof检測正則表达式时，由于规范的原 因，这个操作符也逐回"function”。ECMA-262规定任何在内部实现[[Call]]方法 的对象都应该在应用typeof操作符时返回"function"。由于上述浏览器中的正则 表达式也实现了这个方法，因此对正则表达式应用typeof会返回"function1•。在 IE和Firefox中，对正则表达式应用typeof会返回nobject"〇
可以把ECMAScript函数的参数想象成局部变量。
##  4.2 执行环境及作用域
&emsp;&emsp;执行环境（executioncontext,为简单起见，有时也称为“环境”）是JavaScript中最为重要的一个概 念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个 与之关联的变置对象（variable object),环境中定义的所有变置和函数都保存在这个对象中。虽然我们 编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。  
&emsp;&emsp;全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环 境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象（第7章将详细讨论)，W 此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变fi和函数定义也随之销毁（全局执行环境直到应用程序退 出一例如关闭网页或浏览器一时才会被销毁)。  
&emsp;&emsp;每个函数都有A己的执行环境。当执行流进入-个函数时，函数的环境就会被推人-个环境找中。 而在函数执行之后，找将其环境弹出，把控制权返问给之前的执行环境。ECMAScript程序中的执行流 正是由这个方便的机制控制着。  
&emsp;&emsp;当代码在一个环境中执行时，会创建变M对象的一个作用域链（scopechain)。作用域链的用途，是 保证对执行环境有权访问的所有变fit和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变缳对象。如果这个环境是函数，则将其活动对象（activation object)作为变量对象。活动对 象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的)。作用域链中 的下一个变该对象来自包含（外部）环境，而再下一个变量对象则来A下一个包含环境。这样，一直延 续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。  
&emsp;&emsp;标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生)。  
请看下面的示例代码：
```javascript
var color = "blue";

function changeColor(){
	if (color === "blue"){
		color = "red";
	} else {
		color = "blue";
	}
}

changeColor();

alert("Color is now " + color);
```
&emsp;&emsp;在这个简单的例子中，函数changeColor <>的作用域链包含两个对象：它自己的变量对象（其中 定义着arguments对象）和全局环境的变量对象。可以在函数内部访问变Mcolor,就是因为可以在 这个作用域链中找到它。
此外，在局部作用域中定义的变量可以在局部环境中与全局变贵换使用，如下面这个例子所示:
```javascript
var color = "blue";

function changeColor(){
	var anotherColor = "red";

	function swapColors(){
		var tempColor = anotherColor;
		anotherColor = color;
		color = tempColor;
		
		//这里可以访问 color、anotherColor和 tempColor
	}

	//这里可以访问color和anotherColor，住不能访问tempColor swapColors();       
	swapColors();
}

//这里只能访问color
changeColor();
```
&emsp;&emsp;以上代码共涉及3个执行环境：全局环境、changeColorO的局部环境和swapColors ()的局部 环境。全局环境中有--个变量color和一个兩数changeColor ()。changeColor ()的局部环境中有 一个名为anotherColor的变量和一个名为swapColors ()的函数，但它也可以访问全局环境中的变 量color。swapColors ()的局部环境中有一个变置tempColor，该变量只能在这个环境中访问到。 无论全M环境还是changeColor 〇的局部环境都无权汸问tempColor。然而，在swapColors ()内部 则可以访问芄他两个环境中的所有变童，闪为那两个环境是它的父执行环境。图4-3形象地展示了前面 这个例子的作用域链。  
&emsp;&emsp;阁4-3中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但 外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都 可以向上搜索作用域链，以査询变量和函数名;但任何环境都不能通过向下搜索作用域链而进人另一个 执行环境。对于这个例了中的swapColors()而言，其作用域链中包含3个对象：swapColors()的变 量对象、changeColorO的变童对象和全局变最对象。swapColors ()的局部环塊开始时会先在自己的 变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。changeColorO的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问swapColors()的 环境。
函数参数也被当作变量来对待，因此其访问规則与执行环境中的其他变量相同。
###  4.2.1  延长作用域链
&emsp;&emsp;虽然执行环境的类迆总共只有两种一全局和局部（函数），但还是有其他办法来延长作用域链。 这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变M对象会在代码执行后被移 除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会 得到加长：  
&emsp;&emsp;■try-catch 语句的 catch 块;  
&emsp;&emsp;■with语句。  
&emsp;&emsp;这两个语句都会在作用域链的前端添加一个变fi对象。对with语句来说，会将指定的对象添加到 作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 下面看一个例子。
```javascript
function buildUrl() {
	var qs = "?debug=true";

	with(location){
		var url = href + qs;        
	}

	return url;
}
```
&emsp;&emsp;在此，with语句接收的是location对象，因此其变量对象中就包含了 location对象的所有属 性和方法，而这个变量对象被添加到了作用域链的前端。buildUrlO函数中定义了一个变量qs。当在 with语句中引用变量href时（实际引用的是location.href ),可以在当前执行环境的变ft对象中 找到。当弓丨用变量qs时，弓I用的则是在buildUrlO中定义的那个变量，而该变量位于函数环境的变 量对象中。至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一 部分，所以可以作为函数的值被返回。  
&emsp;&emsp;在丨E8及之前版本的JavaScript实现中，存在一个与标准不一致的地方，即在
Zcatch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句 的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修 复了这个问题。
###  4.2.2  没有块级作用域
&emsp;&emsp;JavaScript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括号封闭的代码 块都有自己的作用域（如果用ECMAScript的话来讲，就是它们自己的执行环境)，W而支持根据条件来 定义变量。例如，下面的代码在JavaScript中并不会得到想象中的结果：
```javascript
if (true) {
var color = "blue";
}
alert (color); /"blue"
```
&emsp;&emsp;这里是在一个if语句中定义了变color。如果是在C、C++或Java中，color会在if语句执 行完毕后被销毁。但在JavaScript中，if语句中的变量声明会将变童添加到当前的执行环境（在这里是 全局环境）中。在使用for语句时尤其要牢记这一差异，例如：
```javascript
for (var i=0; i < 10; i++){ 
	doSoniething (i);
}
alert (i);//10
```
&emsp;&emsp;对f有块级作用域的语言来说，for语句初始化变量的表达式所定义的变tt,只会存在于循环的环 境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在 于循环外部的执行环境中。
**1.声明变置**  

&emsp;&emsp;使用var卢明的变ft会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部
环境;在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自
动被添加到全局环境。如下所示：
```
function add(numl, num2) { 
	var sum = numl + num2;
	return sum;
}
var result = add(10, 20);//30
alert(sum);//由于sum不是有效的变量，因此会导致错误
```
&emsp;&emsp;以上代码中的函数add()定义了一个名为sum的局部变量，该变量包含加法操作的结果。虽然结
果值从函数中返四了，但变《 sum在函数外部是访问不到的。如果省略这个例子中的var关键字，那
么当add ()执行完毕后，sum也将可以访问到：
```javascript
function add(numl, num2) {
	sum = numl + num2;
	return sum;
}
var result = add(10, 20);//30
alert(sum);//30
```
&emsp;&emsp;这个例子中的变量sum在被初始化賦值时没有使用var关键字。于是，当调用完add ()之后，添 加到全局环境中的变M sum将继续存在;即使函数已经执行完毕，后面的代码依旧可以访问它。
&emsp;&emsp;在编写JavaScript代码的过程中，不声明而直接初始化变量是一个常见的错误做 法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就 可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。
### 2.查询标识符
&emsp;&emsp;当在某个环境中为了读取或写人而引用一个标识符时，必须通过搜索来确定该标识符实际代表什 么。搜索过程从作用域链的前端开始，向上逐级丧询与给定名字匹配的标识符》如果在M部环境中找到 了该标识符，搜索过程停止，变最就绪。如果在M部环境中没存找到该变M名，则继续沿作用域链向上 搜索。搜索过程将一直追到到全局环境的变it对象。如果在全局环境中也没有找到这个标识符，则意味 着该变量尚未声明。  
&emsp;&emsp;通过下面这个示例，可以理解査询标识符的过程:
```javascript
var color = "blue";
function getColor(){
	return color;
}
alert(getColor());//"blue"
```
&emsp;&emsp;调用本例中的函数getColor ()时会引用变量color。为了确定变量color的值，将开始一个两 步的搜索过程。首先，搜索getColor ()的变量对象，査找其中是否包含一个名为color的标识符。 在没有找到的情况下，搜索继续到下-个变M对象（全M环境的变M对象），然后在那里找到了名为 color的标识符。因为搜索到了定义这个变_位的变fl：对象，搜索过程寅告结束。图4*4形象地展示了上 述搜索过程。  
&emsp;&emsp;在这个搜索过程中，如果存在-个M部的变M的定义，则搜索会自动停止，不再进人另一个变量对 象。换句话说，如果局部环境中存在宥同名标识符，就不会使用位于父环境中的标识符，如下面的例子 所示：
```javascript
var color = "blue";
function getColor(){ 
	var color = "red";
	return color;
)
alert(getColor());//"red"
```
&emsp;&emsp;修改后的代码在getColor U函数中声明了一个名为color的局部变M。调用函数时，该变董就 会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量color的值。搜索过程首先 从局部环境中开始，而且在这里发现了一个名为color的变量，其值为-red•。因为变置已经找到了， 所以搜索即行停止，return语句就使用这个局部变童，并为函数会返回"red•。也就足说，任何位于 局部变tt color的声明之后的代码，如果不使用window.color都无法访问全局color变:M。如果有 一个操作数是对象，而另一个不是，就会在对象上调用valueOfO方法以取得基本类型的值，以便根 据前面的规则进行比较。
变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因 为不用向上搜索作用域链。JavaScript引擎在优化标识符查询方面做得不错，因此这 个差别在将来恐怕就可以忽略不计了。
##  4.3 垃圾收集
&emsp;&emsp;JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 而在C和C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问 题的一个根源。在编写JavaScript程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无 用内存的冋收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变 置，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）, 周期性地执行这一操作。  
&emsp;&emsp;下面我们来分析一下函数中局部变量的正常生命周期。局部变fi只在函数执行的过程屮存在。而在 这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使 用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供 将来使用。在这种情况下，很容易判断变童是否还有存在的必要;但并非所有情况下都这么容易就能得 出结论。垃圾收集器必须跟踪哪个变量有用哪个变fi没用，对于不再有用的变量打上标记，以备将来收 间其占用的内存。用于标识无用变童的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两 个策略。
###  4.3.1  标记清除
&emsp;&emsp;JavaScript中最常用的垃圾收集方式是标记清除（mark-and-swecp)。当变M进入环境（例如，在函 数中声明一个变量）时，就将这个变量标记为“进人环境”。从逻辑上讲，永远不能释放进人环境的变
M所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而汽变M离开环境时，则将其 标记为“离开环境”。    
&emsp;&emsp;可以使用任何方式来标记变M。比如，可以通过翻转某个特殊的位来记录一个变量何时进人环境， 或者使用一个“进人环境的”变W列表及一个“离开环境的”变量列表来跟踪哪个变贷发生了变化。说 到底，如何标记变ftJt实并不重要，关键在于采取什么策略。  
&emsp;&emsp;垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方 式)。然后，它会去掉环境中的变M以及被环境中的变M引用的变tt的标记。而在此之后冉被加上标记 的变将被视为准备删除的变M,原因是环境中的变Mid经无法访问到这些变谱了。最后，垃圾收集器 完成内存清除1：作，销毁那些带标记的值并凹收它们所占用的内存空间。  
&emsp;&emsp;到2008年为止，E、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都足标记清除式的 垃圾收集策略（或类似的策略)，只不过垃圾收集的时间间隔互有不同。
###  4.3.2 引用计数
&emsp;&emsp;另一种不太常见的垃圾收集策略叫做引用计数（referencecounting)。引用计数的含义是跟踪记汆每 个值被引用的次数。当卢明了一个变量并将一个引用类型值赋给该变ffl时，则这个值的引用次数就是1。 如果同一个值又被賦给另一个变毋，则该值的引用次数加丨。相反，如果包含对这个值引用的变M 乂取 得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没存办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。
&emsp;&emsp;Netscape Navigator 3.0是最早使用引用计数策略的浏览器，似很快它就遇到了一个严重的问题：循 环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的 引用。请看下面这个例子：
```javascript
function problem(){
	var objecLA = new Object(); 
	var objectB = new Object();
	objectA.someOtherObject = objectB;
	objectB.anotherObject = objectA;
)
```
&emsp;&emsp;在这个例子中，object和objects通过各自的属性相互引用;也就是说，这两个对象的引用次 数都是2。在采用标i己清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种 相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA和objectB还 将继续存在.因为它们的引用次数永远不会是0。假如这个函数被重复多次调用，就会导致大量内存得 不到回收。为此，Netscape在Navigator4.0中放弃了引用计数方式，转而采用标记清除来实现其垃圾收 集机制。可是，弓丨用计数导致的麻烦并未就此终结。  
&emsp;&emsp;我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是 使用C++以COM ( Component Object Model,组件对象模型）对象的形式实现的，而COM对象的垃圾 收集机制采用的就是引用计数策略。W此，即使丨E的JavaScript引擎是使用标记淸除策略来实现的，但 JavaScript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会 存在循环引用的问题。下面这个简单的例子，展示了使用COM对象导致的循环引用问题：
```javascript
var element = document.getEleinentById("some—element");
var myObject = new Objecc();
myObject.element = element;
element.soroeObject = myObject;
```
这个例子在一个DOM元素（element )与一个原生JavaScript对象（rnyObject)之间创建了循环 引用。其屮，变tt myObject有一个名为element的属性指向element对象;而变置element也有 一个属性名叫someObject W指rnyObject。由于存在这个循环引用，即使将例子中的DOM从页面中 移除，它也水远不会被回收。
为了避免类似这样的循环引用问题，S好是在不使用它们的时候手n断开原生JavaScript对象与 DOM元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用：
将变量设贾为nuK意味着切断变ft与它此前引用的值之间的连接。巧垃圾收集器下次运行时，就 会删除这些值并M收它们A用的内存。
为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了 两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。
###  4.3.3 性能问题
&emsp;&emsp;垃圾收集器是周期性运行的，而如果为变最分配的内存数货很可观，那么回收工作量也是相当大 的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一 次，不禁让人联想到丨EW此而声名狼藉的性能问题。1E的垃圾收集器是根据内存分配童运行的，具体 一点说就足256个变量、4096个对象（或数组）字面M和数组元素（slot)或者64KB的字符串。达到 上述任何-个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变 摄，那么该脚本很可能会在其生命周期中一直保有那么多的变盘。而这样一来，垃圾收集器就+得不频 繁地运行。结果，由此引发的严S性能问题促使IE7 2写了其垃圾收集例程。  
&emsp;&emsp;随若IE7的发布，其JavaScript引擎的垃圾收集例程改变了丁作方式：触发垃圾收集的变量分配、 字面M和（或）数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果 垃圾收集例程W收的内存分配蛩低于丨5%,则变S、字面量和（或）数组元素的临界值就会加倍。如果 例程回收了 85%的内存分配最，则将各种临界值承置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大罱JavaScript的页面时的性能。    
&emsp;&emsp;事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。在1£中，调用7»：1113〇».£：〇1160;七〇3115&的（>方法会立即执行垃圾收集。在〇15€1'3 7及更 高版本中，调用window.opera.collects)也会启动垃圾收集例程。
rnyObject.element = null? elcjmont. someObject = null;
导致循环引用的情况不止这些，其他一些情况将在本书中陆续介绍。
###  4.3.4 管理内存
&emsp;&emsp;使用具备垃圾收集机制的语言编写程序，开发人员般不必操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问題还是有点与众不同。其中最主要的一个问题，就是分配给Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑， 目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变最 分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。  
&emsp;&emsp;因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行 中的代码只保存必要的数据。一且数据不再有用，最好通过将其值设置为null来释放其引用——这个 做法叫做**解除引用**（dereferencing)。这-做法适用于大多数全局变贵和全局对象的属性。局部变量会在 它们离开执行环境时自动被解除引用，如下面这个例子所示：
```javascript
function createPerson(name){
	var localPerson = new Object();
	localPerson.name = name; 
	return localPerson;
}
var globalPerson = creacePerson("Nicholas");

//手工解除globalPerson的引用 

globalPerson = null;
```
&emsp;&emsp;在这个例子中，变最globalPerson取得了 createPerson()函数返回的值。在createPerson() 函数内部，我们创建了一个对象并将其陚给局部变量localPerson，然后又为该对象添加了-个名为 name的属性。最后，当调用这个函数时，localPerson以函数值的形式返N并賦给全局变量 globalPerson。由于localPerson在createPerson()函数执行完毕后就离开丫其执行环境，因此 X需我们显式地去为它解除引用。但是对于全局变量globalPerson而言，则需要我们在不使用它的 时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。  
&emsp;&emsp;不过，解除一个值的引用并不意味着自动网收该值所占用的内存。解除引用的真正作用是让值妝离 执行环境，以便垃圾收集器下次运行时将其回收。
##  4.4小结
&emsp;&emsp;JavaScript变童可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5 种基本数据类型：Undefined、Null、Boolean、Number和String。基本类SS值和引用类§?值具 有以下特点：  
- [ ] 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中;  
- [ ] 从一个变最向另一个变量复制基本类型的值，会创建这个值的一个副本;  
- [ ] 引用类型的值是对象，保存在堆内存中;  
- [ ] 包含引用类型值的变童实际上包含的并不是对象本身，而是一个指向该对象的指针;    
- [ ] 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，W此两个变量最终都指向同 一个对象;  
- [ ] 确定-个值是哪种基木类铟可以使用typeof操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符〇    
所有变ft (包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执 行环境决定了变童的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几 点总结：    
- [ ] 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分;  
- [ ] 每次进人一个新执行环境，都会创建一个用T搜索变量和函数的作用域链;  
- [ ] 函数的局部环境不仅有权访问函数作用域中的变童，而且有权访问其包含（父）环境，乃至全 局环境;  
- [ ] 全M环境只能访问在全W环境中定义的变置和函数，而不能直接访问局部环境中的任何数据;  
- [ ] 变M的执行环境有助于确定应该何时释放内存。  
- [ ] JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可 以对JavaScript的垃圾收集例程作如F总结。   
- [ ] 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除.  
- [ ]  “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然 后再问收其内存。  
- [ ] 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript 弓丨擎H前都不再使用这种算法;但在丨E中访问非原生JavaScript对象（如DOM元素）时，这种 算法仍然可能会导致问题。  
- [ ] 当代码中存在循环弓丨用现象时，“引用计数”算法就会导致问题。  
- [ ] 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回 收内存，应该及时解除不#使用的全局对象、全M对象属性以及循环引用变量的引用。  
[上一章](https://github.com/qianjilou/javascript3/blob/master/chapter/chapter3.md)&emsp;&emsp;[下一章](https://github.com/qianjilou/javascript3/blob/master/chapter/chapter5.md)