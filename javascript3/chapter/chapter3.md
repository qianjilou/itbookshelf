#  第3章 基本概念 ([返回首页](https://github.com/qianjilou/javascript3))
**本章内容**
- 语法
- 数据类型
- 流控制语句
- 理解函数  

何语言的核心都必然会描述这门语言最基本的工作原理。而描述的内容通常都要涉及这门语 言的语法、操作符、数据类瑠、内置功能等用于构建复杂解决方案的基本概念。如前所述， ECMA-262通过叫做ECMAScript的“伪语言”为我们描述了 JavaScript的所有这些基本概念。
目前，ECMA-262第3版中定义的ECMAScript是各浏览器实现最多的一个版本。ECMA-262第5 版是浏览器接下来实现的版本，但截止到2011年底，还没有浏览器完全实现了这个版本。为此，本章 将主要按照第3版定义的ECMAScript介绍这门语言的基本概念，并就第5版的变化给出说明。
##  3.1 语法
ECMAScript的语法大量借鉴了 C及其他类C语言(如Java和Perl)的语法。因此，熟悉这些语言 的开发人员在接受ECMAScript更加宽松的语法时，一定会有一种轻松自在的感觉。
###  3.1.1 区分大小写
要理解的第一个概念就是ECMAScript中的一切(变量、函数名和操作符）都区分大小写。这也就 意味着，变最名test和变域名Test分别表示两个不同的变量，而函数名不能使用typeof，因为它 是一个关键字(3.2节介绍关键字），但typeOf则完全可以是一个有效的函数名。
###  3.1.2 标识符
所谓标识符，就是指变ft、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则 组合起来的一或多个字符:
- [ ] 第一个字符必须是一个字母、下划线(_)或一个美元符号($);
- [ ] 其他字符可以是字母、下划线、美元符号或数字。  

标识符中的字母也可以包含扩展的ASCII或Unicode宇母宇符(如入和疋)，但我们不推荐这样做。 按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个有意义 的单词的首字母大写，例如:
虽然没有谁强制要求必须采用这种格式，但为了与ECMAScript内置的函数和对象命名格式保持一 致，可以将其当作一种最佳实践。
不能把关键字、保留字、.trua、false和null用作标识符。3.2节将介绍更多相 关内容。
###  3.1.3 注释
ECMAScript使用C风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头，如下所示:
〃单行注释
块级注释以一个斜杠和一个星号(/*)开头，以一个星号和一个斜杠(V )结尾，如下所示:
/*
21.1.1这是一■个多行
21.1.2(块级）注释
V
虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯 粹是为了提高注释的可读性(这种格式在企业级应用程序中极其常见)。
###  3.1.4 严格模式
ECMAScript 5引人了严格模式(strict mode)的概念。严格模式是为JavaScript定义了一种不同的 解析与执行模型。在严格模式下，ECMAScript3中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码:
■use strict";
这行代码看起来像是字符串，而且也没有赋值给任何变M,但其实它是一个编译指示(pragma), 用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。 在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行:
function doSomething(){
"use strict";
//函數体

严格模式下，JavaScript的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支 持严格模式的浏览器包括 IE10+、Firefox4+、Safari 5.1+、Opera 12+和 Chrome。
###  3.1.5 语句
ECMAScript中的语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾，如下例所示:
var sum = a + b	//即使没有分号也是有效的语句	不推朞
var diff = a - b;	//有效的语句	推其
虽然语句结尾的分号不是必需的，但我们建议任何时候都不要楫略它。因为加上这个分号可以避免 很多错误(例如不完整的输人）,开发人员也可以放心地通过删除多余的空格来压缩ECMAScript代码(代 码行结尾处没有分号会导致压缩错误)。另外，加上分号也会在某些情况下增进代码的性能，因为这样 解析器就不必再花时间推测应该在哪里插人分号了。
可以使用C风格的语法把多条语句组合到一个代码块中，即代码块以左花括号({)开头，以右花 括号(})结尾:
if (testH
test = false; alert(test)?

虽然条件控制语句(如if语句）只在执行多条语句的情况下才要求使用代码块，供最佳实践是始 终在控制语句中使用代码块一即使代码块中只有一条语句，例如:
if (test)
alert (test) ;	//有效但容易出械，不要使用
if (test){	//推苒使用
alert(test);
)
在控制语句中使用代码块可以让编码意图更加淸晰，而且也能降低修改代码时出错的儿率。
##  3.2 关键字和保留字
ECMA-262描述了 一组具有特定用途的__关键字__，这些关键宇可用于表示控制语句的开始或结束，或 者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是ECMAScript 的全部关键字(带*号上标的是第5版新增的关键字）:
ECMA-262还描述了另外一组不能用作标识符的保留宇。尽管保留字在这门语言中还没有任何特定 的用途，但它们有可能在将来被用作关键字。以下是ECMA-262第3版定义的全部保留字:
第5版把在非严格模式下运行时的保留字缩减为下列这些:
class	enum	extends	super
const	export	import
在严格模式下，第5版还对以下保留宇施加了限制:
implements	package	public
interface	private	static
let	protected	yield
注意，let和yield是第5版新增的保留字;其他保留字都是第3版定义的。为了最大程度地保 证兼容性，建议读者将第3版定义的保留字外加let和yield作为编程时的参考。
在实现ECMAScript 3的JavaScript弓丨擎中使用关键字作标识符，会导致“丨dentifierExpected”错误。 而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。
第5版对使用关键字和保留字的规则进行了少许修改。关键字和保留字虽然仍然不能作为标识、符使 用，但现在可以用作对象的属性名。一般来说，最好都不要使用关键字和保留字作为标识符和属性名， 以便与将来的ECMAScript版本兼容。
除了上面列出的保留字和关键字，ECMA-262第5版对eval和arguments还施加了限制。在严 格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。
##  3.3 变量
ECMAScrjpt的变量是松敗类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说， 每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用var操作符(注意var是一个关键 字)，后跟变ft名(即一个标识符)，如下所示: var message;
这行代码定义了一个名为message的变量，该变量可以用来保存任何值(像这样未经过初始化的 变量，会保存一个特殊的值——undefined,相关内容将在3.4节讨论)。ECMAScript也支持直接初始 化变量，W此在定义变量的同时就可以设置变量的值，如下所示: var message = "hi■;
在此，变M message中保存了一个字符串值"hi •。像这样初始化变量并不会把它标记为字符串类型; 初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值的类型，如下所示:
var message = "hi";
message = 100;	//有效，位不推其
在这个例了中，变童message—开始保存了一个字符串值”hi_,然后该值又被一个数字值100取 代。虽然我们不建议修改变tt所保存值的类塑，伯这种操作在ECMAScript中完全有效。
有一•点必须注意，即使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是 说，如果在函数中使用var定义一个变屋:，那么这个变童在阐数退出后就会被销毁，例如:
```
function test(){	，
var message = -hi•; // 局部t量
)
test();
alert (message) ; // 樣误！
```
这里，变童message 是在闲数中使用var定义的。当函数被调用时，就会创建该变量并为其赋值。 而在此之后，这个变量又会立即被销毁，W此例子中的下一行代码就会导致错误。不过，可以像下面这 样贫略var操作符，从而创建一个全局变最:
function test(){
message » _hi_; // 全為变责
}
test();
alert(message); // *hi"
这个例子省略了 var操作符，因而message就成了全局变量。这样，只要调用过一次test ()函 数，这个变甭就有了定义，就奵以在函数外部的任何地方被访问到。
虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局 部作用域中定义的全局变量很难维护，而且如果有意地忽略了 var操作符，也会由于 相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式 下会导致抛出ReferenceError構误。
可以使用一条语句定义多个变量，只要像下面这样把每个变fi(初始化或不初始化均可）用逗号分 隔开即可:
var message = "hi", found = false,
age = 29;
这个例子定义并初始化了 3个变M。同样由于ECMAScript是松散类型的，因而使用不同类型初始 化变fl的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提 高可读性。
在严格模式下，不能定义名为eval或arguments的变虽，否则会导致语法错误。
##  3.4 数据类型
ECMAScript中有5种简单数据类型(也称为基本数据类型）:Undefined、Null、Boolean、Number .
和String。还有1种复杂数据类5!	Object,Object本质上是由一组无序的名值对组成的。ECMAScript
不支持任何创建0定义类型的机制，时所有值最终都将是上述6种数据类型之一。乍一•看，好像只有6 种数据类型不足以表示所有数据;但是，由于ECMAScript数据类沏具有动态性，因此的确没有再定义 其他数据类型的必要了。
###  3.4.1 typeof 操作符
鉴于ECMAScript是松散类型的，因此需要有一种手段来检测给定变最的数据类型一typeof就 是负责提供这方面信息的操作符。对一个值使用typeof操作符可能返回下列某个字符串:
- [ ] "undefined"	如果这个值未定义;
- [ ] "boolean"	如果这个值是布尔值;
- [ ] "string"	如果这个值是字符串;
- [ ] "number"	如果这个值是数值;
- [ ] "object"——如果这个值是对象或null;
- [ ] "function"——如果这个值是函数。  
下面是几个使用typeof操作符的例子:
```javascript
var message = "some string";
alert(typeof message);    //"string"
alert(typeof (message));  //"string"
alert(typeof 95);         //"number"
```
这几个例子说明，typeof操作符的操作数可以是变量(message),也可以是数值字面ft。注意， typeof是一个操作符闹不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。
有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值。比如，调用typeof null 会返回"object"因为特殊值null被认为是一个空的对象引用。Safari 5及之前版本、Chrome 7及之 前版本在对正则表达式调用typeof操作符时会返冋"function",而其他浏览器在这种情况下会返回 "object"

---

从技术角度讲，函数在ECMAScript中是对象，不是一种數据类型。然而，函数也 确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。  

---

###  3.4.2 Undefined 类型
Undefined类型只有一个值，即特殊的undefined。在使用var声明变董但未对其加以初始化时， 这个变费的值就是undefined,例如: 
```javascript
var message;
alert(message == undefined);    //true
```
这个例子只声明r变ftmessage，但未对其进行切始化。比较这个变最与undefined宇面量，结 果表明它们是相等的。这个例子与下面的例子是等价的:
```javascript
var message = undefined;
alert(message == undefined);    //true
```
这个例子使用undefined值显式初始化了变量message。但我们没有必要这么做，闵为未经初始 化的值默认就会取得undefined值。

---

一般而言，不存在需要里式地把一个变量设置为undefined值的情况。字面值 undefined的主要目的是用于比较，而ECMA-262第3版之前的版本中并没有规定 这个值。第3版幻入这个值是为了正式区分空对象指针与未经初始化的变量。

---

不过，包含undefined值的变量与尚未定义的变谓:还是不一样的。看看下面这个例子:
```javascript
var message;   //这个变责声明之后默认東得了 undefined值

//下面这个变量并没有声明 
//var age

alert(message);  //"undefined"
alert(age);      //causes an error
```
运行以上代码，第一个替告框会显示变屋message的值，即"undefined"。而第二个替告框—— 由于传递给alert()函数的是尚未声明的变量age——则会导致个错误。对于尚未声明过的变量，只 能执行一项操作，即使用typeof操作符检测其数据类型(对未经声明的变量调用delete不会导致错 误，但这样做没什么实际意义，而&在严格模式下确实会导致错误)。
然而，令人困惑的是:对未初始化的变.it执行typeof操作符会返I5! undefined值，而对未声明 的变最执行typeof操作符同样也会返回undefined值。来看下面的例子:
```javascript
var message;     // 这个变量声明之后默认取得了 undefined 值
        
//下面这个变量并没有声明
//var age

alert(typeof message);  //"undefined"
alert(typeof age);      //"undefined"
```
UndefinedExample04. htm
结果表明，对未初始化和未声明的变量执行typeof操作符都返回了 undefined值;这个结果有 其逻辑上的合理性。因为虽然这两种变量从技术角度看旮本质区别，但实际上无论对哪种变量也不可能 执行真正的操作。
即便未初始化的变量会自动被赋予undsfined值，但显式地初始化变量依然是 明智的选择。如果能够做到这一点，那么当typeof操作符返回"undefined"值时， 我们就知道被检测的变量还没有被声明，而不是尚未初始化。
###  3.4.3 Null 类型
Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表 不一个空对象指针，而这也正是使用typeof操作符检测null值时会返回"object"的原因，如下面 的例子所示:
```javascript
var car = null;
alert(typeof car);   //"object"
```
NullExampleOl. htm
如果定义的变M准备在将来用于保存对象，那么最好将该变量初始化为mill而不是其他值。这样 一来，只要立接检査mill值就可以知道相应的变M是否已经保存了一个对象的引用，如下面的例子 所示:
if fear != null){
//对car对象执行暮些操作
)
实际上，undefined值是派生null值的，因此ECMA-262规定对它们的相等性测试要返回true: alert(null == undefined); //true
NuliExample02.htm
这里，位T null和undefined之间的相等操作符(==)总是返冋true,不过要注意的是，这个 操作符出于比较的目的会转换其操作数(本章后面将详细介绍相关内容)。
尽管mill和undefined有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下 都没有必要把一个变量的值显式地设置为undefined,可是同样的规则对null却不适用。换句话说， 只要意在保存对象的变M还没有真正保存对象，就应该明确地让该变M保存null值。这样做不仅可以 体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。
###  3.4.4 Boolean 类型
Boolean类型是ECMAScript中使用得最多的一种类型，该类型只有两个字面值:true和false。 这两个值与数字值不是-冋事，因此true不一定等于1,而false也不一定等于0。以下是为变量赋 Boolean类型值的例子:
var found = true; var lost s false;
需要注意的是，Boolean类5!!的字面值true和false是P(分大小写的。也就是说,True和False (以及其他的混合大小写形式）都不是Boolean值，只是标识符。
虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值 等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数B〇〇lean(),如下例所示:
var message = 'Hello world!•; var messageAsBoolean = Boolean(message);
BooleanExample01.htm
在这个例子中，字符串message被转换成广一个Boolean值，该值被保存在messageAsBoolean 变M中。可以对任何数据类铟的值调用Boolean ()函数，而且总会返冋一个Boolean值。至T返回的 这个值是tr Je还是false,取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及苏对 应的转换规则。
这些转换规则对理解流控制语句(如if语句）自动执行相应的Boolean转换非常重要，请看下面 的代码:
```
var message = "Hello world!";
if (message){
alert("Value is true");
```
BooleanExample02.htm
运行这个示例，就会显示一个警告框，W为字符串message被自动转换成了对应的Boolean值 (true)。由于存在这种自动执行的Boolean转换，因此确切地知道在流控制语句中使用的是仆么变量 至关重要。错误地使用一个对象而不是个Boolean值，就有可能彻底改变应用程序的流程。
###  3.4.5 Number 类型
Number类型应该是ECMAScript中最令人关注的数据类型了，这种类型使用IEEE754格式来表示 整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。为支持各种数值类型，ECMA-262定 义了不同的数值字面ft格式。
最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输人:
var intNuxn = 55;	"整数
除了以十进制表示外，整数还可以通过八进制(以8为基数）或十六进制(以16为基数）的字面值 来表示。其中，八进制字面值的第一位必须是零(0),然后是八进制数字序列(0~7)。如果字面值中的 数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。请看下面的例子:
```
var octalNuml = 070;	// /v进嚤4 的 56
var octalNum2	= 079;	//无效的八进制数值	解析为79
var octalNuxn3	= 08;	//无效的八进制数值——解析为8
```
八进制字面tt在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。 f-六进制字面值的前两位必须是Ox,后跟任何十六进制数字(0~9及A~F)。其中，字母A~F 可以大写，也可以小写。如下面的例子所示:
var hexNural =	OxA;	//	十六进制的 10
var hexNum2 =	Oxlf;	//	十六进制的 31
在进行算术计算时，所有以Aja制和十六进制表示的数值最终都将被转换成十进制数值。
①n/a (辱N/A)•是not applicable的缩写，意思是“不适用”。
鉴于JavaScript中保存数值的方式，可以保存正零(+0)和负零(-0)。
负零被认为相等，但为了读者更好地理解上下文，这里特别做此说明。
正零和
1.浮点数值
所谓^点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小 数点前面可以没有整数，似我们不推荐这种写法。以T是浮点数值的几个例子:
```
var floatNural	=	1.1;
var floatNum2	=	0.1;
var float:Num3	=	.1;	//	有效，位不推其
```
由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值 转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样 地，如果浮点数值本身表示的就是-个整数(如1.0),那么该值也会被转换为整数，如下面的例子所示:
var floatNuml = 1.;	//小数点后面没有数字	解析为1
var floatNum2 = 10.0;	// 整数	解析为 10
对于那些极大或极小的数值，可以用e表示法(即科学计数法）表示的浮点数值表示。用e表示法 表示的数值等于e前面的数值乘以10的指数次幂。ECMAScript中e表示法的格式也是如此，即前面是 一个数值(可以是整数也可以是浮点数），中间是•个大写或小写的字母E,后面是10的幂中的指数， 该幂值将用来与前面的数相乘。下面是一个使用e表示法表示数值的例子: var floatNum = 3.125e7;	〃等于 31250000
在这个例子中，使用e表示法表示的变童fl〇atNum的形式虽然简洁，但它的实际值则是31250000。 在此，e表示法的实际含义就是"3.125乘以107"。
也可以使用e表示法表示极小的数值，如〇.〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇03,这个数值可以使用更简洁的3e-17 表示。在默认情况下，ECMASctipt会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法 表示的数值(例如，0.0000003会被转换成3e-7)。
浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1加0.2 的结果不是0.3,而是0.30000000000000004。这个小小的舍人误差会导致无法测试特定的浮点数值。 例如:
if (a + b == 0.3) {	//不要做这样的測试!
alert<"You got 0.3."};
}
在这个例子中，我们测试的是两个数的和是不是等于0.3。如果这两个数是0.05和0.25,或者是0.15 和0.15都不会有问题。而如前所述，如果这两个数是0.1和0.2,那么测试将无法通过。因此，永远不 要测试某个特定的浮点数值。
关于浮点数值计算会产生舍入误差的问题，有一点需要明确:这是使用基于 IEEE754数值的浮点计算的通病，ECMAScript并非独此一家;其他使用相同数值格
式的语言也存在这个问题。
由于内存的限制，ECMAScript并不能保存世界上所有的数值。ECMAScript能够表示的最小数值保 存在Number.MlN_VALUE中一在大多数浏览器中，这个值是5*^324;能够表示的最大数值保存在 Nun〇Der.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的 结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的infinity值。具 体来说，如果这个数值是负数，则会被转换成-infinity (负无穷），如果这个数值是正数，则会被转
换成Inf inity (正无穷）。
如上所述，如果某次计算返回了正或负的Infinity值，那么该值将无法继续参与下一次的计算， 因为infinity不是能够参与计算的数值。要想确定-个数值是不是有穷的(换句话说，是不是位于最 小和最大的数值之间），可以使用isFiniteU函数。这个函数在参数位于最小与最大数值之间时会返
回true,如下面的例子所示:
var result = Number.MAX_VALUE + Number.MAX_VALUE? alert(isFinite(result)); //false
尽管在计算中很少出现某些值超出表示范围的情况，供在执行极小或极大数值的计算时，检测监控 这些值是可能的，也是必需的。
访问 Number.NEGATIVB_INFINITY 和 Number.POSITIVE—iENFINITY 也可以 得到负和正Infinity的值。可以想见，这两个属性中分别保存着-Infinity和 Infinity  

**3. NaN**  

NaN,即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操 作数未返冋数值的情况(这样就不会抛出错误了 )。例如，在其他编程语言中，任何数值除以〇都会导 致错误，从而停止代码执行。但在ECMAScript中，任何数值除以0会返回NaN,因此不会影响其他代 码的执行。
NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作(例如NaN/10 )都会返冋NaN,这 个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代 码会返回false:
alert(NaN == NaN); //false
针对NaN的这两个特点，ECMAScript定义了 isNaN(函数。这个函数接受一个参数，该参数可以 是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaNO在接收到一个值之后，会尝试 将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串"10 "或Boolean值。而任何 不能被转换为数值的值都会导致这个函数返回true。请看下面的例子:
```
alert(isNaN(NaN)); alert(isNaNtlO))? alert(isNaN("10")); alert(isNaN("b1ue")); alert(isNaN(true));
//true
//false (10是一个数值）
"false (可以被样换成数值10)
//true (不能转換成数值）
"false (可以祓转换成数值
```
NumberExample03.htm
```
var numl = Number("Hello world!")?
var num2 = Number("");
var num3 = Number("000011");
var num4 = Number(true);
```
这个例子测试了 5个不同的值。测试的第--个值是NaN本身，结果当然会返冋true。然后分别测 试了数值丨0和字符串"10■，结果这两个测试都返NT false, W为前者本身就是数值，而后者可以被 转换成数值。但是，字符串"blue*不能被转换成数值，因此函数返回了 true。由于Boolean值true 可以转换成数值1,因此函数返回false。
0
	尽管有点儿不可思议，但iBNaNU确实也适用于对象。在基于对象调用iBNaN(
函数时，会首先调用对象的valueOfO方法，然后确定该方法返回的值是否可以转 换为数值。如果不能，則基于这个返回值再调用toString(方法，再测试返回值。 而这个过程也是ECMAScript中内置函数和操作符的一般执行流程，更详细的内容请 参见3.5节。
4.数值转换
有3个函数可以把非数值转换为数值:NumbeirO、parselnt()和parseFloatU。第一个函数, 即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个 函数对于同样的输人会有返回不同的结果。
Number ()函数的转换规则如下。
- [ ] 如果是Boolean值，true和false将分别被转换为1和0。
- [ ] 如果是数字值，只是简单的传人和返回。
- [ ] 如果娃null值，返回0。
- [ ] 如果是undefined,返间NaN。
- [ ] 如果是字符串，遵循下列规则:
- [ ] 如果字符串中只包含数字(包括前面带正号或负号的情况），则将其转换为十进制数值，即”1。
会变成1, -123"会变成123,而"011•会变成11 (注意:前导的零被忽略了）;
- [ ] 如果字符串中包含有效的浮点格式，如U.1•，则将其转换为对应的浮点数值(同样，也会忽 略前导零);
- [ ] 如果字符串中包含冇效的十六进制格式，例如”0xf",则将其转换为相同大小的十进制整 数值;
- [ ] 如果字符串是空的(不包含任何字符)，则将其转换为0;
- [ ] 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。
- [ ] 如果是对象，则调用对象的valueOfU方法，然后依照前面的规则转换返问的值。
- [ ] 如果转换 的结果是NaN,则调用对象的t〇String()方法，然后再次依照前面的规则转换返回的字符 串值。  

根据这么多的规则使用Number 〇把各种数据类型转换为数值确实有点复杂。下面还是给出几个具 体的例子吧。
首先，字符串"Hello world!"会被转换为NaN,因为其中不包含任何有意义的数字值。空字符串 会被转换为0。字符串"000011"会被转换为丨丨，W为忽略了其前导的零。最后，true值被转换为I。
一元加操作符(3.5.丨节将介绍）的搮作与Number()函教相同。
由于Number ()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是
parselnt()函数。parselntU闲数在转换字符串时，更多的是呑其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不足数字字符或者负号，parselntO 就会返问NaN;也就是说，用parselnt()转换空字符串会返I^lNaNfNumberf)对空字符返间0)。如 果第一个字符是数宇字符，parseint ()会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。例如，"1234blue"会被转换为1234,因为"blue"会被完全忽略。类似地，-22.b* 会被转换为22,因为小数点并不是有效的数字字符。
如果字符串中的第一个字符是数字字符，parselntO也能够识别出各种整数格式(即前面讨论的 十进制、八进制和十六进制数)。也就是说，如果字符串以_0x开头且后跟数字字符，就会将其当作一 个十六进制整数;如果字符串以"0"开头且后跟数字字符，则会将其当作一个八进制数来解析。
为f更好地理解parseint ()函数的转换规则，下面给出一些例P:
```
var nuinl var nuin2 var num3 var nuir»4 var nuro5 var num6 var num7
=parselnt("1234blue");
=parselnt("");
=parselnt("OxA-);
=parselnt{22.5);
=:parseint<"070，;
=parselnt("70");
=parselnt("Oxf*);
// 1234
// NaN
// 10 (十六进制数)
"22
// 56 (八进釗数） // 70 (十进制数）
// 15 (十六进制敫)
```
NumberExample05. htm
在使用parselnt(解析像八进制字面M:的字符串时，ECMAScript3和5存在分歧。例如:
//ECMAScript 3认为是56 (八进制），ECMAScript 5认为是0 (十进制） var num = parselnt{■070•);
在ECMAScript3JavaScript引擎中，’_070•被3成八进制字面fi,因此转换后的值是十进制的56。 而在ECMAScript 5 JavaScript引擎中，.parselnt:(已经不具棚析八进制值的能力，因此前导的零会 被认为无效，从而将这个值当成结果就得到十进制的0。在ECMAScript5中.即使是在严格模式 下也会如此。
为了消除在使用parselnt (函数时可能导致的上述闲惑，可以为这个函数提供第二个参数:转换 时使用的基数(即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数16作为第 二个参数，可以保证得到正确的结果，例如:
var num = parselnt("OxAF", 16);	//175
实际上，如果指定了 16作为第二个参数，字符审可以不带前面的-ox",如下所示:
```
var numl = parselnt ("AF", 16);	"175
var num2 = parselnt{"AF");	//NaN
NumberExample06. htm
Q
var numl = parselntClO*, 2);
var num2 = parselnt("10", 8};
var num3 = parselnt("10", 10);
var num4 = parselnt("_10", 16);
```
NumberExampleO 7. htm
不指定基数意味着让parselntO决定如何解析输人的字符串，因此为了避免错误的解析，我们建 议无论在什么情况下都明确指定基数。
多数情况下，我们要解析的都是十进制数值，因此始终将10作为第二个参教是 非常必要的。
与parselnt (函数类似，parseFloat <)也是从第-个字符(位置0 )开始解析每个字符。rftf且 也是一直解析到字符串末尾，或#解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第 一个小数点是有效的，而第二个小数点就是无效的了，W此它后面的字符串将被忽略。举例来说， "22.34.5"将会被转换为22.34。
除了第一个小数点有效之外，parseFloat ()与parseint ()的第二个区别在于它始终都会忽略前导 的零。parseFloatO可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格 式的字符串则始终会被转换成0。由丁• parseFloat ()只解析I•进制值，因此它没有用第二个参数指定基 数的用法。最后还要注意一点:如果字符串包含的是-个可解析为整数的数(没有小数点，或者小数点后 都是零），parseFloatO会返冋整数。以下是使用parseFloatO转换数值的几个典型示例。
```
var muni = parsGFloat("1234blue")i
var num2 = parseFloat("0xA°);
var r.um3 = parseFloat ("22.5"};
var r.uin4 c parseFloat ("22.34.5");
var num5 = parseFloat(^0908.5");
var nun»6 = parseFloat {"3.125e7");
//1234	(整数）
//0
"22.5
"22.34
//908.5
//31250000
```
NumberExampie08.htm
###  3.4.6 String 类型
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即卞符串。字符串可以由双 引号("）或单引号(|)表示，W此下面两种宇符串的写法都是有效的:
```
var firstName
"Nicholas"
var lastName = 'Zakas';
```
与PHP中的双引号和单引号会影响对字符串的解释方式不同，ECMAScript中的这两种语法形式没 有什么区别。用双引号表示的字符串和用单引号表示的字符串完全相同。不过，以双引号开头的字符串
这个例子中的第一个转换成功了，而第二个则失败了。差别在于第-个转换传人了基数，明确传诉 parseintU要解析一个卜六进制格式的字符串;而第二个转换发现第'-个字符不是数字字符，闲此就 自动终止了。
指定基数会影响到转换的输出结果。例如:
也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。例如，下面这种字符串表示法会导 致诺法错误:
var firstName = 'Nicholas"; // 语法嫌误■(左右引号必用Sfc)
字符字面置
String数据类型包含一些特殊的字符字面ft,也叫转义序列，用于表示非打印字符，或者具有其 他用途的字符。这些字符字面M如下表所示:
字面置	含义
\'	单引号< 1 ),在用单引号表示的字符串中使用。例如:’He said, Vhey.\__
\*	双引号(* ),在用双引号表示的字符串中使用。例如:_He said, \-hey.\-"
\xnfi	以十六进制代码rai*示的一个字符(其中n_/0~F)。例如，\x41表示-A»
\unnnn	以十六进制代码mnn*示的一个Unicode字符(其中n*0~F)。例如，\u〇3a3表示希腊T符S
这些字符字面ft可以出现在字符串中的任意位置，而且也将被作为一个字符来解析，如下面的例子 所示:
var text = "This is the letter sigma: \u03a3.";
这个例子中的变量text有28个字符，其中6个字符长的转义序列表示〖个字符。
任何字符串的长度都可以通过访问其length属性取得，例如:
alert(text.length); // 出 28
这个属性返回的字符数包括16位字符的数目。如果字符串中包含双字节字符，那么length属性 可能不会精确地返回字符串中的字符数目。
字符串的特点
ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变 某个变最保存的宇符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变最， 例如:
```
var lang = •Java**;
Xang = lang + "Script";
```
以上示例中的变量lang开始时包含字符串-Java•。而第二行代码把lang的值重新定义为"java" 与"Scrip.t"的组合，EP"JavaScript"。实现这个操作的过程如下:首先创建一个能容纳10个字符的 新字符串，然后在这个字符串中填充-Java•和-Script•，域后一步是销毁原来的宇符串-java■和字 符串"Script",因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版木的

34 第3章基本概念
-10-
"Lrue"
"null-
"undefined"
StringExample03. htm
alert (Strmg(valuel));
alert(String(valu〇2));
alert(Scring(value3));
alert(String(value4));
var num - 10;
alert(num.toString());
alert(num.toSLring(2));
alert(num.toString(8));
alert{num.tostring(10));
alert!num.toStrina(16));
StringExample02, him
通过这个例子可以S-出，通过指定基数，t〇String()方法会改变输出的值。而数值10根据基数的 不N,"丨以在输出时被转换为不同的数值格式。注意，默认的(没有参数的）输出值与指定基数10时 的输出值相间。
在不知道要转换的值楚不是null或undefined的情况下，还可以使用转型函数String( ,这个 闲数能够将任何类塑的值转换为字符串。Strings函数遵循下列转换规则:
□如果值有toString (方法，则调用该方法(没存参数）并返回相戍的结果;
□如果值是null,则返冋•null11;
□如果值是 undefined,则返IsJ’undefined"。
下面再看几个例子:
```
. var valuel ^ 10;
var value2 = true; var value3 = null; var value4;
```
浏览器(例如版本低于1.0的Firefox、IE6等）中拼接字符串时速度很慢的原因所在。但这些浏览器后 来的版本已经解决了这个低效字问题。
$专换4字符$
要把-个值转换为-个字符串有两种方式。第一种足-使用几乎每个值都有的Costring <)方法(第 5章将讨论这个方法的特点)。这个方法唯一要做的就是返间相应值的字符串表现。来看下面的例子:
var age = 11;
var ageAsString = age.toString() ;	// 字符串 ”11**
var tound = true;
var foundAsString •: found. Lost ring () ;	// 字符事•true”
StringExample01.htm
数值、布尔值、对象和字符串值(没错.每个字符申也都有一个t〇String()方法，该方法返冋字 符中的一个副本）都有toString(方法。但null和undefined值没有这个方法。
多数怙况下，调用t〇String()方法不必传递参数。但是，在调用数值的t〇String(方法时，可 以传递一个参数:输出数值的基数。默认情况下，toStringU方法以十进制格式返回数值的字符串表 示。IW通过传递基数，L〇String<)nJ•以输出以二进制、八进制、十六进制，乃至其他任意有效进制格 式衣示的字符串值3下而给出几个例了•:
/ / / / / / / /
o
• 1 **
0 0 2 0" 1 1 X 1 3
/ / / / / / / / / /

3.4数据类型	35
这里先后转换了 4个值:数值、布尔值、null和undefined。数值和布尔值的转换结果与调用 toStringU方法得到的结果相同。因为null和undefined没々'toStringU方法，所以String <) 函数就返回了这两个值的字面童。	•
要把某个值转换为字符串，可以使用加号操作符(3.5节讨论）把它与一个字符 串(” * )加在一起。
###  3.4.7 Object 类型
ECMAScript中的对象艽实就是一组数据和功能的集合。对象可以远过执行new操作符后跟要创建 的对象类型的名称來创建。而创建Object类型的实例并为其添加属性和(或）方法，就可以创建定 义对象，如下所示:
var 〇 = new ObjectO;
这个语法与Java中创建对象的语法相似;但在ECMAScript中，如果不给构造函数传递参数，则扣 以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那 对圆括号(但这不是推荐的做法）:
var 〇 = new Object; //有效，位不推存省略SB括号
仅仅创建Object的实例并没有什么用处，似关键是要理解一个重要的思想:即在ECMAScript中， (就像Java中的java.lang.Object对象一样）Object类塑是所有它的实例的基础。换句话说， Object类型所具有的任何属性和方法也同样存在于更具体的对象中。
Object的每个实例都具有下列属性和方法。
21.4.6Constructor:保存着用于创建?^前对象的函数。对于前面的例子时言，构造函数(constructor) 就是 Object (。
21.4.7hasOwnProperty{propertyWaj7?e:用于检查给定的M性在5前对象实例中(而不是在实例 的原型中）是否存在。其中，作为参数的属性名(propertyWa/ne〉必须以字符串形式指走(例 如:o.hasOwnProperty ("name") )〇
21.4.8isPrototypeOf(object):用于检査传人的对象是否是另一个对象的原型(第5章将讨论原 型）。
21.4.9propertylsEnumerable(propertyWajne):用于检查给定的属性是诉能够使用f〇r-in语句 (本章后面将会讨论）来枚举。与hasOwnProperty ()方法一样，作为参数的域性名必须以字符 串形式指定。
21.4.10toLocaleStringU:返回对象的字符串表尔，该字符串与执行环境的地区对应。
21.4.11toString():返回对象的字符串表示。
21.4.12valueOf():返回对象的字符串、数值或布尔值表示。通常与tostring()方法的返丨封值 相同。
由于在ECMAScript中Object是所冇对象的基础，因此所有对象都具有这共基木的属性和方法。 第5章和第6章将详细介绍〇bj ect与其他对象的关系。

36 第3章基本概念
0
从技术角度讲，ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。 浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是 由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此宿主对象可能会也 可能不会继承Object。
##  3.5 操作符
ECMA-262描述了一组用于操作数据值的操作符，包括算术操作符(如加号和减号）、位操作符、 关系操作符和相等操作符。ECMAScript操作符的与众不同之处在于，它们能够适用于很多值，例如字 符串、数字值、布尔值，甚至对象。不过，在应用于对象时,相应的操作符通常都会调用对象的valueOf ( 和(或）toString (方法，以便取得可以操作的值。
□一元操作符
只能操作一个值的操作符叫做一元操作符。一元操作符是ECMAScript中最简单的操作符。
1.递增和递减操作符
递增和递减操作符直接借鉴自C,而且各有两个版本:前置型和后置型。顾名思义，前置型应该位 于要操作的变量之前，而后置型则应该位于要操作的变量之后。因此，在使用前置递增操作符给一个数 值加1时，要把两个加号(++)放在这个数值变量前面，如下所示:
var age = 29;
++age;
在这个例子中，前置递增操作符把age的值变成了 30 (为29加上了 1 )。实际上，执行这个前置递 增操作与执行以下操作的效果相同:
var age = 29; age = ag« * 1;
执行前置递减操作的方法也类似，结果会从一个数值中减去丨。使用前置递减操作符时，要把两个 减号(--)放在相应变量的前面，如下所示:
var age = 29;
一一age;
这样，age变童的值就减少为28 (从29中减去了 1 )。
执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。(在计算机科学领域，这种 情况通常被称作副效应。）清看下面这个例子。
var age * 29;
var anotherAge = --age +2;
alert(age);
alert(anotherAgo);
//输出28 //输出30
IncrementDecrementExampleOI. htm

3.5操作符 37
这个例子中变董anotherAge的初始值等于变量age的值前置递减之后加2。由于先执行了减法操 作，age的值变成了 28,所以再加上2的结果就是30。
由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。再看一个例子:
var numl =2; var num2 =20;
var num3 = --numl + num2;	// 等于 21
var num4 = numl + nuni2;	// 等于 21
IncrementDecrementExample02.htm
在这里，num3之所以等于21是因为numl先减去了 1才与num2相加。而变M num4也等于21是 因为相应的加法操作使用了 numl减去1之耵的值。
后置型递增和递减操作符的语法不变(仍然分别是和只不过要放在变量的后面而不是前面。 后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求 值之后才执行的。这个区别在某些情况下不是什么问题，例如:
var age = 29; age-»4;
把递增操作符放在变最后面并不会改变语句的结果，因为递增是这条语句的唯一操作。但是，当语 句中还包含其他操作时，上述区別就会非常明显了。请看下面的例子:
var numl = 2; var num2 =20;
var num3 麵 numl-- + num2;	// 等于 22
var num4 = numl + num2;	// 等于 21
lncrementDecrementExample03.htm
这里仅仅将前置递减改成了后畀递减，就立即可以看到差别。在前面使用前置递减的例子中，nUm3 和num4最后都等于21。而在这个例子中，num3等于22, mim4等于21。差别的根源在于，这里在计 算num3时使用了 iimnl的原始值(2 )完成了加法i十算，而mam4则使用了递减后的值(1 )。
所有这4个操作符对任何值都适用，也就是它们不仅适用于整数，还4以用于字符串、布尔值、浮 点数值和对象。在应用于不同的值时，递减和递减操作符遵循下列规则。
□在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字 符串变量变成数值变量。
□在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN (第4章将详细讨论)。 字符串变量变成数值变量。
□在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。 □在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变变成数值变ft。 □在应用丁•浮点数值时，执行加减1的操作。
□在应用于对象时，先调用对象的valueOf (方法(第5章将详细讨论）以取得-个可供操作的 值。然后对该值应用前述规则。如果结果娃NaN,则在调用toString()方法后再应用前述规 则。对象变S变成数值变量。
以下示例展示了上面的一些规则:

38 第3幸基本概念
sl = «»s 二
s2 - hs2
s3 = +s3
b <= +b;
f - +f;
O - +c ;
var sl -，_2"; var s2 = "z"? vac b = false; var f. = 1.1; var o = {
valueof: function() { return -1?
)
;
sl++; s2++? bt--* ;
f —;
//值变成数值3
//值变成NaN
//值变成数值i
//值变成0.100000G0000000009 (由于浮点含人铋谈所致）
//值变成数值--2
IncrementDecrementExample04. htm
2.—元加和减操作符
绝大多数开发人员Xt—元加和减操作符都不会陌牛，而且这两个ECMAScript操作符的作用与数学
书卜.讲的完全一样。一元加操作符以-个加号(+ )表示，放在数值前面，对数值不会产生任何影响，
如下而的例子所示:
var mo =? 25;
num = +nu!n;	// 仍然是之5
不过，在对非数值应用一元加操作符时，该操作符会像Number 〇转型涵数一样对这个值执行转换。
换句话说，布尔值false和tnae将被转换为0和1,字符串值会被按照一组特殊的规则进行解析，而
对象是先调用它们的valueOf ()和(或）toString <)方法，洱转换得到的值。
下面的例子展示了对不同数据类型应用一元加操作符的结果:
var sl = M0i*;
_ var s2 = "1.1";
var s3 s nz";
var b = false;
var £ r 1.1;
var o = {
valueOf: function() {
return -1;
}
};
VnaryPlusMinusExampleOl. htm
—元减操作符主要用于表示负数，例如将i转换成-1。下面的例子演示了这个简单的转换过程:
var num = 25;
nuiu = -num; // 变成了-25
是
igiaN值仍值 数数Nft，&- 成成成成变成 变变变变未变 值值值值值值
//////
//////

//值变成了数值-i
//值变成了麩值-1.1 //值变成了 NaN //值变成了数值0 // 变成了-1.1
在将一元减操作符应用于数值时，该值会变成负数(如上面的例子所示)。而当应用于非数值时， 一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下面的例子所示:
```
var si = "01"; var s2 = "1.1"; var s3 = "z_; var b = false; var f = 1.1; var o = {
valueOf: function() { return -1;
}
;
a
〇 = -〇;	//值变成了数值1
```
一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类塑。
###  3.5.2 位操作符
位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中的所有数 值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位 的整数，然后执行操作，最后再将结果转换冋64位。对于开发人员来说，由于64位存储格式是透明的, 因此整个过程就像是只存在32位的整数一样。
对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号:〇表示正 数，丨表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以 纯二进制格式存储，31位中的每一位都表示2的幂。第一位(叫做位0)表示2°,第二位表示21,以此 类推。没有用到的位以0填充，即忽略不计。例如，数值18的二进制表示是 OOOOOOOOOOOOOOOOOOOOOOOOOOOlOCilO,或者更简洁的lOOlOo这是5个有效位，这5位本身就决定了实 际的值(如图3-1所示)。
18
图3-1
负数同样以—进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下 列3个步骤:
12 3
S3S
-b-f
12 3 s s S

40 第3章基本概念
3.求这个数值绝对值的二进制码(例如，要求-18的二进制补码，先求18的二进制码);
4.求二进制反码，即将0替换为1，将1替换为0;
5.得到的二进制反码加1。
要根据这3个步骤求得-18的二进制码，首先就要求得18的二进制码，即:
0000 0000 0000 0000 0000 0000 0001 0010
然后，求其二进制反码，即0和丨互换:
1111 1111 1111 1111 1111 1111 1110 1101
最后，二进制反码加1:
1111 1111 1111 1111 1111 1111 1110 1101
1
1111 1111 1111 nil 1111 1111 1110 1110
这样，就求得了-丨8的二进制表示，即lmiiimmimmimmoiiio。要注意的是，在处理有 符号整数时，是不能访问位31的。
ECMAScript会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时, 我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示:
var num = -18;
alert(num.CoString(2));	// "-10010"
要把数值-丨8转换成二进制字符串时，得到的结果是"-10010•。这说明转换过程理解了二进制补+ 码并将其以更合乎逻辑的形式展示了出来。
默认情况下，ECMAScript中的所有整數都是有符号整数。不过，当然也存在无 符号整数。对于无符号整數来说，第32位不再表示符号，因为无符号整数只能是正 教。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示 數值。
在ECMAScript中，当对数值应用位操作符时，后台会发生如下转换过程:64位的数值被转换成32 位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这样，表面上看起来就好像是在操 作32位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重 的副效应，即在对特殊的NaN和infinity值应用位操作时，这两个值都会被当成0来处理。
如果对非数值应用位操作符，会先使用Number (函数将该值转换为一个数值(自动完成)，然后 再应用位操作。得到的结果将是一个数值。
按位非(NOT)
按位非操作符由一个波浪线(~)表示，执行按位非的结果就是返回数值的反码。按位非是 ECMAScript操作符中少数几个与二进制计算有关的操作符之一。下面看一个例子:
var auml = 25;	// 二进制 00000000000000000000000000011001
var nura2 = -numl;	// 二进《 mmilllUlllllllllllllllOOllO
alert(num2)?	// -26
BitwiseNotExample01.htm



3.5操作符 41
这里，对25执行按位非操作，结果得到了-26。这也验证了按位非操作的本质:操作数的负值减1。 因此，下面的代码也能得到相同的结果:
var numl = 25;
var num2 = -numl - 1;
alert(num2);	//
虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底层执行操作，因此速度更快。
按位与(AND)
按位与操作符由一个和号字符(&)表示，它有两个操作符数。从本质上讲，按位与操作就是将两 个数值的每-位对齐，然后根据下表中的规则，对相同位置上的两个数执行AND操作:



简而言之，按位与操作只在两个数值的对应位都是1时才返回1,任何一位是0,结果都是0。 下面肴一个对25和3执行按位与操作的例子:



var result = 25 & 3; alert(result);	//I
BitwiseAndExampleOl. htm
可见，对25和3执行按位与操作的结果是丨。为什么呢？请看其底层操作:
25 = 0000 0000 0000 0000 0000 0000 0001 1001 3 = 0000 0000 0000 0000 0000 0000 0000 0011
AND = 0000 0000 0000 0000 0000 0000 0000 0001
原来，25和3的二进制码对应位上只有一位间时是1,而其他位的结果0然都是0,因此最终结果 等于U
按位或(OR)
按位或操作符由一个竖线符号(丨）表示，同样也有两个操作数。按位或操作遵循下面这个真值表。



由此可见，按位或操作在有--个位是1的情况下就返间1,而只有在两个位都是0的情况下才返回〇。
如果在前面按位与的例子中对25和3执行按位或操作，则代码如下所示:
var result = 25 i 3;
alert(result);	//27
BitwiseOrExampieOI.htm

42 第3章基本概念
25与3按位或的结果是27:
25 = 0000 0000 0000 0000 0000 0000 0001 1001 3 = 0000 0000 0000 0000 0000 0000 0000 0011
OR S 0000 0000 0000 0000 0000 0000 0001 1011
这两个数值的都包含4个1, W此可以把每个1直接放到结果中。二a制码11011等于十进制值27。
按位异或(XOR)
按位异或操作符由一个插人符号(A)表示，也有两个操作数。以下是按位异或的真值表。
按位异或与按位或的不同之处在于，这个操作在两个数值对应位t:只有一个1时才返冋1,如果对 应的两位都是1或都是0,则返回0。
对25和3执行按位异或操作的代码如下所示:
var result = 25 A 3; alert(result);	//26
BitwiseXorExample01.htm
25与3按位异或的结果是26，其底层操作如下所示:
25 = 0000 0000 0000 0000 0000 0000 0001 1001 3 = 0000 0000 0000 0000 0000 0000 0000 0011
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
这两个数值都包含4个1,但第一位上则都是1,因此结果的第一位变成了 0。而其他位上的1在另 一个数值中都没有对应的1，可以直接放到结果中。二进制码11010等于十进制值26 (注意这个结果比 执行按位或时小1 )。
5.左移
左移操作符由两个小于号(《)表示，这个操作符会将数值的所有位向左移动指定的位数。例如， 如果将数值2 (二进制码为10)向左移动5位，结果就是64 (二进制码为1000000),代码如下所示:
var oldValue = 2;	// 等于二进制的10
var newValue = oldValue « 5?	// 等于二进制的 1000000,十进制的 64
LeftShiftExampleOl. htm
注意，在向左移位后，原数值的右侧多出了5个空位。左移操作会以0来填充这些空位，以便得到 的结果是一个完整的32位二进制数(见图3-2 )。





3.5操作符 43
隐藏的符号位	数值2
I	_	.	.	.	■
将数值2向左移动5位(得到64)
0

以0填充
图3-2
注意，左移不会影响操作数的符号位。换句话说，如果将-2向左移动5位，结果将是-64,而非64。 6.有符号的右移
有符号的右移操作符由两个大于号(》)表示，这个操作符会将数值向右移动，但保留符号位(即 正负号标记)。有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2:
var oldValue = 64;	// 等于二进制的 1000000
var newValue = oldValue » 5;	//等于二进剩的10，即十进制的2
SignedRightShiftExampleOl .htm
同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左側、符号位的 右侧(见图3-3)。而此时ECMAScript会用符号位的值来填充所有空位，以便得到一个完整的值。
隐藏的符号佼	数值64
将数值64向右移动5位(得到2
〇|〇|〇|〇|〇|〇|〇|〇|〇|〇[〇|〇l〇|〇|〇|〇|〇|〇[〇|〇|〇[〇|〇j〇|l|〇
以0填充(符号位的值）
图3-3
7.无符号右移
无符号右移操作符由3个大于号(》)表示，这个操作符会将数值的所有32位都向右移动。对正 数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将64无符号右 移5位，结果仍然还是2:
var oldValue = 64;	// 等于二进命J的 1000000
var newValue = oldValue » 5;	// 等于二进制的 10 ,即十进制的 2



UnsignedRightShiftExampleOl. htm
但是对负数来说，情况就不一样了。首先，无符号右移是以0来填充空位，而不是像有符号右移那 样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不

44 第3章基本概念
一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对 值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示:
var oldValue = -64;	// 等于二进制的 11111111111111111111111111000000
var newvalue = oldValue » 5;	// 等于十进制的 134217726
UnsignedRigIuShiftExample02.htm
这里，当对-64执行无符号右移5位的操作后，得到的结果是134217726。之所以结果如此之大， 是因为-64的二进制码为11 111 11111 111 11 111 1111 111 1000000,而且无符号右移操作会把这个二进制码当 成正数的二进制码，换算成十进制就是4294967232。如果把这个值右移5位，结果就变成了 00000111111111111111111111111110,即十进制的 134217726。
###  3.5.3 布尔操作符
在一门编程语言中，布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力，那么 诸如i f ... else和循环之类的语句就不会有用武之地了。布尔操作符一共有3个:非(NOT )、与(AND ) 和或(OR)。
□逻辑非
逻辑非操作符由一个叹号(！）表示，可以应用于ECMAScript中的任何值。无论这个值是什么数据 类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再 对其求反。也就是说，逻辑非操作符遵循下列规则:
□如果操作数是一个对象，返回false;
□如果操作数是一个空字符串，返回true;
□如果操作数是一个非空字符串，返回false;
□如果操作数是数值0,返回true;
口如果操作数是任意非0数值(包括infinity ),返回false;
□如果操作数是null,返冋true;
□如果操作数是NaN，返回true;
□如果操作数是undefined,返凹true。
下面几个例子展沿了应用上述规则的结果:
alert(!false);	if	true
alert(!"blue");	//	false
alert(!0);	ll	true
alert(!NaNJ;	//	true
alert(!"");	ft	true
alert(112345);	//false
LogicalNotExampleOl. him
逻辑丨卩操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际 上就会模拟Boolean (转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布 尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结 果与对这个值使用Boolean(函数相同，如下面的例子所示:

3.5操作符 45



逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况 下，逻辑与操作就不一定返M布尔值;此时，它遵循K列规则:
□如果第一个操作数是对象，则返回第二个操作数;
□如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返冋该 对象;
□如果两个操作数都是对象，则返回第二个操作数;
□如果有一个操作数是null,则返回null;
□如果有一个操作数是NaN,则返回NaN;
U如果有一个操作数是undefined,则返回undefined。
逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 对于逻辑与操作而言，如果第一个操作数是false,则无论第二个操作数是什么值，结果都不再可能是 true 了。来看下面的例子:



var found = true;
var result = (found && someUndefinedVariable)?
alert (result);	//这一行不会执行
//这里会发生嫌误
LogicalAndExampleOl.htm
在上面的代码中，当执行逻辑与操作时会发生错误，因为变量someUndefinedVariable没有声 明。由于变found的值是true，所以逻辑与操作符会继续对变量someUndefinedVariable求值。 但someUndefinedVariable尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义 的值。如果像下面这个例中一样，将found的值设置为false,就不会发生错误了:
var found ■ false/
var result = (found && someUndefinedVariable) ;	// 不会发生嫌误
alert (result) ;	// 会执行(*false-)
LogicalAndExampie02.htm

46 第3章基本概念
在这个例子中，警告框会显示出来。无论变董someUndefinedVariable有没有定义，也永远不 会对它求值，因为第一个操作数的值是false。而这也就意味着逻辑与操作的结果必定是false,根本 用不着再对&&右側的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。
3.逻辑或
逻辑或操作符由两个竖线符号(M)表示，有两个操作数，如下面的例子所示: var result = true I I false;
逻辑或的真值表如下:
第一个搡作数	第二个襍作数	结 果
True	false
false	true
false	false



false
与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返冋布尔值;此时，它遵循下 列规则:
□如果第一个操作数是对象，则返回第一个操作数;
□如果第-个操作数的求值结果为false,则返回第二个操作数;
□如果两个操作数都是对象，则返回第一个操作数;
口如果两个操作数都是null,则返回null;
□如果两个操作数都是NaN,则返回NaN;
Q如果两个操作数都是undefined,则返回undefined。
与逻辑与操作符相似，逻辑或操作符也是短路搡作符。也就是说，如果第一个操作数的求值结果为 true,就不会对第二个操作数求值了。下面看一个例子:



var found = true;
var result = (found I I someUndefinedVariable);
alert (result);	// 会执行(’true.)
//不会发生镁谈
LogicalOrExample01.htm
这个例子跟前面的例子一样，变量someUndef inedVariable也没有定义。但是，由于变量found 的值是true,而变量someUndefinedVariable永远不会被求值，因此结果就会输出"true"。如果 像下面这个例子一样，把found的值改为false,就会导致错误:
var £ouzid * £alse;
var result = (found II someUndef inedVariable) ?	// 这里会发生楼误
alert (result) ;	//这一行不会执行
LogicalOrExampleQ2. him
我们可以利用逻辑或的这一行为来避免为变童赋null或undefined值。例如: var myObject = preferredObject |I backupobject;
在这个例子中，变量myObject将被赋予等号后面两个值中的一个。变量preferredObject中包 含优先赋给变董myObject的值，变量backupObject负责在preferredObject中不包含有效值的

3.5操作符 47
情况下提供后备值。如果preferredObject的值不是null,那么它的值将被赋给myObject;如果 是null,则将backupObject的值赋给myObjectoECMAScript程序的赋值语句经常会使用这种模式， 本书也将采用这种模式。
###  3.5.4 乘性操作符
ECMAScript定义了 3个乘性操作符:乘法、除法和求模。这些操作符与Java、C或者Perl中的相 应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘法if嘴的某 个操作数不是数值，后台会先使用Number ()转型函数将其转换为数值。也就是说，空字符串将被当作 0,布尔值true将被当作1。
25.1乘法
乘法操作符由一个星号(*)表示，用T计算两个数值的乘积。其语法类似于C,如下面的例子 所示:
var result = 34 * 56;
在处理特殊值的情况下，乘法操作符遵循下列特殊的规则:
□如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而 如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript数值的表示范围, 则返回 Infinity 或-Infinity;
□如果有一个操作数是NaN，则结果是NaN;
□如果是Inf inity与0相乘，则结果是NaN;
□如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity,取决于有符号操作数 的符号;
□如果是Infinity与Infinity相乘，则结果是Infinity;
□如果有-••个操作数不是数值，则在后台调用NumberO将其转换为数值，然后再应用上面的 规则。
25.2除法
除法操作符由一个斜线符号(/)表示，执行第二个操作数除第一个操作数的计算，如下面的例子 所示:
var result » 66 / 11;
与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下:
□如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而 如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript数值的表示范围， 则返回 Infinity 或-Infinity;
□如果有一个操作数是NaN,则结果是Nan;
U如果是Inf inity被Infinity除，则结果是NaN;
□如果是零被零除，则结果是NaN;
□如果是非零的有限数被零除，则结果是Infinity或-Infinity,取决于有符号操作数的符号; □如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity,取决于有符号操作 数的符号;

48 第3章基本概念
口如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。 3求模
求模(余数）操作符由一个百分号(*)表示，用法如下:
var result =	% 5;	// 等于 1
与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值:
□如果操作数都是数值，执行常规的除法计算，返w除得的余数;
□如果被除数是无穷大值而除数是有限大的数值，则结果是NaN;
□如果被除数是有限大的数值而除数是零，则结果是NaN;
□如果是Inf inity被Infinity除，则结果是NaK;
□如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数;
口如果被除数是零，则结果是零;
□如果存一个操作数不是数值，则在后台调用Number ()将其转换为数值，然后再应用上面的规则。
###  3.5.5 加性操作符
加法和减法这两个加性操作符应该说是编程语言中最简单的算术操作符了。但是在ECMAScript中, 这两个操作符却都有一系列的特殊行为。与乘性操作符类似，加性操作符也会在后台转换不同的数据类 铟。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。
加法操作符(+ )的川法如F所示:
• var result =1+2;
如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果:
□如果有一个操作数是NaN,则结果是NaN;
Q 如果是 Infinity 加 Infinity,则结果是 Infinity;
□如果是-Infinity 加-Infinity,则结果是-Infinity;
口如果是Infinity■加-Infinity,则结果是NaN; a如果是+0加+0,则结果是+0;
□如果是-0加-0,则结果是-0;
口如果是+0加-0,则结果是+0。
不过，如果有一个操作数是字符串，那么就要应用如下规则:
□如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来;
□如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接 起来。
如果冇一个操作数是对象、数值或布尔值，则调用它们的t〇String(方法取得相应的字符串值， 然fe再应用前面关于字符串的规则。对于undefined和null,则分別调用String ()函数并取得字符 ■’P ’’ unde f ined ’’ 和"nul 1 * 〇 下面来举几个例子:
```
var resultl = 5 + S;	//两个数值相加
alert(resultl)?	// 10
var result2 = 5 + ■5*'; if 一个数值和一个字符串相加 alert(result2);	// "55"
```
AddExampleOl. htm
以上代码演示了加法操作符在两种模式K的差别。第一行代码演示了正常的情况，即5+5等于10 (数值)。但是，如果将一个操作数改为字符串》5»，结果就变成了(字符串值〉，因为第一个操作 数也被转换成了 ”5"。
忽视加法操作中的数据类型是ECMAScript编程中锒常见的一个错误。再来看一个例子:
```
var numl = 5; var num2 = 10;
var message = "The sum of 5 and 10 is ■ + numl + num2; alert(message);	// "The sum of 5 and 10 is 510"
```
AddExample02.htm
在这个例子中，变S message的值是执行两个加法操作之后的结果。有人可能以为最后得到的字 符串是”The sum of 5 and 10 is 15"，但实际的结果却是rtThe sum of 5 and 10 is 510”。 之所以会这样，是W为每个加法操作是独立执行的。第一个加法操作将一个宇符串和一个数值(5)拼 接广起来，结果是一个字符串。而第二个加法操作又用这个字符串去加另一个数值(10),当然也会得 到一个字符串。如果想先对数值执行算术，然后再将结果与字符串拼接起来，应该像下面这样使用 圆括号:
```
var numl =5; var num2 = 10;
var meBBage « _The flum of 5 and 10 is ” + (aunl -f num2) g
alert(message);	//"The sum of 5 and 10 is 15*
```
AddExample03. htm
在这个例子中，一对圆括号把两个数值变s括在了一起，这样就会告诉解析器先计»其结果，然后 再将结果与字符串拼接起来。因此，就得到了结果"The sum of 5 and 10 is 15”。  

**2.减法**  

减法i作符(-)是另一个极为常用的操作符，其用法如下所示: var result =2-1;
与加法操作符类似，ECMAScript中的减法操作符在处理各种数据类型转换时，同样需要遵循一些 特殊规则，如下所示:
- [ ] 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果;
- [ ] 如果有一个操作数是NaN，则结果是NaN;
Q如果是Infinity减Inf inity,则结果是NaN;
Q如果是-Infinity减-Infinity,则结果是NaN;
- [ ] 如果是 Infinity 减-Infinity,则结果是 Infinity;
- [ ] 如果是-Infinity 减 Infinity，则结果是-Infinity;
- [ ] 如果+0减则结果是+0;
- [ ] 如果昏K)减-0,则结果是-0;
- [ ] 如果是-0减-0, WIJ结果是+〇;
- [ ] 如果有一个操作数是字符串、布尔值、null或undefined,则先在后台调用Number (1函数将 其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN,则减法的结果 就足NaN;
- [ ] 如果有一个操作数是对象，则调用对象的valUe〇f<方法以取得表示该对象的数值。
- [ ] 如果得到 的值是NaN,则减法的结果就是NaN。如果对象没有valueOf(方法，则调川其toString() 方法并将得到的字符串转换为数值。  

下面几个例子展示了上面的规则:
```
var result1 var results var results var result4 var result5 var result6
=5 - true; =NaN - 1;
=b ^ 3;
=5 -
-5 - -2";
=b - null;
// 4,因为true被转换成了 1
//NaN
// 2
// 5，因为••被转换成了 0 // 3,因为_2•被转換成了 2 // 5,因为null祓转換成了 0
```
SubtractExampleOl.htm
###  3.5.6 关系操作符
小于(<)、大于()、小丁-等于(<=)和大于等于(=)这几个关系操作符用于对两个值进行比 较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值，如下面的例子所示:
```
var resultl = 5  3;	//true
var result2 = 5 < 3;	//false
```
中包含本节所有的代码片段
与ECMAScript中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换 或完成某些奇怪的操作。以下就是相应的规则。
- [ ] 如果两个操作数都是数值，则执行数值比较。
- [ ] 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- [ ] 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- [ ] 如果一个操作数是对象，则调用这个对象的vaiueOfO方法，用得到的结果按照前面的规则执 行比较。如果对象没冇valueOfO方法，则调用t〇String()方法，并用得到的结果根据前面 的规则执行比较。
- [ ] 如果-个操作数足-布尔值，则先将其转换为数值，然后再执行比较。
在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。  

很多人都会认为，在比较字符串值 时，小于的意思是“在字母表中的位置靠前”，而大T则意味着“在字母表中的位置靠后”，但实际上完 全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。经 过这么一番比较之后，#返回一个布尔值。由于大写字母的字符编码全部小于小写宇母的字符编码，因 此我们就会看到如T所示的奇怪现象:
```
var result = "Brick" < "alphabet"; //true
```
在这个例子中，字符串-Brick•被认为小于字符串"alphabet’•。原W楚字母B的字符编码为66, 而字母a的宇符编码是97。如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大 小写形式(全部大写或全部小写），然后再执行比较，如下所示:
```
var result =■ "Brick* . toLowerCase () < "alphabet* .toLowerCase ( ; //false
```
通过将两个操作数都转换为小写形式，就可以得出• a lphabet •按字母表顺序排在• Br ick •之前的 正确判断了。
另一种奇怪的现象发生在比较两个数字7-符串的悄况下，比如下面这个例子:
```
var result = "231* < "3" ; //true
```
确实，当比较字符串”23•是否小于"3•时，结果居然是true。这是W为两个操作数都是字符串， 而字符串比较的是字符编码("2的字符编码是50,而•的字符编码是5丨）。不过，如果像下面例子 中一样，将一个操作数改为数值，比较的结果就正常了:
```
var result = "23" < 3; //false
```
此时，宇符串"23”会被转换成数值23,然后再与3进行比较，因此就会得到合理的结果。在比较 数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。当然，这个规则对 前面的例子是适用的。可是，如果那个字符串不能被转换成一个合理的数值呢？比如:
var result = 'a" < 3;	// false, 因为被转换成了 NaN
由于字母"a•不能转换成合理的数值，因此就被转换成了 NaN。根据规则，任何操作数与NaN进行 关系比较，结果都是false。于是，就出现了下面这个有意思的现象:
```
var resultl = NaN < 3; //false
var result2 = NaN = 3; //false
```
按照常理，如果一个值不小于另一个值，则一•定是大丁-或等于那个值。然而，在与NaN进行比较时， 这两个比较操作的结果都返冋了 false。
###  3.5.7 相等操作符
确定两个变量是否相等是编程中的一个非常甫要的操作。在比较字符串、数值和布尔值的相等性时， 问題还比较简单„但在涉及到对象的比较时，问题就变得复杂了。锒早的ECMAScript中的相等和不等 操作符会在执行比较之前，先将对象转换成相似的类型。后来，冇人提出了这种转换到底是否合理的质 疑。最后，ECMAScript的解决方案就是提供两组操作符:相等和不相等一先转换再比较，全等和不 全等一一仅比较而不转换。
(1)相等和不相等
ECMAScript中的相等操作符由两个等于号(==)表示，如果两个操作数相等，则返回true。而不 相等操作符由叹号后跟等于号(！=)表示，如果两个操作数不相等，则返冋true。这两个操作符都会 先转换操作数(通常称为强制转型），然后再比较它们的相等性。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则:
- [ ] 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值一false转换为〇,而 true转换为1;
- [ ] 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值; □如果一个操作数是对象，另一个操作数不是，则调用对象的valueOfU方法，用得到的基本类 型值按照前面的规则进行比较;
这两个操作符在进行比较时则要遵循下列规则。
- [ ]  null和undefined是相等的。
- [ ] 要比较相等性之前，不能将mill和undefined转换成其他任何值。
- [ ] 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。  

重要提示: 即使两个操作数都是NaN,相等操作符也返回false;因为按照规则，NaN不等于NaN。 □如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 则相等操作符返N true;否则，返回false。
下表列出了一些特殊情况及比较结果:
(2)全等和不全等
除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全 等操作符由3个等于号(===)表示，它只在两个操作数未经转换就相等的情况下返回true,如下面的 例子所示:
```
var resulcl = ("55" == 55);	//true,因为转换后相辛
var result2 = ("bb" === 55);	//false,因为不同的跃搞类货不相辛
```
EqualityOperatorsExample02. him
在这个例子中，第一个比较使用的是相等操作符比较字符串"55"和数值55,结果返回了 true。如 前所述，这是因为字符串”55«先被转换成了数值55,然后再与另一个数值55进行比较。第二个比较使 用了全等操作符以不转换数值的方式比较同样的字符串和值。在不转换的情况下，字符串当然不等于数 值，因此结果就是false。
不全等操作符由一个叹号后跟两个等于号(！==)表示，它在两个操作数未经转换就不相等的情况 下返回true。例如:
```
var resultl = ('55" != 55) ;	//false,因为转换后相等
var result2 * {mbbm 1-- 55);	//true,因为不同的数振类垡不相等
```
EqualityOperatorsExample03.htm
在这个例子中，第一个比较使用了不相等操作符，而该操作符会将字符串"55”转换成55,结果就 与第二个操作数(也足55)相等了。而由于这两个操作数被认为相等，因此就返回了 false。第二个 比较使用了不全等操作符。假如我们这样想:字符串55与数值55不相同吗？，那么答案一定是:是的 (true )〇
记住:null == undefined会返回true，因为它们是类似的值;但null === undefined会返冋false,因为它们是不同类型的值。
由于相等和不相等操作符存在类型转换问题，而为了保持代码中教据类型的完整
我们推荐使用全等和不全等操作符。
###  3.5.8 条件操作符
条件操作符应该W是ECMAScript中最灵活的一种操作符了，而且它遵循与Java中的条件操作符相 同的语法形式，如下面的例子所示:
```
variable = boolean一expression ? true_value : false_value;
```
本质上，这行代码的含义就是基于对toolean_expression求值的结果，决定给变置variable K什么值。如果求值结果为true,则给变量variable陚Crue_value值;如果求值结果为false, 则给变量variable赋false_value值。冉看-个例子:
var max = (numl  nuro2) ? nuinl : nun2;
在这个例子中，max中将会保存…个最大的值。这个表达式的意思是:如果numl大于mam2 (关 系表达式返回true),则将numl的值赋给max;如果numl小于或等于num2(关系表达式返回false), 则将num2的值赋给max。
###  3.5.9 赋值操作符
简筚的赋值操作符由等于号(=)表示，其作用就是把右侧的俥赋给左侧的变量，如下面的例子所示:
```javascript
var num = 10;
```
如果在等于号(=)前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。 这种复合陚值操作相当于是对下面常规表达式的简写形式:
```javascript
var num = 10;
num = num + 10;
```
其中的第二行代码可以用一个复合赋值来代替:
```javascript
var num = 10;
num += 10;
```
每个主要算术操作符(以及个別的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示: 
- [ ] 乘/赋值(\*=);
- [ ] 除/赋值(/=);
- [ ] 模/赋值(\*=);
- [ ] 加/赋值(+=);
- [ ] 减/陚值(-=);
- [ ] 左移/赋值(&lt;&lt;=);
- [ ] 有符号右移/赋值(=);
- [ ] 无符号右移/赋值(=)。  
设计这些操作符的主要H的就是简化赋值操作。使用它们不会带来任何性能的提升。
###  3.5.10 逗号操作符
使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示:
```javascript
var nunl=l, num2=2, num3=3;
```
逗号操作符多用r•卢明多个变量;但除此之外，逗号操作符还可以用于赋值。在用丁赋值时，逗号 操作符总会返回表达式中的最后一项，如卜面的例子所示:
```javascript
var nun = (5, 1, 4, 8, 0); // num 的值为 0
```
由于0是表达式中的敢后一项，因此nura的值就足0。虽然逗号的这种使用方式并不常见，这个 例子可以帮我们理解逗号的这种行为。
##  3.6 语句
ECMA-262规定了一组语句(也称为流控制语句)。从本质上看，语句定义了 ECMAScript中的主要 语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出;也可以比 较复杂，例如指定复执行某个命令的次数。
###  3.6.1 if 语句
大多数编程语言中最为常用的一个语句就是if语句。以K屋• if语句的语法:
```javascript
if (condition) statementl else statement2
```
其中的condition (条件）町以娃任意表达式;而JL对这个表达式求值的结果不一定是布尔值。 ECMAScript会自动调用Boolean ()转换函数将这个表达式的结果转换为一个布尔值。如果对condition 求值的结果是true,则执行statementl(语句1 ),如果对condition求值的结果是false,则执行statetnent2 (语句2 )。而且这两个语句既可以是一行代码，也可以是一个代码块(以一对花括号括起来的多行代码)。 请看下面的例子。
```javascript
if (i  25)
	alert("Greater than 25.");    //单行语句
else {
	alert("Less than or equal to 25.");  //代码块中的语句
}
```
不过，业界普遍推崇的域佳实践是始终使川代码块，即使要执行的只有--行代码。w为这样可以消 除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。  
另外，也可以像下面这样把整个if语句写在-行代码中:
```javascript
if (conditionl) statementl else if (condition2) statement2 else statement3
```
但我们推荐的做法则是像下面这样:
```javascript
if (i  25) {
	alert("Greater than 25.")
} else if (i < 0) {
	alert("Less than 0.");
} else {
	alert("Between 0 and 25, inclusive.");
}
```
#### 3.6.2 do-while 语句
do-while语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。 换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是do-while语句的 语法:
```javascript
do {
statement
} while (expression);
```
下面是一个示例:
```javascript
var i = 0;
do {
   i += 2;
} while (i < 10);

alert(i);
```
在这个例子中，只要变贵i的值小于10,循环就会一直继续下去。而且变量i的值最初为0,每次 循环都会递增2。
像do-while这种后测试循环语句最常用于循环体中的代码至少要被执行一次的Y情形。			
###  3.6.3  while 语句
while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。 因引，循环体内的代码有可能永远不会被执行。以下是while语句的语法:
```javascript
while(expression) statement
```
下面是一个示例:
```javascript
var i = 0;
while (i < 10) {
   i += 2;
}
```
在这个例子中，变虽i开始时的值为0,每次循环都会递增2。而只要i的值小于10,循环就会继 续下去。
###  3.6.4 for 语句
for语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代 码的能力。以下是Eor语句的语法:
```javascript
for {initialization; expression; post-loop-expression) statement
```
下面是一个示例:
```javascript
var count = 10;
for (var i=0; i < count; i++){
	alert(i);
}
```
以上代码定义了变II i的初始值为0。只有当条件表达式(i<C〇unt )返回true的情况下才会进 人for循环，因此也有可能不会执行循环体中的代码。如果执行了循环体中的代码，则一定会对循环后 的表达式(i++ )求值，即递增i的值。这个for循环语句与下面的while语句的功能相同:
```javascript
var count = 10;
var i = 0;
while (i < count){
	alert(i);
	i++;
}
```
使用while循环做不到的，使用for循环同样也做不到。也就是说，for循环只是把与循环有关 的代码集中在了一个位置。
有必要指出的是，在for循环的变量初始化表达式中，也可以不使用var关键字。该变量的初始 化可以在外部执行，例如:
```javascript
var count = 10;
var i;
for (i=0; i < count; i++){
	alert(i);
}
```
以上代码与在循环初始化表达式中声明变最的效果是一样的。由于ECMAScript中不存在块级作用 域(第4章将进一步讨论这一点)，因此在循环内部定义的变量也可以在外部访问到。例如:
```javascript
var count = 10;
for (var i=0; i < count; i++){
	alert(i);
}
alert(i);    //10

```
在这个例子中，会有一个替告框显示循环完成后变M i的值，这个值是10。这是因为，即使i是 在循环内部定义的一个变量，但在循环外部仍然可以访问到它。
此外，for语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部 省略，就会创建一个无限循环，例如:
for (;;) {	// 无ft循坏
doSomething()?
}
而只给出控制表达式实际上就把for循环转换成了 while循环，例如:
```javascript
var count = 10;
var i = 0;
for (; i < count; ){
	alert(i);
	i++;
}
```
由于for语句存在极大的灵活性，因此它也是ECMAScript中最常用的一个语句。
###  3.6.5 for-in 语句
for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是for-in语句的语法: 
```javascript
for (property in expression) statement 
```
下面是一个示例:
```javascript
for (var propName in window) {
	 document.write(propName);
}
```
在这个例子中，我们使用for-in循环来显示了 BOM中window对象的所有属性。每次执行循环 时，都会将window对象中存在的一个属性名赋值给变ft propName。这个过程会一直持续到对象中的 所有属性都被枚举一遍为止。与for语句类似，这里控制语句中的var操作符也不是必需的。但是, 为了保证使用局部变M，我们推荐上面例子中的这种做法。  
ECMAScript对象的属性没有顺序。因此，通过 for-in循环输出的属性名的顺序是不可预测的。 具体来讲，所有《性都会被返回一次，但返回的先后次序可能会因浏览器而异。  
但是，如果表示要迭代的对象的变量值为null或undefined, for-in语句会抛出错误。 ECMAScript5更正了这一行为;对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的
兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。  

---

Safari 3以前版本的for-in语句中存在一个bug，该bug会导致某些属性被返回 两次。

---

###  3.6.6 label 语句
使用label语句可以在代码中添加标签，以便将来使用。以下是label语句的语法:
```
label: statement
```
下面是一个示例:
```javascript
start: for (var i=0; i < count; i++) { 	alert(i);
}
```
这个例子中定义的start标签可以在将来由break或continue语句引用。加标签的语句一般都 要与for语句等循环语句配合使用。
###  3.6.7 break 和 continue 语句
break和continue语句用于在循环中精确地控制代码的执行。其中.break语句会立即退出循环， 强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶 部继续执行。请看下面的例子:
```javascript
var num = 0;

for (var i=1; i < 10; i++) {
	if (i % 5 == 0) {
		break;
	}
	num++;
}

alert(num);    //4
```
这个例子中的for循环会将变量i由1递增至10。在循环体内，有一个if语句检査i的值是否 可以被5整除(使用求模操作符)。如果是，则执行break语句退出循环。另一方面，变量num从0开 始，用于记录循环执行的次数。在执行break语句之后，要执行的下一行代码是alert ()函数，结果 显示4。也就是说，在变量i等于5时，循环总共执行了 4次;而break语句的执行，导致了循环在 num再次递增之前就退出了。如果在这里把break替换为continue的话，则可以看到另一种结果:
```javascript
var num = 0;

for (var i=1; i < 10; i++) {
	if (i % 5 == 0) {
		continue;
	}
	num++;
}

alert(num);    //8
```
例+的结果显示8,也就是循环总共执行f 8次。当变tti等于5时，循环会在num再次递增之前 退出，但接下来执行的是下一次循环，即i的值等于6的循环。于是，循环又继续执行，直到i等于 10时自然结束。而num的最终值之所以是8,是因为continue语句导致它少递增了一次。
break和conUmie语句都可以与label语句联合使用，从而返回代码中特定的位置。这种联合 使用的情况多发生在循环嵌套的情况下，如下面的例子所示:
```javascript
var num = 0;

outermost:
for (var i=0; i < 10; i++) {
	 for (var j=0; j < 10; j++) {
		if (i == 5 && j == 5) {
			break outermost;
		}
		num++;
	}
}

alert(num);    //55
```
在这个例子中，outermost标签表示外部的for语句。如果每个循环正常执行10次，则num+ + 语句就会正常执行100次。换句话说，如果两个循环都自然结束，num的值应该是丨00。但内部循环中 的break语句带了一个参数:要返回到的标签。添加这个标签的结果将导致break语句不仅会退出内 部的for语句(即使用变量j的循环)，而且也会退出外部的for语句(即使用变量i的循环)。为此, 当变量i和j都等于5时，num的值正好是55。同样，continue语句也可以像这样与label语句联 用，如下面的例子所示:
var num = 0;
outermost:
for (var i=0? i < 10; i++) {
for (var j=〇; j < 10; j++) { if (i == 5 St& j == 5) { continue outeno丨t;
}
num++;
alert(num);	//95
ContinueStatementExample02.htm

60 第3章基本概念
在这种情况下，continue语句会强制继续执行循环一退出内部循环，执行外部循环。当j是5 时，continue语句执行，而这也就意味着内部循环少执行了 5次，因此num的结果是95„
虽然联用break、continue和label语句能够执行复杂的操作，但如果使用过度，也会给调试 带来麻烦。在此，我们建议如果使用label语句，一定要使《描述性的标签，同时不要嵌套过多的循环。
###  3.6.8 with 语句
with语句的作用是将代码的作用域设置到一个特定的对象中。with语句的语法如下:
with (expression) statement?
定义with语句的B的主要是为了简化多次编写同一个对象的.T作，如下面的例子所示:
var qs = location.search.substring(1); var hostName = location.hostname; var url = location.href;
上面几行代码都包含location对象。如果使用with语句，nj以把上面的代码改每成如下所示:
with(location){
var qs = search.substring(1}; var hostName = hostname? var url = href;
WithStatementExampleOl. him
在这个重写后的例子中，使用v/ith语句关联了 location对象。这意味若在with语句的代码块 内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变S的定义，就会査询 location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。 严格模式下不允许使用with语句，否则将视为语法错误。
由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此 在开发大型应用程序时，不建议使用with语句。
###  3.6.9 switch 语句
switch语句与if语句的关系最为密切，而11也是在其他语言中普遍使用的一种流控制语句。
ECMAScript中switch语句的语法与其他基于C的语言非常接近，如下所示:
```javascript
switch (expression) {
case value: statement break;
case value: statement break;
case value: statement break?
case value: statement break;
default: statement
}
```
switch语句中的每一种情形(case)的含义是:“如果表达式等于这个值(value),则执行后面的 语句(statement )”。而break关键字会导致代码执行流跳出switch语句。如果省略break关键字， 就会导致执行完当前case后，继续执行下一个case。最后的default关键字则用于在表达式不匹配前 面任何一种情形的时候，执行机动代码(因此，也相当于一个else语句。
从根本上讲，switch语句就是为了让开发人员免于编写像下面这样的代码:
```javascript
if (i == 25){
	alert("25");
} else if (i == 35) {
	alert("35");
} else if (i == 45} {
	alert{"45");
 else {
	alert("Other");
```
而与此等价的switch语句如下所示:
```javascript
var i = 25;

switch (i) {
	case 25: 
		alert("25");
		break;
	case 35: 
		alert("35");
		break;
	case 45: 
		alert("45");
		break;
	default: 
		alert("Other");
}
```
通过为每个case后面都添加一个break语句，就可以避免同时执行多个case代码的情况。假如确 实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了 break关键字，如下所示:
```
switch (i) {
	case 25: 
		/* 合并两种情况 */
	case 35: 
		alert("25 or 35");
		break;
	case 45: 
		alert("45");
		break;
	default: 
		alert("Other");
}
```
虽然ECMAScript中的switch语句借鉴自其他语言，但这个语句也有A己的特色。首先，可以在 switch语句中使用任何数据类迆(在很多其他语言中只能使用数值)，无论是字符串，还是对象都没有 问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。请看K面这个例子:
```javascript
switch ("hello world") {
	case "hello" + " world": 
		alert("Greeting was found.");
		break;
	case "goodbye": 
		alert("Closing was found.");
		break;
	default: 
		alert("Unexpected message was found.");
}
```
在这个例子中，switch语句使用的就是字符串。其中，第一种情形实际上是一个对字符串拼接操 作求值的表达式。由于这个字符串拼接表达式的结果与switch的参数相等，因此结果就会显示 "Greeting was found."。时昆，使用表达式作为case值还可以实现下列操作:
```javascript
switch ("hello world") {
	case "hello" + " world": 
		alert("Greeting was found.");
		break;
	case "goodbye": 
		alert("Closing was found.");
		break;
	default: 
		alert("Unexpected message was found.");
}
```
这个例子首先在switch语句外面声明了变量num。而之所以给switch语句传递表达式true, 是因为每个case值都可以返回一个布尔值。这样，每个case按照顺序被求值，直到找到匹配的值或者 遇到default语句为止(这正是这个例子的最终结果)。

---

switch语句在比较值时使用的是全等操作符，因此不会发生类型转换(例如, 字符串"10"不等于数值10)。

---

##  3.7 函数
函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、 任何时候调用执行。ECMAScript中的函数使用function关键字来声明，后跟--组参数以及函数体。 函数的基本语法如下所示:
```javascript
function functionName(arg0, argl,...,argN} { 	statements
}
```
以下是一个函数示例:
```javascript
function sayHi(name, message) {
	alert("Hello " + name + ", " + message);
}
```
这个函数可以通过艽函数名来调用，后面还要加上一对圆括号和参数(圆括号中的参数如果有多个, 可以用逗号隔开)。调用sayHi (函数的代码如下所示:
sayHi("Nicholas", "how are you today?*);
这个函数的输出结果是"Hello Nicholas, how are you today?•。函数中定义中的命名参数name 和message被用作了字符串拼接的两个操作数，而结果最终通过警告框显示了出来。
ECMAScript中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过 return语句后跟要返[Pi的值来实现返冋值。请看下面的例子:
```javascript
function sum(num1, num2) {
	return num1 + num2;
}
```
这个suiM)函数的作用是把两个值加起来返回一个结果。我们注意到，除了 return语句之外，没 有任何声明表示该函数会返回一个值。调用这个函数的示例代码如下:
```javascript
 var result = sum(5, 10);
```
这个函数会在执行完return语句之后停止并立即退出。因此，位于return语句之后的任何代码 都永远不会执行。例如:
```javascript
function sum(numl, num2) {
	return numl + num2;
	alert ("Hello world"); // 永远不会执行
}
```
在这个例子中，由于调用alert <)函数的语句位于return语句之后，因此永远不会显示聱告框。 当然，一个函数中也可以包含多个return语句，如下面这个例子中所示:
```javascript
function diff(num1, num2) {
	if (num1 < num2) {
		return num2 - num1;
	} else {
		return num1 - num2;
	}
}
```
这个例子中定义的diff()函数用JH十算两个数值的差。如果第一个数比第二个小，则用第二个数 减第个数否则，用第-•个数减第二个数。代码中的两个分支都具有自己的return语句，分别用于 执行正确的计算。
另外，return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined 值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。比如在下面这个例子中，就 不会M示警告框:
```javascript
function sayHi(name, message) {
	return;
	alert("Hello " + name + ", " + message);    //永远不会调用
}
```

---

推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如 果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。
严格模式对函数冇一些限制:

---

- [ ] 不能把函数命名为eval或arguments;
- [ ] 不能把参数命名为eval或arguments;
- [ ] 不能出现两个命名参数同名的情况  
如果发生以上情况，就会导致语法错误，代码无法执行。
###  3.7.1 理解参数
ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript函数不介意传递进 来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数， 在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不 会有什么怨言。之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收 到的始终都是这个数组，而不关心数组中包含哪些参数(如果有参数的话)。如果这个数组中不包含任 何元素，无听谓;如果包含多个元素，也没有问题。实际上，在函数体内可以通过arguments对象来 访问这个参数数组，从而获取传递给函数的毎一个参数。
K实，arguments对象只是与数组类似(它并不是Array的实例），W为可以使用方括号语法访 问它的每一个兀素(即第一个元素是arguments [0],第二个元素是argumetns[l],以此类推），使 用length M性来确定传递进来多少个参数。在前面的例子中，sayHi(闲数的第一个参数的名宇叫 name,而该参数的值也可以通过访问arguments [0]来获取。丙此，那个函数也可以像下面这样重写， 即不显式地使用命名参数:
```javascript
function sayHi() {
	alert("Hello " + arguments[0] + ", " + arguments[1]);
}
```

---

```javascript
function howManyArgs() {
	alert(arguments.length);
}

howManyArgs("string", 45);    //2
howManyArgs();                //0
howManyArgs(12);              //1
```
执行以上代码会依次出现3个警&框，分別显示2、0和丨。由此可见，开发人员可以利用这一点让 函数能够接收任意个参数并分别实现适当的功能。请肴下面的例子:
```javascript
function doAdd() {
	if(arguments.length == 1) {
		alert(arguments[0] + 10);
	} else if (arguments.length == 2) {
		alert(arguments[0] + arguments[1]);
	}
}

doAdd(10);        //20
doAdd(30, 20);    //50
```
函数d〇Add(会在只有一个参数的情况下给该参数加上10;如果是两个参数，则将那个参数简单 相加并返回结果。因此，doAdd(10会返回20，而doAdd<30,20则返回50。虽然这个特性算不上完 美的重载.但也足够弥补ECMAScript的这一缺憾了。
另+—个与参数相关的重要方面，就是arguments对象可以与命名参数一起使用，如下面的例子所示:
```javascript
function doAdd(num1, num2) {
	if(arguments.length == 1) {
		alert(num1 + 10);
	} else if (arguments.length == 2) {
		alert(arguments[0] + num2);
	}
}


doAdd(10);        //20
doAdd(30, 20);    //50
```
在重写后的这个doAdd<)函数中，两个命名参数都与arguments对象一起使用。由于numl的值 与arguments(0]的值相同，因此它们可以互换使用(当然，nUm2和arguments[l]也是如此）。
关于arguments的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。 例如:
这个重写后的函数中不包含命名的参数。虽然没有使用name和message标识符，但函数的功能 依旧。这个亊实说明了 ECMAScript闲数的一个重要特点:命名的参数只提供便利，但不是必需的。另 外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但 在ECMAScript中，没有这些条条框框，解析器不会验证命名参数。
通过访问arguments对象的length属性可以获知有多少个参数传递给了函数。下面这个函数会 在每次被调用时，输出传人K中的参数个数:
```javascript
function doAdd(num1, num2) {
	//if(arguments.length == 1) {
		arguments[1] = 10;
	//}
	alert(arguments[0] + num2);
}

doAdd(10, 20);        //20
doAdd(30, 20);    //50
```
每次执行这个d〇Add()函数都会重写第二个参数，将第二个参数的值修改为10。闪为arguments 对象屮的值会0动反映到对应的命名参数，所以修改arguments [1],也就修改了 nmn2,结果它们的 值都会变成10。不过，这并不是•说读取这两个值会访问相同的内存空间;它们的内存空间是独立的，但 它们的值会同步。但这种影响是单向的:修改命名参数不会改变arguments屮对应的值。另外还要记 住，如果只传人了一个参数，那么为arg咖entslir设置的值不会反应到命名参数中。这是因为 arguments对象的长度是由传人的参数个数决定的，不是出定义函数时的命名参数的个数决定的。
关于参数还要记住最后一点:没有传递值的命名参数将A动被赋予undefined值。这就跟定义f 变fi但又没有初始化一样。例如，如果只给d〇Add(函数传递了一个参数，则num2中就会保存 undefined 值 〇
严格模式对如何使用arguments对象做出了一《限制。首先，像前面例子中那样的赋值会变得无 效。也就是说，即使把arguments[l]设置为10，num2的值仍然还是undefined。其次，重写 arguments的值会导致语法错误(代码将不会执行)。

---

ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。

---

###  3.7.2 没有重载
ECMAScript函数不能像传统意义h那样实现東载。而在其他语言(如Java)中，可以为一个闲数 编写两个定义，只要这网个定义的签名(接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt 函数没有签名，因为K参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可
能做到的。
如果在ECMAScript中定义丫两个名字相同的函数，则该名字只属丁•后定义的函数。请看下面的例子:
```javascript
function addSomeNumber(num){
	return num + 100;
}

function addSomeNumber(num) {
	return num + 200;
}

var result = addSomeNumber(100);    //300
alert(result);
```
在此，函数addSomeNumber ()被定义了两次。第一个版本给参数加100,而第二个版本给参数加 200。由于后定义的函数覆盖f先定义的函数，因此岀在嵌后•行代码中调用这个函数时，返问的结果 就是300。
如前所述，通过检査传人涵数中参数的类型和数量并作出不间的反应，可以模仿方法的重载。
##  3.8 小结
JavaScript的核心语W特性在ECMA-262中是以名为ECMAScript的伪语言的形式来定义的。 ECMAScript中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但 没有对取得输人和产生输出的机制作出规定。理解ECMAScript及其纷繁复杂的各种细节，是理解其在 Web浏览器中的实现——JavaScript的关键。U前大多数实现所遵循的都是ECMA-262第3版，但很多 也已经着手开始实现第5版了。以下简要总结了 ECMAScript中基本的要素。
- [ ] ECMAScript 中的基本数据类型包括 Undefined、Null、Boolean、Number 和 String。 □与其他语言不同，ECMScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可
用丁•表示所有数值。
- [ ] ECMAScript中也冇一种复杂的数据类铟，即Object类型，该类型是这门语言中所有对象的基 础类型。
- [ ] 严格模式为这门语言中容易出错的地方施加了限制。
- [ ] ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算术操作符、布尔操作 符、关系操作符、相等操作符及陚值操作符等。
- [ ] ECMAScript从他语言中借鉴了很多流控制语句，例如if语句、for语句和switch语句等。 ECMAScript中的涵数与其他语言中的函数有诺多不同之处。
- [ ] 无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
- [ ] 实际h,未指定返凹值的函数返问的是--个特殊的undefined值。
- [ ] ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式 传递的。
- [ ] 可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。 □由于不存在函数签名的特性，ECMAScript函数不能重载。  
[上一章](https://github.com/qianjilou/javascript3/blob/master/chapter/chapter2.md)&emsp;&emsp;[下一章](https://github.com/qianjilou/javascript3/blob/master/chapter/chapter4.md)