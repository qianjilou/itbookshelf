## 第10章 php面向对象的程序设计
- [ ] 面向对象的介绍
- [ ] 如何抽象一个类
- [ ] 通过类实例化对象
- [ ] 封装性
- [ ] 继承性
- [ ] 常见的关键字和魔术方法
- [ ] 抽象类与接口
- [ ] 多态性的应用
- [ ] 面向对象版图形计算器

---

### 10.1 面向对象的介绍
#### 10.1.1 类和对象之间的关系  


```php
<?php
	class Person{
		//下面声明的是人类的成员属性，通常成员属性都在成员方法的前面声明
         var $name;            		//第一个成员属性，用于存储人的名字
         var $age;             		//第二个成员属性，用于存储人的年龄
         var $sex;             		//第三个成员属性，用于存储人的性别

		//下面声明了几个人的成员方法,通常将成员方法声明在成员属性的下面
		function say(){      		//人可以说话的方法
			echo "人在说话";   		//方法体
		}		

		function run(){      		//人可以走路的方法
			echo "人在走路";    	//方法体
		}		
	}



```




```php
<?php
	/**
		声明一个电话类,类名为Phone
	*/
	class Phone {                   
        //声明4个与电话有关的成员属性
		var $Manufacturers;     //第一个成员属性，用于存储电话的外观
		var $color;             //第二个成员属性，用来设置电话的外观颜色
		var $Battery_capacity;  //第三个成员属性，用来定义电话的电池容量
		var $screen_size;       //第四个成员属性，用来定义电话的屏幕尺寸

		//第一个成员方法用来声明电话具有接打电话的功能
		function call(){          		
            echo "正在打电话";	//方法体，可以是打电话的具体内容
		}

		//第二个成员方法用来声明电话具有发信息的功能
		function message(){       		
		    echo "正在发信息";	//方法体，可以是发送的具体信息
		}

		//第三个成员方法用来声明电话具有播放音乐的功能
		function playMusic() {    		
		    echo "正在播放音乐";	//方法体，可以是播放的具体音乐
		}

		//第四个成员方法用来声明电话具有拍照的功能
		function photo() {          	 
             echo "正在拍照";		//方法体，可以是拍照的整个过程
		}
	}



```




```php
<?php
	/**
		声明一个电话类Phone
	*/
	class Phone {             	
		//类中成员同上（略）
	}

	/**
		声明一个人类Person
	*/
	class Person {            		
		//类中成员同上（略）
	}

	//通过Person类实例化三个对象$person1、$person2、$person3
	$person1 = new Person();    //创建第一个Person类对象，引用名为$person1
	$person2 = new Person();    	//创建第二个Person类对象，引用名为$person2
	$person3 = new Person();    	//创建第三个Person类对象，引用名为$person3

	//通过Phone类实例化三个对象$phone1、$phone2、$phone3
	$phone1 = new Phone();    		//创建第一个Phone类对象，引用名为$phone1
	$phone2 = new Phone();    		//创建第二个Phone类对象，引用名为$phone2
	$phone3 = new Phone();    		//创建第三个Phone类对象，引用名为$phone3


```



```php
<?php
	/**
		声明一个人类Person，其中包含三个成员属性和两个成员方法
	*/
	class Person {
		//下面是声明人的三个成员属性
		var $name;       				//第一个成员属性$name定义人的名字
		var $sex;        				//第二个成员属性$sex定义人的性别
		var $age;        				//第三个成员属性$age定义人的年龄

		//下面是声明人的两个成员方法
		function say() {   				
			echo "这个人在说话<br>";	//在说话的方法体中可以有更多内容
		}		

		function run() {     			
			echo "这个人在走路<br>";	//在走路的方法体中可以有更多内容
		}		
	}

	//下面三行通过new关键字实例化person类的三个实例对象
	$person1 = new Person();  			//通过类Person创建第一个实例对象$person1
	$person2 = new Person();  			//通过类person创建第二个实例对象$person2
	$person3 = new Person();  			//通过类person创建第三个实例对象$person3

	//下面三行是给$person1对象中属性初始化赋值
	$person1->name = "张三"; 			//将对象person1中的$name属性赋值为张三 
	$person1->sex = "男";     			//将对象person1中的$sex属性赋值为男
	$person1->age = 20;     			//将对象person1中的$age属性赋值为20

	//下面三行是给$person2对象中属性初始化赋值
	$person2->name = "李四";     		//将对象person2中的$name属性赋值为李四
	$person2->sex = "女";        		//将对象person2中的$sex属性赋值为女
	$person2->age = 30;          		//将对象person2中的$age属性赋值为30

	//下面三行是给$person3对象中属性初始化赋值
	$person3->name = "王五";     		//将对象person3中的$name属性赋值为王五
	$person3->sex = "男";        		//将对象person3中的$sex属性赋值为男
	$person3->age = 40;          		//将对象person3中的$age属性赋值为40
	
	//下面三行是访问$person1对象中的成员属性
	echo "person1对象的名字是：".$person1->name."<br>";  	
	echo "person1对象的性别是：".$person1->sex."<br>";    	
	echo "person1对象的年龄是：".$person1->age."<br>";    	

	//下面两行访问$person1对象中的方法
	$person1->say();          		
	$person1->run();          		
	
	//下面三行是访问$person2对象中的成员属性
	echo "person2对象的名字是：".$person2->name."<br>";  	
	echo "person2对象的性别是：".$person2->sex."<br>";    	
	echo "person2对象的年龄是：".$person2->age."<br>";    	

	//下面两行访问$person2对象中的方法
	$person2->say();          		
	$person2->run();          		
	
	//下面三行是访问$person3对象中的成员属性
	echo "person3对象的名字是：".$person3->name."<br>";  	
	echo "person3对象的性别是：".$person3->sex."<br>";   	
	echo "person3对象的年龄是：".$person3->age."<br>";   
	
	//下面两行访问$person3对象中的方法
	$person3->say();          		
	$person3->run();          		


```




```php
<?php
	/** 声明一个人类Person，其中包含三个成员属性和两个成员方法 */
	class Person {             
		//下面是声明人的成员属性
		var $name;          		//定义人的名字
		var $sex;            		//定义人的性别
		var $age;           		//定义人的年龄

		//下面是声明人的成员方法
		function say(){     		
			//在类中声明说话的方法，使用$this访问自己对象内部的成员属性
			echo "我的名字：".$this->name."， 性别：".$this->sex."， 年龄：".$this->age."。<br>";
		}		
		
		//在类中声明另一个方法 
		function run(){      		
			echo $this->name."在走路<br>";    //使用$this访问$name属性
		}		
	}

	//下面三行通过new关键字实例化person类的三个实例对象
	$person1 = new Person();      
	$person2 = new Person();       	
	$person3 = new Person();       

	//下面三行是给$person1对象中属性初始化赋值
	$person1->name = "张三";     	
	$person1->sex = "男";         	
	$person1->age = 20;         

	//下面三行是给$person2对象中属性初始化赋值
	$person2->name = "李四";     	
	$person2->sex = "女";         
	$person2->age = 30;          	

	//下面三行是给$person3对象中属性初始化赋值
	$person3->name = "王五";     
	$person3->sex = "男";        	
	$person3->age = 40;          	
	
	$person1->say();     	//使用$person1访问它中的say()方法，方法say()中的$this就代表这个对象$person1
	$person2->say();     	//使用$person2访问它中的say()方法，方法say()中的$this就代表这个对象$person2
	$person3->say();     	//使用$person3访问它中的say()方法，方法say()中的$this就代表这个对象$person3



```



```php
<?php
	/** 声明一个人类Person，其中声明一个构造方法 */
	class Person {         			
		//下面是声明人的成员属性，都是没有初值的，在创建对象时，使用构造方法赋初值
		var $name;       			//定义人的名字
		var $sex;        			//定义人的性别
		var $age;        			//定义人的年龄

		//声明一个构造方法，将来创建对象时，为对象的成员属性赋予初值，参数中都使用了默认参数
		function __construct($name="", $sex="男", $age=1) {
			$this->name = $name;  	//在创建对象时，使用传入的参数$name为成员属性$this->name赋初值
			$this->sex = $sex;     	//在创建对象时，使用传入的参数$sex为成员属性$this->sex赋初值
			$this->age = $age;    	//在创建对象时，使用传入的参数$age为成员属性$this->age赋初值
		}

		//下面是声明人的成员方法
		function say(){ 
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."。<br>";
		}		

		function run(){					
			echo $this->name."在走路<br>";	
		}
	}

	//下面三行中实例化person类的三个实例对象，并使用构造方法分别为新创建的对象成员属性赋予初值
	$person1 = new Person("张三", "男", 20); //创建对象$person1时会自动执行构造方法，将全部参数传给它
	$person2 = new Person("李四", "女");     //创建对象$person2时会自动执行构造方法，传入前两个参数
	$person3 = new Person("王五");           //创建对象$person3时会自动执行构造方法，只传入一个参数

	$person1->say();     					
	$person2->say();     					
	$person3->say();     					


```

```php
<?php
	class Person {             			
		var $name;          		
		var $sex;            		
		var $age;            		
		
		function __construct($name, $sex, $age) {
			$this->name = $name;   	
			$this->sex = $sex;      	
			$this->age = $age;      
		}

		function say(){             	
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."。<br>";
		}		

		function run() {            	
			echo $this->name."在走路<br>";    
		}
		
		//声明的析构方法，在对象销毁前自动调用
		function __destruct() {
			echo "再见".$this->name."<br>";
		}		
	}

	//下面三行通过new关键字实例化person类的三个实例对象
	$person1 = new Person("张三", "男", 20); 	 //创建对象$person1 
	$person1 = null;              			  	 //第一个对象将失去引用
	$person2 = new Person("李四", "女", 30);     //创建对象$person2 
	$person3 = new Person("王五", "男", 40);     //创建对象$person3 



```

```php
<?php
	class Person  {          			
		//下面是声明人的成员属性，全都使用了private关键字封装
		private $name;     				//第一个成员属性$name定义人的名字，此属性被封装
		private $sex;      				//第二个成员属性$sex定义人的性别，此属性被封装
		private $age;      				//第三个成员属性$age定义人的年龄，此属性被封装

	    function __construct($name="", $sex="男", $age=1) {
			$this->name = $name;    	
			$this->sex = $sex;       	
			$this->age = $age;       	
		}

		//在类中声明一个走路方法，调用两个内部的私有方法完成
		function run(){              	
			echo $this->name."在走路时".$this->leftLeg()."再".$this->rightLeg()."<br>";	
		}
         
		//声明一个迈左腿的方法，被封装所以只能在内部使用
		private function leftLeg() {    	
			return "迈左腿";
		}
        
		//声明一个迈右腿的方法，被封装所以只能在内部使用
		private function rightLeg() {   	
			return "迈右腿";
		}
	}
	$person1 = new Person();         	
	
	$person1->run();               		//run()的方法没有被封装，所以可以在对象外部使用
	$person1->name = "李四";        	//name属性被封装，不能在对象外部给私有属性赋值
	echo $person1->age;            		//age属性被封装，不能在对象的外部获取私有属性的值
	$person1->leftLeg();            	//leftLeg()方法被封装，不能在对象外面调用对象中私有的方法



```

```php
<?php
	class Person  {            		
		//下面是声明人的成员属性，全都使用了private关键字封装
		private $name;       		//第一个成员属性$name定义人的名字，此属性被封装
		private $sex;         		//第二个成员属性$sex定义人的性别，此属性被封装
		private $age;         		//第三个成员属性$age定义人的年龄，此属性被封装

	    function __construct($name="", $sex="男", $age=1) {
			$this->name = $name;    
			$this->sex = $sex;       	
			$this->age = $age;       	
		}
		
		//通过这个公有方法可以在对象外部获取私有属性$name的值
		public  function getName() {   	
			return $this->name;      			//返回对象的私有属性的值
		}
		
		//通过这个公有方法在对象外部为私有属性$sex设置值，但限制条件
		public function setSex($sex) {  	
			if($sex=="男" || $sex=="女") 		//如果传入合法的值才为私有的属性赋值
				$this->sex=$sex;   				//条件成立则将参数传入的值赋给私有属性
		}

		//通过这个公有方法在对象外部为私有属性$age设置值，但限制条件
		public function setAge($age) { 	
			if($age > 150 || $age <0)  			//如果设置不合理的年龄则函数不往下执行
				return;            				//返回空值，退出函数
			$this->age=$age;         			//执行此语句则重新为私有属性赋值
		}

		//通过这个公有方法可以在对象外部获取私有属性$name的值
		public function getAge(){    	
			if($this->age > 30)       			//如果年龄的成员属性大于30则返回虚假的年龄
				return $this->age - 10; 		//返回当前的年龄减去10岁
			else                   				//如果年龄在30岁以下则返回真实年龄
				return $this->age;   			//返回当前的私有年龄属性
		}

		//下面是声明人的成员公有方法，说出自己所有的私有属性
		function say(){   			
			echo "我的名字：".$this->name."， 性别：".$this->sex."，年龄：".$this->age."。<br>";
		}		
	}
	
	$person1 = new Person("王五", "男", 40);	//创建对象$person1
	
	echo $person1->getName()."<br>";  			//访问对象中的公有方法，获取对象中私有属性$name输出
	$person1->setSex("女");            			//通过公有的方法为私有属性$sex设置合法的值
	$person1->setAge(200);            			//通过公有的方法为私有属性$age设置非法的值，赋值失败
	echo $person1->getAge()."<br>";    			//访问对象中的公有方法，获取对象中私有属性$age输出
	$person1->say();               				//访问对象中的公有方法，获取对象中所有的私有属性并输出



```

```php
<?php
	class Person  {          				
		//下面是声明人的成员属性，全都使用了private关键字封装
		private $name;     				//此属性被封装
		private $sex;      				//此属性被封装
		private $age;      				//此属性被封装

	    function __construct($name="", $sex="男", $age=1) {
			$this->name = $name;  		
			$this->sex = $sex;      		
			$this->age = $age;       		
		}
		
		/**
			声明魔术方法需要两个参数，直接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值
			@param	string	$propertyName		成员属性名
			@param	mixed	$propertyValue	成员属性值
		*/
		private function __set($propertyName, $propertyValue) { 
			//如果第一个参数是属性名sex则条件成立
			if($propertyName == "sex"){	
				//第二个参数只能是男或女
				if(!($propertyValue == "男" || $propertyValue == "女")) 
					//如果是非法参数返回空，则结束方法执行
					return;       		
			}	
			
			//如果第一个参数是属性名age则条件成立
			if($propertyName == "age"){   
				//第二个参数只能在0到150之间的整数
				if($propertyValue > 150 || $propertyValue <0)  
					//如果是非法参数返回空，则结束方法执行
					return;           	
			}
            
			//根据参数决定为那个属性被赋值，传入不同的成员属性名，赋上传入的相应的值
			$this->$propertyName = $propertyValue; 
		} 
		
		//下面是声明人类的成员方法，设置为公有的可以在任何地方访问
		public function say(){
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."。<br>";
		}		
	}

	$person1 = new Person("张三", "男", 20); 
	//以下三行自动调用了__set()函数，将属性名分别传给第一个参数，将属性值传给第二个参数
	$person1->name = "李四";     		//动调用了__set()方法为私有属性name赋值成功
	$person1->sex = "女";         		//动调用了__set()方法为私有属性sex赋值成功
	$person1->age = 80;         		//动调用了__set()方法为私有属性age赋值成功
	
	$person1->sex = "保密";       		//“保密”是一个非法值，这条语句给私有属性sex赋值失败
	$person1->age = 800;         		//800是一个非法值，这条语句私有属性age赋值失败

	$person1->say();	           		//调用$person1对象中的say()方法，查看一下所有被重新设置的新值



```

```php
<?php
	class Person  {          				
		private $name;       				//此属性被封装
		private $sex;         				//此属性被封装
		private $age;         				//此属性被封装

	    function __construct($name="", $sex="男", $age=1) {     
			$this->name = $name; 		
			$this->sex = $sex;     		
			$this->age = $age;       			
		}
		
		/**
			在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理
			@param	string	$propertyName		成员属性名
			@return	mixed					返回属性值
		*/
		private function __get($propertyName)  {  	//在方法前使用private修饰，防止对象外部调用 
			 if($propertyName == "sex") {        	//如果参数传入的是”sex”则条件成立
				return "保密";                		//不让别人获取到性别，以“保密”替代
			 } else if($propertyName == "age") { 	//如果参数传入的是“age”则条件成立
				if($this->age > 30)            		//如果对象中的年龄大于30时条件成立
					return $this->age-10;	    	//返回对象中虚假的年龄，比真实年龄小10岁
				else                         		//如果对象中的年龄不大于30时则执行下面代码
					return $this->$propertyName;  	//让访问都可以获取到对象中真实的年龄
			 } else {                            	//如果参数传入的是其他属性名则条件成立
			 	return $this->$propertyName;      	//对其他属性都没有限制，可以直接返回属性的值
			 } 
		}
	}

	$person1 = new Person("张三", "男", 40);	
	
	echo "姓名：".$person1->name."<br>";   	//直接访问私有属性name，自动调用了__get()方法可以间接获取
	echo "性别：".$person1->sex."<br>";    	//自动调用了__get()方法，但在方法中没有返回真实属性值
	echo "年龄：".$person1->age."<br>";    	//自动调用了__get()方法，根据对象本身的情况会返回不同的值



```

```php
<?php
	class Person  {            			
		private $name;       				//此属性被封装
		private $sex;         				//此属性被封装
		private $age;         				//此属性被封装

		function __construct($name="", $sex="男", $age=1) {
			$this->name = $name;    			
			$this->sex = $sex;       			
			$this->age = $age;       
		}
		
		/**
			当在对象外面使用isset()测定私用成员属性时，自动调用，并在内部测定扣传给外部的isset()结果
			@param	string	$propertyName		成员属性名
			@return	boolean					返回isset()查询成员属性的真假结果
		*/
		private function __isset($propertyName) {	//需要一个参数，是测定的私有属性的名称
			if($propertyName == "name")      		//如果参数中传入的属性名等于“name”时条件成立
				return false;               		//返回假，不允许在对象外部测定这个属性
			return isset($this->$propertyName); 	//其他的属性都可以被测定，并返回测定的结果
   		}
		
		/**
			当在对象外面使用unset()方法删除私用属性时，自动被调用，并在内部把私用的成员属性删除
			@param	string	$propertyName		成员属性名
		*/
   		private function __unset($propertyName) {	//需要一个参数，是要删除的私有属性名称
			if($propertyName == "name")       		//如果参数中传入的属性名等于“name”时条件成立
				return;                    			//退出方法，不允许删除对象中的name属性
			unset($this->$propertyName);     		//在对象的内部删除在对象外指定的私有属性
		}

		public function say() {
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."。<br>";
		}		
	}

	$person1 = new Person("张三", "男", 40);   		//创建一个对象$person1，将成员属性分别赋上初值
	
	var_dump( isset( $person1->name ) );        	//输出bool(false)，不允许测定name属性
	var_dump( isset( $person1->sex ) );          	//输出bool(true)，存在sex私有属性
	var_dump( isset( $person1->age ) );          	//输出bool(true)，对象中存在age私有属性
	var_dump( isset( $person1->id ) );           	//输出bool(false)，测定对象中不存在id属性
		
	unset( $person1->name );                		//删除私有属性name，但在__unset()中不允许删除
	unset( $person1->sex );                  		//删除对象中的私有属性sex，删除成功
	unset( $person1->age );                  		//删除对象中的私有属性age，删除成功
	
	$person1->say();  	//对象中的sex和age属性被删除，输出：我的名字叫：张三，性别：，我的年龄是：



```

```php
<?php
	//声明一个人类，定义人所具有的一些其本的属性和功能成员，作为父类 
	class Person {           			
		var $name;         				//声明一个存储人的名字的成员
		var $sex;           			//声明一个存储人的性别的成员
		var $age;           			//声明一个存储人的年龄的成员
		
	    function __construct($name="", $sex="男", $age=1) {		
			$this->name = $name;   					
			$this->sex = $sex;      				
			$this->age = $age;     					
		}

		function say(){          		
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."。<br>";
		}	
		
		function run() {          		
			echo $this->name."正在走路。<br>";
		}
	}

	//声明一个学生类，使用extends关键字扩展（继承）Person类
	class Student extends Person {   		
		var $school;             		//在学生类中声明一个所在学校school的成员属性
		
		//在学生类中声明一个学生可以学习的方法
		function study() {        		
			echo $this->name."正在".$this->school."学习<br>";
		}	
	}

	//再声明一个教师类，使用extends关键字扩展（继承）Student类
	class Teacher extends Student {  		
		var $wage;              		//在教师类中声明一个教师工资wage的成员属性
		
		//在教师类中声明一个教师可以教学的方法
		function teaching() {      		
			echo $this->name."正在".$this->school."教学,每月工资为".$this->wage."。<br>";	
		}
	}
	
	$teacher1 = new Teacher("张三", "男", 40); 	//使用继承过来的构造方法创建一个教师对象
	
	$teacher1->school = "edu";        			//将一个教师对象中的所在学校的成员属性school赋值
	$teacher1->wage = 3000;         			//将一个教师对象中的成员属性工资赋值

	$teacher1->say();              				//调用教师对象中的说话方法
	$teacher1->study();            				//调用教师对象中的学习方法
	$teacher1->teaching();          			//调用教师对象中的教学方法



```

```php
<?php
	//声明一个类作为父类使用，将它的成员都声明为私有的
	class MyClass {                 	
		private $var1 = 100;          	//声明一个私有的成员属性并给初值为100
		
		//声明一个成员方法使用private关键字设置为私有的
		private function printHello() {	
			echo "hello<br>";     		//在方法中只有一条输出语句作为测试使用
		}
	}

	//声明一个MyClass类的子类试图访问父类中的私有成员
	class MyClass2 extends MyClass { 	
		//在类中声明一个公有方法，访问父类中的私有成员
		function useProperty() {
			echo "输出从父类继承过来的成员属性值".$this->var1."<br>"; 	//访问父类中的私有属性
			$this->printHello();                                     	//访问父类中的私有方法
		}
	}

	$subObj = new MyClass2();      		//初始化出子类对象
	$subObj->useProperty();         	//调用子类对象中的方法实现对父类私有成员的访问



```

```php
<?php
	//声明一个类作为父类使用，将它的成员都声明为保护的
	class MyClass {                   		
		protected $var1=100;          		//声明一个保护的成员属性并给初值为100

		protected function printHello() {   //声明一个成员方法使用protected关键字设置为保护的
			echo "hello<br>";           	//在方法中只有一条输出语句作为测试使用
		}
	}

	//声明一个MyClass类的子类试图访问父类中的保护成员
	class MyClass2 extends MyClass {     
		//在类中声明一个公有方法，访问父类中的保护成员
		function useProperty() {
			echo "输出从父类继承过来的成员属性值".$this->var1."<br>";	//访问父类中受保护的属性
			$this->printHello();                                     	//访问父类中受保护的方法
		}
	}

	$subObj = new MyClass2();          		//初始化出子类对象
	$subObj->useProperty();            		//调用子类对象中的方法实现对父类保护的成员访问
    echo $subObj->var1;               		//试图访问类中受保护的成员，结果出错



```

```php
<?php
	//声明一个人类，定义人所具有的一些其本的属性和功能成员，作为父类 
	class Person {       			
		protected $name;   		
		protected $sex;       	
		protected $age;        	
		
	    function __construct($name="", $sex="男", $age=1) {	
			$this->name = $name;        				
			$this->sex = $sex;              			
			$this->age = $age;              			
		}

		//在人类中声明一个通用的说话方法，介绍一下自己
		function say(){      		
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."。<br>";
		}	
	}

	//声明一个学生类，使用extends关键字扩展（继承）Person类
	class Student extends Person {				
		private $school;       				//在学生类中声明一个所在学校school的成员属性
	
        //覆盖父类中的构造方法，在参数列表中多添加一个学校属性，用来创建对象并初始化成员属性
	    function __construct($name="", $sex="男", $age=1, $school="") {   
			$this->name = $name;      	
			$this->sex = $sex;         		
			$this->age = $age;         		
			$this->school = $school;     
		}

		function study() {        			
			echo $this->name."正在".$this->school."学习<br>";
		}
		
		//定义一个和父类中同名的方法，将父类中的说话方法覆盖并重写，多说出所在的学校名称
		function say() { 
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."，在".$this->school."学校上学<br>";
		}	
	}

	$student = new Student("张三","男",20, "edu");	//创建一个学生对象，并多传一个学校名称参数
	$student->say();                         		//调用学生类中覆盖父类的说话方法



```


```php
<?php
	class Person {           			
		protected $name;   			
		protected $sex;       		
		protected $age;        		
		
	    function __construct($name="", $sex="男", $age=1) {	
			$this->name = $name; 	
			$this->sex = $sex; 		
			$this->age = $age; 		
		}

		function say(){       	
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."。<br>";
		}	
	}

	//声明一个学生类，使用extends关键字扩展（继承）Person类
	class Student extends Person {		
		private $school;      		
	
         //覆盖父类中的构造方法，在参数列表中多添加一个学校属性，用来创建对象并初始化成员属性
	    function __construct($name="", $sex="男", $age=1, $school="") {   
			//调用父类中被本方法覆盖的构造方法，为从父类中继承过来的属性赋初值
			parent::__construct($name,$sex,$age);  
			$this->school = $school; 	//新添加一条为子类中新声明的成员属性赋初值
		}

		function study() {        		
			echo $this->name."正在".$this->school."学习<br>";
		}
		
		//定义一个和父类中同名的方法，将父类中的说话方法覆盖并重写，多说出所在的学校名称
		function say() { 
			parent::say();                  		//调用父类中被本方法覆盖掉的方法
			echo "在".$this->school."学校上学<br>";	//在原有的功能基础上多加一点功能
		}	
	}

	$student = new Student("张三","男",20, "edu");  //创建一个学生对象，并多传一个学校名称参数
	$student->say();                                //调用学生类中覆盖父类的说话方法



```

```php
<?php
	final class MyClass {            	//声明一个类，并使用final关键字标识，使其不能有子类
		//成员略…
	}
	class MyClass2 extends MyClass { 	//声明另一个类并试图去继承final标识的类，结果出错
		//成员略…
	}	



```




```php
<?php
	//声明一个类MyClass作为父类，在类中只声明一个成员方法
    class MyClass {     
		//声明一个成员方法并使用final标识，则不能在子类中覆盖
		final function fun() {       
			//方法体中的内容略
		}
	}
	
	//声明继承MyClass类的子类，在类中声明一个方法去覆盖父类中的方法
	class MyClass2 extends MyClass { 
		//在子类中试图去覆盖父类中已被final标识的方法，结果出错
		function fun() {             
			//方法体中的内容略
		}
	}	



```


```php
<?php
	//声明一个MyClass类，用来演示如何使用静态成员
	class MyClass {                 	
		static $count;               	//在类中声明一个静态成员属性count，用来统计对象被创建的次数

		function __construct() {     	//每次创建一个对象就会自动调用一次这个构造方法
			self::$count++;	       		//使用self访问静态成员count，使其自增1
		}

		static function getCount() {	//声明一个静态方法，在类外面直接使用类名就可以调用
			return self::$count;   		//在方法中使用self访问静态成员并返回
		}
	}
	
	MyClass::$count=0;         			//在类外面使用类名访问类中的静态成员，为其初始化赋值0

	$myc1 = new MyClass();      		//通过MyClass类创建第一个对象，在构造方法中将count累加1
	$myc2 = new MyClass();       		//通过MyClass类创建第二个对象，在构造方法中又为count累加1
	$myc3 = new MyClass();       		//通过MyClass类创建第三个对象，在构造方法中再次为count累加1
     
	echo MyClass::getCount();      		//在类外面使用类名访问类中的静态成员方法，获取静态属性的值 3
    echo $myc3->getCount();     		//通过对象也可以访问类中的静态成员方法，获取静态属性的值 3



```


```php

<?php
	/**
		声明一个类Db，用于演示单态模式的使用
	*/
	class DB {
		private static $obj = null; 		//声明一个私有的，静态的成员属性$obj
		
		/* 构造方法， 使用private 封装后则只能在类的内部使用new去创建对象 */
		private function __construct() {
			/* 在这个方法中去完成一些数据库连接等操作 */
			echo "连接数据库成功<br>";
		}
		
		/* 只有通过这个方法才能返回本类的对象，该方法是静态方法，用类名调用 */
		static function getInstance() {
			if(is_null(self::$obj))			//如果本类中的$obj为空,说明还没有被实例化过
				self::$obj = new self();	//实例化本类对象
				
			return self::$obj;				//返回本类的对象
		}
		
		/* 执行SQL语句完成对数据库的操作 */
		function query($sql) {
			echo $sql;
		}
	}
	
	//只能使用静态方法getInstance()去获取DB类的对象
	$db = DB::getInstance();
	
	//访问对象中的成员
	$db -> query("select * from user");
```




```php

<?php
	//声明一个MyClass类，在类中声明一个常量，和一个成员方法
	class MyClass {   
		 const CONSTANT = 'CONSTANT value';  		//使用const声明一个常量，并直接赋上初始值

   		 function showConstant() {                 	//声明一个成员方法并在其内部访问本类中的常量
       		echo  self::CONSTANT."<br>"; 			//使用self访问常量，注意常量前不要加“$”
   		 }
	}

	echo MyClass::CONSTANT . "<br>";             	//在类外部使用类名称访问常量，也不要加”$”
	$class = new MyClass();                        	//通过类MyClass创建一个对象引用$class
	$class->showConstant();                        	//调用对象中的方法
	// echo $class::CONSTANT;                     		//通过对象名称访问常量是不允许的


```


```php

<?php
	//声明类Person，并在其中声明了三个成员属性，一个构造方法以及一个成员方法
	class Person {    	
		private $name;   					//第一个私有成员属性$name用于存储人的名字
		private $sex;     					//第二个私有成员属性$sex用于存储人的性别
		private $age;     					//第三个私有成员属性$age用于存储人的age

		//构造方法在对象诞生时为成员属性赋初值
		function __construct($name="", $sex="", $age=1) { 
			$this->name = $name;
			$this->sex = $sex;
			$this->age = $age;
		}

		//一个成员方法用于打印出自己对象中全部的成员属性值
		function say()  {     				
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."<br>";
		}
	}

	$p1 = new Person("张三", "男", 20); 	//创建一个对象并通过构造方法为对象中所有成员属性赋初值
	$p2 = clone $p1;                		//使用clone关键字克隆（复制）对象，创建一个对象的副本
    // $p3=$p1                    				//这不是复制对象，而是为对象多复制出一个访问该对象的引用
	$p1 -> say();                    		//调用原对象中的说话方法，打印原对象中的全部属性值
	$p2 -> say();                   		//调用副本对象中的说话方法，打印出克隆对象的全部属性值


```

```php

<?php
	class Person {    		
		private $name;     
		private $sex;       	
		private $age;      

		function __construct($name="", $sex="", $age=1) {		
			$this->name = $name;
			$this->sex = $sex;
			$this->age = $age;
		}
		
		//声明此方法则在对象克隆时自动调用，用来为新对象重新赋值
		function __clone() { 	
			$this->name = "我是".$that->name."的副本";	//为副本对象中的name属性重新赋值
			$this->age = 10;                          	//为副本对象中的age属性重新赋值
		}		

		function say()  {     				
			echo "我的名字：".$this->name."，性别：".$this->sex."，年龄：".$this->age."<br>";
		}
	}

	$p1 = new Person("张三", "男", 20); 	//创建一个对象并通过构造方法为对象中所有成员属性赋初值
	$p2 = clone $p1;                 		//使用clone克隆（复制）对象，并自动调用类中的__clone()方法 
    
	$p1 -> say();                   		//调用原对象中的说话方法，打印原对象中的全部属性值
	$p2 -> say();                    		//调用副本对象中的说话方法，打印出克隆对象的全部属性值


```


```php
<?php
	//声明一个测试类，在类中声明一个成员属性和一个__toString()方法
	class TestClass {             		
   		private $foo;             			//在类中声明的一个成员方法

    	function __construct($foo) {		//通过构造方法传值为成员属性赋初值
        	$this->foo = $foo;      		//为成员属性赋值
   		}
  
		public function __toString() {		//在类中定义一个__toString方法 
        	return $this->foo;      		//返回一个成员属性$foo的值
		}
	}

	$obj = new TestClass('Hello');     		//创建一个对象并赋值给对象引用$obj
	echo $obj;                     			//直接输出对象引用则自动调用了对象中__toString()方法输出Hello



```

```php
<?php
	//声明一个测试类，在类中声明printHello()和__call()方法
	class TestClass {                 	
		function printHello() {        	//声明一个方法，可以让对象能成功调用
			echo "Hello<br>";       	//执行时输出一条语句
		}
		
		/**
			声明魔术方法__call(),用来处理调用对象中不存在的方法
			@param	string	$functionName	访问不存的成员方法名称字符串
			@param	array	$args		访问不存的成员方法中传递的参数数组
		*/
		function __call($functionName, $args) {     	
			echo "你所调用的函数：".$functionName."(参数：";  //输出调用不存在的方法名
			print_r($args);                                   //输出调用不存在的方法时的参数列表
			echo ")不存在！<br>\n";                       	  //输出附加的一些提示信息
		}	
	}

	$obj = new TestClass();        	  	//通过类TestClass实例化一个对象
	$obj -> myFun("one", 2, "three");   //调用对象中不存在的方法，则自动调用了对象中的__call()方法
	$obj -> otherFun(8,9);           	//调用对象中不存在的方法，则自动调用了对象中的__call()方法
	$obj -> printHello();             	//调用对象中存在的方法，可以成功调用



```

```php

<?php
	//声明一个DB类（数据库操作类）的简单操作模型
	class DB {
		//声明一个私有成员属性数组，主要是通过下标来定义可以参加连贯操作的全部方法名称
		private $sql = array(
			"field" => "",
			"where" => "",
			"order" => "",
			"limit" => "", 
			"group" => "",
			"having" => ""
			);
		
		//连贯操作调用field() where() order() limit() group() having()方法，组合SQL语句
		function __call($methodName, $args) {
			//将第一个参数（代表不存在方法的方法名称），全部转成小写方式，获取方法名称
			$methodName = strtolower($methodName);
			
			//如果调用的方法名和成员属性数组$sql下标对应上，则将第二个参数给数组中下标对应的元素
			if(array_key_exists($methodName, $this->sql)) {
				$this->sql[$methodName] = $args[0];
			} else {
				echo '调用类'.get_class($this).'中的方法'.$methodName.'()不存在';
			}
			
			//返回自己对象，则可以继续调用本对象中的方法，形成连贯操作
			return $this;				
		}
		
		//简单的应用，没有实际意义，只是输出连贯操作后组合的一个SQL语句，是连贯操作最后调用的一个方法
		function select() {
			echo "SELECT FROM {$this->sql['field']} user {$this->sql['where']} {$this->sql['order']}
				  {$this->sql['limit']}  {$this->sql['group']}  {$this->sql['having']}";
		}
	}
	
	$db = new DB;	
	
	//连贯操作,也可以分为多行去连续调用多个方法
	$db -> field('sex, count(sex)')
		-> where('where sex in ("男", "女")')
		-> group('group by sex')
		-> having('having avg(age) > 25')
		-> select();
		
	//如果调用的方法不存在，也会有提示，下面演示的就是调用一个不存的方法query()
	$db -> query('select * from user');
```

```php
<?php   
	/**
		声明一个自动加载类的魔术方法__autoload()
		@param	string	$className 需要加载的类名称字符串
	*/
	function __autoload($className) {       
		//在方法中使用include包含类所在的文件
		include(strtolower($className).".class.php"); 
	}
	
	$obj  = new User();  //User类不存在则自动调用__autoload()函数，将类名“User”作为参数传入
	$obj2 = new Shop();	 //Shop类不存在则自动调用__autoload()函数，将类名“Shop”作为参数传入
 


```

```php
<?php
	//声明一个Person类，包含三个成员属性和一个成员方法
	class Person {        
		private $name;   	//人的名字
		private $sex;     	//人的性别
		private $age;     	//人的年龄
		
		//构造方法为成员属性赋初值
		function __construct($name="", $sex="", $age="") {   
			$this->name = $name;
			$this->sex = $sex;
			$this->age = $age;
		}

		//这个人可以说话的方法, 说出自己的成员属性
		function say()  {   	
			echo "我的名字：".$this->name.",性别：".$this->sex.",年龄：".$this->age."<br>";
		}
	}



```

```php
<?php
	require "person.class.php";               		//在本文件中包含Person类所在的脚本文件
	
	$person = new Person("张三", "男", 20);      	//能过Person类创建一个对象，对象的引用名为$person
	
	$person_string = serialize($person);          	//通过serialize函数将对象串行化，返回一个字符串
	
	file_put_contents("file.txt", $person_string);	//将对象串行化后返回的字符串保存到file.txt文件中



```


```php
<?php
	require "person.class.php";	              		//在本文件中包含Person类所在的脚本文件
	
	$person_string = file_get_contents("file.txt"); //将file.txt文件中的字符串读出来并赋给变量$person_string
	
	$person = unserialize($person_string); 	     	//进行反串行化操作，形成对象$person。
	
	$person -> say();                         		//调用对象中的say()方法，用来测试反串行化对象是否成功



```

```php
<?php
	//声明一个Person类，包含三个成员属性和一个成员方法
	class Person {      	
		private $name; 		//人的名字
		private $sex;     	//人的性别
		private $age;     	//人的年龄
	
		function __construct($name="", $sex="", $age="") {  
			$this->name = $name;
			$this->sex = $sex;
			$this->age = $age;
		}

		function say()  {           	
			echo "我的名字：".$this->name.",性别：".$this->sex.".年龄：".$this->age."<br>";
		}
		
		//在类中添加此方法，在串行化时自动调用并返回数组
		function __sleep() {         	
			$arr = array("name", "age");	//数组中的成员$name和$age将被串行化，成员$sex则被忽略
			return($arr);           		//返回一个数组
		} 
		
		//在反串行化对象时自动调用该方法，没有参数也没有返回值
		function __wakeup() {      	
			 $this->age = 40;     			//在重新组织对象时，为新对象中的$age属性重新赋值
		}
	}

	$person1 = new Person("张三", "男", 20);//通过Person类实例化对象，对象引用名为$person1
	//把一个对象串行化，返一个字符串，调用了__sleep()方法,忽略没在数组中的属性$sex
	$person_string = serialize($person1); 
	echo $person_string."<br>";             //输出对象串行化的字符串
 
 	//反串行化对象，并自动调用了__wakup()方法重新为新对象中的$age属性赋值
	$person2 = unserialize($person_string); //反串行化对象形成对象$p2重新赋值$age为40
	$person2 -> say();                      //调用新对象中say()方法输出的成员中已没有$sex属性了



```

```php
<?php
	//声明一个抽象类，要使用abstract关键字标识
	abstract class Person {            	
		protected $name;            	//声明一个存储人的名字的成员
		protected $country;           	//声明一个存储人的国家的成员
			
	    function __construct($name="", $country="china") {	
			$this->name = $name;                     
			$this->country = $country;                 
		}
		
		//在抽象类中声明一个没有方法体的抽象方法，使用abstract关键字标识
		abstract function say();   		
	
		//在抽象类中声明另一个没有方法体的抽象方法，使用abstract关键字标识
		abstract function eat();   		
		
		//在抽象类中可以声明正常的非抽象的方法
		function run(){         		
			echo "使用两条腿走路<br>";  //有方法体，输出一条语句
		}
	}



```

```php
<?php
	//声明一个类去继承抽象类Person
	class ChineseMan extends Person { 
		//将父类中的抽象方法覆盖，按自己的需求去实现
		function say() {            	
			echo $this->name."是".$this->country."人，讲汉语<br>"; 	//实现的内容
		}
		
		//将父类中的抽象方法覆盖，按自己的需求去实现
		function eat() {             	
			echo $this->name."使用筷子吃饭<br>";                	//实现的内容
		}
	}
	
	//声明另一个类去继承抽象类Person
	class Americans extends Person {  	
		//将父类中的抽象方法覆盖，按自己的需求去实现
		function say() {            	
			echo $this->name."是".$this->country."人，讲英语<br>"; 	//实现的内容
		}
		
		//将父类中的抽象方法覆盖，按自己的需求去实现
		function eat() {            	
			echo $this->name."使用刀子和叉子吃饭<br>";           	//实现的内容
		}
	}

	$chineseMan = new ChineseMan("高洛峰", "中国"); 		//将第一个Person的子类实例化对象
	$americans = new Americans("alex", "美国");      		//将第二个Person的子类实例化对象

	$chineseMan -> say();        	//通过第一个对象调用子类中已经实例父类中抽象方法的say()方法
	$chineseMan -> eat();           //通过第一个对象调用子类中已经实例父类中抽象方法的eat()方法

	$americans -> say();            //通过第二个对象调用子类中已经实例父类中抽象方法的say()方法
	$americans -> eat();           	//通过第二个对象调用子类中已经实例父类中抽象方法的eat()方法



```


```php
 <?php
	interface One {                          	//声明一个接口使用interface关键字，One为接口名称
		const CONSTANT = 'CONSTANT value';		//在接口中声明一个常量成员属性，和在类中声明一样
		function fun1();                     	//在接口中声明一个抽象方法“fun1()”
		function fun2();                     	//在接口中声明另一个抽象方法“fun2()”
	}



```


```php
<?php
	//声明一个接口Two对接口One进行扩展
	interface Two extends One {        			
		function fun3();              			//在接口中声明一个抽象方法“fun1()”
		function fun4();              			//在接口中声明另一个抽象方法“fun2()”
	}



```



```php
<?php
	//声明一个接口使用interface关键字，One为接口名称
	interface One {                          	
		const CONSTANT = 'CONSTANT value'; 		//在接口中声明一个常量成员属性和在类中声明一样
		function fun1();                     	//在接口中声明一个抽象方法“fun1()”
		function fun2();                     	//在接口中声明另一个抽象方法“fun2()”
	}
	
	//声明一个抽象类去实现接口One中的第二个方法
	abstract class Three implements One {       	
		function fun2() {                    	//只实现接口中的一个抽象方法
			//具体的实现内容由子类自决定
		}
	}

	//声明一个类实现接口One中的全部抽象方法
	class Four implements One {              		
		function fun1() {                   	//实现接口中第一个方法
			//具体的实现内容由子类自决定
		}	

		function fun2() {                   	//实现接口中的第二个方法
			//具体的实现内容由子类自决定
		}
	}



```


```php

<?php	
	//定义一个USB接口，让每个USB设略都遵守这个规范
	interface USB {
		function run();
	}
	
	//声明一个电脑类， 去使用USB设置
	class Computer {
		//电脑类中的一个方法可以应用任何一种USB设备
		function useUSB($usb) {
			$usb -> run();
		}
	}
	
	$computer = new Computer;					//实例化一个电脑类的对象			
	
	$computer ->useUSB( new Ukey() );			//为电脑插入一个USB键盘设备，并运行
	$computer ->useUSB( new Umouse() );			//为电脑插入一个USB鼠标设备，并运行
	$computer ->useUSB( new Ustore() );			//为电脑插入一个USB存储设备，并运行
	

```

```php

<?php
	//扩展一个USB键盘设置，实现USB接口
	class Ukey implements USB {
		//按键盘的功能实现接口中的方法
		function run() {
			echo "运行USB键盘设备<br>";
		}
	}
	
	//扩展一个USB鼠标设置，实现USB接口
	class Umouse implements USB {
		//按鼠标的功能实现接口中的方法
		function run() {
			echo "运行USB鼠标设备<br>";
		}
	}
	
	//扩展一个USB存储设置，实现USB接口
	class Ustore implements USB {
		//按存储的功能实现接口中的方法
		function run() {
			echo "运行USB存储设备<br>";
		}
	}
```


```php
<html>
	<head>
		<title>图形计算(使用面向对象技术开发)</title>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	</head>

	<body>
		<center>
			<h1>图形（周长&面积）计算器</h1>
			
			<a href="index.php?action=rect">矩形</a>  ||
			<a href="index.php?action=triangle">三角形</a> ||
			<a href="index.php?action=circle">圆形</a> <hr>
		</center>
		<?php
			//设置错误报告的级别，除了无关紧要的"注意",其它的所有报告都输出
			error_reporting(E_ALL & ~E_NOTICE);

			//通过魔术方法__autoload()去自动加载所需要的类文件，将需要的类包含进来
			function __autoload($className){
				include strtolower($className).".class.php";   //包含类所在的文件		
			}

			echo new Form("index.php");	   //输出用户需要的表单
	
			//如果用户提交表单则去计算
			if(isset($_POST["sub"])) {
				echo new Result();         //输出形状的计算结果	
			}
		?>		
	</body>
</html>


```

```php
<?php	
	/**
		Project: 面向对象版图形计算器 
		file: form.class.php
		选择不同的图形时输出对应的表单对象，在主脚本程序中提供给用户一个操作界面
		package:shape
	 */
	class Form {
		private $action;   			 			//表单form属性action的值， 用于设置表单提交的位置
		private $shape;     					//用户选择形状的动作

		/* 构造方法，用于对用户的操作动作和表单提交的位置进行初使化赋值 */
		function __construct($action=""){
			$this->action = $action;      		//为表单form中的action属性赋值
			/* 用户选择形状的动作，默认为矩形rect */
			$this->shape = isset( $_GET["action"] ) ? $_GET["action"] : "rect";  
		}

		/* 魔术方法__toString(), 通过用户不同的请求，返回用户需要的表单字符串，在页面中显示 */
		function __toString(){
			$form='<form action="'.$this->action.'?action='.$this->shape.'" method="post">';
			
			/* 根据用户的get请求组合成方法名称字符串，getRect(), getTriangle(), getCircle() */
			$shape = "get".ucfirst($this->shape);
			$form .= $this->$shape();    		//调用私有方法获取圆形的输入表单
					
			$form .= '<br><input type="submit" name="sub" value="计算"><br>';
			$form .= '</form>';
			return $form;   				  //返回用户需要的输入形状表单界面
		}

		/* 私有方法，用于获取矩形的表单输入 */
		private function getRect(){
			$input = '<b>请输入 | 矩形 | 的宽度和高度：</b><p>';
			$input .= '宽度: <input type="text" name="width" value="'.$_POST["width"].'"><br>';
			$input .= '高度: <input type="text" name="height"  value="'.$_POST["height"].'"><br>';
			return $input;
		}

		/* 私有方法，用于获取三角形的表单输入 */
		private function getTriangle(){
			$input = '<b>请输出 | 三角形 | 的三条边：</b><p>';
			$input .= '第一边: <input type="text" name="side1" value="'.$_POST["side1"].'"><br>';
			$input .= '第二边: <input type="text" name="side2"  value="'.$_POST["side2"].'"><br>';
			$input .= '第三边: <input type="text" name="side3"  value="'.$_POST["side3"].'"><br>';
			return $input;
		}

		/* 私有方法，用于获取圆形的表单输入 */
		private function getCircle(){
			$input = '<b>请输入 | 圆形 | 的半径：</b><p>';
			$input .= '半径：<input type="text" name="radius" value="'.$_POST["radius"].'"><br>';
			return $input;
		}
	}






```


```php
<?php	
	/**
		Project: 面向对象版图形计算器
		file:shape.class.php
		声明一个形状的抽象类，作为所有形状的父类，里面有两个抽象方法,根据子类的形状去实现
		package:shape
	*/
	abstract class Shape {  		   
		public $shapeName;				  //形状的名称
		abstract function area();         //声明的抽象方法在子类中实现它，用来计算不同图型的面积
		abstract function  perimeter();   //声明的抽象方法在子类中实现它，用来计算不同图型的周长

		/*
		 * 该方法是一个普通方法用来对所有形状表单输入的值进行验证
		 * @param	mixed	$value	接收表单输入的值，对该值进行验证
		 * @param	string	$message	消息提示的前缀
		 * @return	boolean			验正通过返回true, 失败则返回false
		 */
		protected function validate($value, $message = '输入的值' ){
			if( $value=="" || !is_numeric($value) || $value < 0 ) {
				$message=$this->shapeName.$message;
				echo '<font color="red">'.$message.'必须为非负值的数字，并且不能为空</font><br>';
				return false;
			}else{
				return true;
			}
		}
	}


```


```php
<?php	
	/**
		Project: 面向对象版图形计算器 
		file: result.class.php
		声明一个Result结果类，通过多态的应用获取用户所选择形状的计算结果
		package:shape
	*/
	class Result {
		private $shape = null ;             //成员属性用于获取某一形状对象

		/* 构造方法用于初使化成员属性$shape */
		function __construct(){
			/* 根据用户的get方法提交的动作'action'创建对应的形状对象[$_GET['action']()变量函数技术] */ 
			$this->shape = new $_GET['action']();
		}

		/* 声明一个魔术方法__toString，在直接访问该对象引用时自动调用，返回利用多态计算后的结果字符串 */
		function __toString(){
			//调用形状对象中的周长方法，获得周长的值
			$result = $this->shape->shapeName.'的周长：'.round($this->shape->perimeter(), 2).'<br>';
			//调用形状对象中的面积方法，获得面积的值
			$result .= $this->shape->shapeName.'的面积：'.round($this->shape->area(), 2).'<br>';
		
			return $result;					//返回计算结果字符串
		}	
	}



```


```php
<?php	
	/**
		Project: 面向对象版图形计算器
		file:rect.class.php
		声明了一个矩形子类，根据矩形的特点实现了形状抽象类中的周长和面积方法
		package:shape
	*/
	class Rect extends Shape {  	
		private $width = 0;          	 //声明矩形的成员属性宽度
		private $height = 0;          	 //声明矩形的成员属性高度

		/* 矩形的构造方法，用表单$_POST中接收的高度和宽度初使化矩形对象 */
		function __construct() {    
			$this->shapeName = "矩形";    //为形状命名

			//通过从shape中继承的方法validate(),对矩形的宽度和高度进行验证
			if($this->validate($_POST["width"], "宽度") & $this->validate($_POST["height"], "高度")){
				$this->width = $_POST["width"];   //通过超全局数组$_POST将表单输入的宽度给成员属性width赋初值
				$this->height = $_POST["height"]; //通过超全局数组$_POST将表单输入高度给成员属性height赋初值
			} 
		}

		/* 按矩形面积的计算公式，实现抽象类shape中的抽象方法area() */
		function area() {                     
			return $this->width*$this->height;       //访问该方法时，返回矩形的面积
		}

		/* 按矩形周长的计算公式，实现抽象类shape中的抽象方法perimeter() */
		function perimeter() {         
			return 2*($this->width+$this->height);   //访问该方法时，返回矩形的周长
		}
	}


```


```php
<?php	
	/**
		Project: 面向对象版图形计算器 
		file: triangle.class.php
		声明了一个三角形子类，根据三角形的特点实现了形状抽象类中的周长和面积方法
		package:shape
	 */
	class Triangle extends Shape {  	
		private $side1 = 0;                           //声明三角形第一个边的成员属性
		private $side2 = 0;                           //声明三角形第二个边的成员属性
		private $side3 = 0;                           //声明三角形第三个边的成员属性

		/* 三角形的构造方法，用表单$_POST中接收的三边值初使化三角形对象 */
		function __construct() { 
			$this->shapeName = "三角形";         	 //为形状命名
			
			//通过从shape中继承的方法validate(),对三角形的第一边进行验证
			if($this->validate($_POST["side1"], "第一个边") & 
					$this->validate($_POST["side2"], "第二个边") & 
						$this->validate($_POST["side3"], "第三个边")) {
				//通过本类内部的私有方法validateSum(),验证三角形的两边之和是否大于第三边
				if($this->validateSum($_POST["side1"], $_POST["side2"], $_POST["side3"])) {
					$this->side1 = $_POST["side1"]; 		
					$this->side2 = $_POST["side2"]; 		
					$this->side3 = $_POST["side3"]; 		
				}else {
					echo '<font color="red" >三角形的两边之和要大于第三边</font><br>';
				}
			}
		}

		/* 按三角形面积的计算公式(海伦公式)，实现抽象类shape中的抽象方法area() */
		function area() {
			$s = ($this->side1+$this->side2+$this->side3)/2;
			//返回三角形的面积
			return sqrt( $s*($s - $this->side1)*($s - $this->side2)*($s - $this->side3) );  
		}

		/* 按三角形周长的计算公式，实现抽象类shape中的抽象方法perimeter() */
		function perimeter() {   
			return  $this->side1+$this->side2+$this->side3;        //返回三角形的周长
		}

		/* 本类内部声明一个私有方法validateSum(),用于验证三角形的两边之和是否大于第三边 */
		private function validateSum($s1, $s2, $s3){
			//如果三角形任意两个边的和大于第三个边返回true, 否则返回false
			if( (($s1 + $s2) > $s3) && (($s1 + $s3) > $s2) && (($s2 + $s3) > $s1) ) {
				return true;
			}else{
				return false;
			}	
		}
	}

	
	
	



```


```php
<?php
	/**
		Project: 面向对象版图形计算器
		file: circle.class.php
		声明了一个圆形子类, 按圆形的特点实现了形状抽象类Shape中的周长和面积
		package:shape
	*/
	class  Circle extends Shape {          
		private $radius = 0;                    //声明一个成员属性用于存储圆形的半径

		/* 圆形的构造方法，用表单$_POST中接收的半径初使化圆形对象*/
		function __construct() {     
			$this->shapeName = "圆形";    		//为形状命名

			//通过从shape中继承的方法validate(),对圆形的半径进行验证
			if( $this->validate($_POST['radius'], '半径') ) {
				$this->radius = $_POST['radius'];  
			}
		}
		
		/* 按圆形面积的计算公式，实现抽象类shape中的抽象方法area() */
		function area() {           
			return pi() * $this->radius * $this->radius;   //返回圆形的面积
		}

		/* 按圆形周长的计算公式，实现抽象类shape中的抽象方法perimeter() */
		function perimeter() {      
			return 2 * pi() * $this->radius;              //返回圆形的周长
		}
	}	


```





#### 10.1.2 面向对象的程序设计  

---

### 10.2 如何抽象一个类  
#### 10.2.1 类的声明  
#### 10.2.2 成员属性  
#### 10.2.3 成员方法  

---

### 10.3 通过类实例化对象  
#### 10.3.1 实例化对象  
#### 10.3.2 对象类型在内存中的分配  
#### 10.3.3 对象中成员的访问  
#### 10.3.4 特殊的对象引用“$this”  
#### 10.3.5 构造方法与析构方法  

---

### 10.4 封装性  
#### 10.4.1 设置私有成员  
#### 10.4.2 私有成员的访问  
#### 10.4.3 __set()、__get()、__isset()和__unset()四个方法

---

### 10.5 继承性   
#### 10.5.1 类继承的应用  
#### 10.5.2 访问类型控制  
#### 10.5.3 子类中重载父类的方法  

---

### 10.6 常见的关键字和魔术方法  
#### 10.6.1 final关键字的应用  
#### 10.6.2 static关键字的使用  
#### 10.6.3 单态设计模式  
#### 10.6.4 const关键字  
#### 10.6.5 instanceof关键字  
#### 10.6.6 克隆对象  
#### 10.6.7 类中通用的方法__tostring()  
#### 10.6.8 __call()方法的应用  
#### 10.6.9 自动加载类  
#### 10.6.10 对象串行化  

---

### 10.7 抽象类与接口  
#### 10.7.1 抽象类  
#### 10.7.2 接口技术  

---

### 10.8 多态性的应用  

---

### 10.9 面向对象版图形计算器  
#### 10.9.1 需求分析  
#### 10.9.2 功能设计及实现  
#### 10.9.3 类的组织架构  

---

### 10.10 小结

---

- [ ] 本章必须掌握的知识点
- [ ] 本章需要了解的内容
- [ ] 本章需要拓展的内容
- [ ] 本章的学习建议
